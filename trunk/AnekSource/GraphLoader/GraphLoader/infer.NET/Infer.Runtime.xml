<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Infer.Runtime</name>
    </assembly>
    <members>
        <member name="T:MicrosoftResearch.Infer.Factors.ReplicateOp">
            <summary>
            Messages from random variables that are defined by deterministic factors.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.MarginalAverageConditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            EP message to 'Marginal'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.MarginalAverageConditional``1(``0[],``0,``0)">
            <summary>
            EP message to 'Marginal'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesAverageConditional``3(``1,``0,``2)">
            <summary>
            EP message to 'Uses'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing messages are the products of all incoming messages except the indexed uses message.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesAverageConditional``2(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'Uses'.
            The formula is <c>int f(Uses,x) q(x) dx</c> where <c>x = (Def)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesAverageConditional``1(``0[],``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'Uses'.
            The formula is <c>int f(Uses,x) q(x) dx</c> where <c>x = (Def)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefAverageConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            EP message to 'Def'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'Def'.
            The formula is <c>int f(Def,x) q(x) dx</c> where <c>x = (Uses)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefAverageConditional``1(``0[],``0)">
            <summary>
            EP message to 'Def'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'Def'.
            The formula is <c>int f(Def,x) q(x) dx</c> where <c>x = (Uses)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.GibbsEvidence``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Evidence message for Gibbs - not supported.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.LogEvidenceRatio``2(System.Collections.Generic.IList{``0},``1)">
            <summary>
            Evidence message for Gibbs - not supported.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesGibbs``3(System.Collections.Generic.IList{``0},``0,``1,System.Int32,``2)">
            <summary>
            Gibbs sample message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="TMarginalDist">Gibbs marginal type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'</param>
            <param name="Def">Incoming message from 'Def'</param>
            <param name="marginal">The Gibbs marginal</param>
            <param name="resultIndex">'Uses' index for result (unused)</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesGibbs``2(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            Gibbs distribution message to 'Uses' for ReplicateWithMarginal
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="resultIndex">'Uses' index for result</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the product of the 'Def' message with all 'Uses' messages except the current
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefGibbs``3(System.Collections.Generic.IList{``0},``1,``2)">
            <summary>
            Gibbs sample message to 'Def'
            </summary>
            <typeparam name="TDist">Uses type</typeparam>
            <typeparam name="TMarginalDist">Gibbs marginal type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'</param>
            <param name="marginal">The Gibbs marginal</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefGibbs``2(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of all the 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefGibbs``2(``0[],``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of all the 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.MarginalGibbs``3(System.Collections.Generic.IList{``1},``1,``0)">
            <summary>
            Gibbs message to 'Marginal'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of 'Def' and 'Uses' messages.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (Uses,Def)</c>.
            </para></remarks> 
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.MarginalAverageLogarithm``2(``1,``0)">
            <summary>
            
            </summary>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesAverageLogarithm``2(``1,System.Int32,``0)">
            <summary>
            VMP message to 'Uses'.
            </summary>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Uses'.
            The formula is <c>int log(f(Uses,x)) q(x) dx</c> where <c>x = (Def)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.UsesAverageLogarithm``2(``1,``0)">
            <summary>
            VMP message to 'Uses'.
            </summary>
            <param name="Def">Incoming message from 'Def'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Uses'.
            The formula is <c>int log(f(Uses,x)) q(x) dx</c> where <c>x = (Def)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Def"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefAverageLogarithm``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'Def'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Def'.
            The formula is <c>int log(f(Def,x)) q(x) dx</c> where <c>x = (Uses)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ReplicateOp.DefAverageLogarithm``1(``0[],``0)">
            <summary>
            VMP message to 'Def'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Def'.
            The formula is <c>int log(f(Def,x)) q(x) dx</c> where <c>x = (Uses)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UsesEqualDefOp">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.MarginalAverageConditional``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            EP message to 'Marginal'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of 'Def' and 'Uses' messages.
            </para></remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.MarginalAverageConditional``1(``0[],``0,``0)" -->
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.UsesAverageConditional``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of the 'Def' message and all 'Uses' messages except the indexed one.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.UsesAverageConditional``1(``0[],``0,System.Int32,``0)">
            <summary>
            EP message to 'Uses'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of the 'Def' message and all 'Uses' messages except the indexed one.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.DefAverageConditional``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            EP message to 'Def'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of all 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.GibbsEvidence``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Evidence message for EP - not supported
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.GibbsEvidence``2(System.Collections.Generic.IList{``0},``1)">
            <summary>
            Evidence message for EP - not supported
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.MarginalGibbs``3(System.Collections.Generic.IList{``1},``1,``0)">
            <summary>
            Gibbs message to 'Marginal'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of 'Def' and 'Uses' messages.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.UsesGibbs``3(System.Collections.Generic.IList{``0},``0,``1,System.Int32,``2)">
            <summary>
            Gibbs sample message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="TMarginalDist">Gibbs marginal type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'</param>
            <param name="Def">Incoming message from 'Def'</param>
            <param name="marginal">The Gibbs marginal</param>
            <param name="resultIndex">'Uses' index for result (unused)</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.UsesGibbs``2(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="resultIndex">'Uses' index for result</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the product of the 'Def' message with all 'Uses' messages except the current
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.DefGibbs``3(System.Collections.Generic.IList{``0},``1,``2)">
            <summary>
            Gibbs sample message to 'Def'
            </summary>
            <typeparam name="TDist">Uses type</typeparam>
            <typeparam name="TMarginalDist">Gibbs marginal type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'</param>
            <param name="marginal">The Gibbs marginal</param>
            <param name="result">Result</param>
            <returns></returns>
            <remarks><para>
            The outgoing message is the current Gibbs sample.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.DefGibbs``2(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Gibbs distribution message to 'Def'
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain type</typeparam>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the product of all the 'Uses' messages.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.AverageLogFactor``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (Uses,Def,Marginal)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.MarginalAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            VMP message to 'Marginal'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Marginal'.
            The formula is <c>int log(f(Marginal,x)) q(x) dx</c> where <c>x = (Uses,Def)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.UsesAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            VMP message to 'Uses'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Uses'.
            The formula is <c>int log(f(Uses,x)) q(x) dx</c> where <c>x = (Def,Marginal)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UsesEqualDefOp.DefAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,``0)">
            <summary>
            VMP message to 'Def'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Def'.
            The formula is <c>int log(f(Def,x)) q(x) dx</c> where <c>x = (Uses,Marginal)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.VectorGaussian">
            <summary>
            Represents a multivariate Gaussian distribution.
            </summary>
            <remarks><para>
            The distribution is parameterized by MeanTimesPrecision and Precision.
            Precision is the inverse of the variance, so a Gaussian with mean m and variance v is
            represented as Precision = inv(v), MeanTimesPrecision = inv(v)*m.
            </para><para>
            Some special cases:
            If the precision is zero, then the distribution is uniform.
            If the precision is infinite along the diagonal, then the distribution is a point mass.  The Point property
            gives the location of the point mass.
            If precision[i,i] is infinite, then the distribution is a point mass along dimension i.  Point[i] gives the mean.
            The rest of the row and column of precision must be zero.
            </para><para>
            The formula for the distribution is:
            <c>N(x;m,v) = |2*pi*v|^(-d/2) * exp(-0.5 (x-m)' inv(v) (x-m))</c>.
            When v=0, this reduces to delta(x-m).
            When v=infinity, the density is redefined to be 1.
            When v is singular, the density is redefined to be <c>exp(-0.5 x' inv(v) x + x' inv(v) m)</c>, 
            i.e. we drop the terms <c>|2*pi*v|^(-d/2) * exp(-0.5 m' inv(v) m)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IDistribution`1">
            <summary>Distribution interface</summary>
            <typeparam name="T">The type of objects in the domain, e.g. Vector or Matrix.</typeparam>
            <remarks><para>
            T should generally have value semantics, i.e. it should override Equals to use value equality.
            Otherwise it implies a Distribution over references.
            </para><para>
            In addition to this interface, Distributions should override Equals to 
            use value equality.  
            A typical implementation of Equals is: <c>MaxDiff(that) == 0.0</c>
            </para><para>
            To be generally used by message-passing algorithms, a distribution should also implement the
            following interfaces:
            <c>SettableTo, SettableToProduct, SettableToRatio, SettableToPower, SettableToWeightedSum,
            CanGetLogAverageOf, CanGetAverageLog</c>
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetDomainPrototype">
            <summary>
            Whether the distribution supports getting a domain prototype
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetDomainPrototype.GetDomainPrototype">
            <summary>
            Get the default value in the domain.
            </summary>
            <remarks>This is a convenience for model construction, so that specifying the distribution 
            of a variable automatically determines its type.  See Models.UnaryFactor.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.HasPoint`1">
            <summary>
            Whether the distribution supports being a point mass
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.HasPoint`1.Point">
            <summary>
            Access the location of a point mass.
            </summary>
            <remarks><para>
            If the distribution parameters do not represent a point mass, 
            getting this property returns an undefined value (if T is a ValueType) 
            or a storage area with undefined contents (if T is a reference type).
            It should not throw an exception.
            Setting Point will change the distribution into a point mass, overriding any other 
            property settings.
            Note: Point = Point does have an effect!
            </para><para>
            If T is a reference type, then the result is volatile.  
            Its contents expire upon invoking any subsequent distribution method.
            </para><para>
            Point is a property because it is expected that each distribution would have a 
            corresponding data field.  Accessing the Point should take constant time.
            </para></remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.HasPoint`1.IsPointMass">
            <summary>
            Gets whether the distribution parameters represent a point mass.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Diffable">
            <summary>
            Interface which allows the calculation of a maximum difference between
            this instance and another object (not necessarily of the same type)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Diffable.MaxDiff(System.Object)">
            <summary>
            The maximum difference between this instance and the given
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SettableToUniform">
            <summary>
            Whether the distribution can be set to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SettableToUniform.SetToUniform">
            <summary>
            Set the distribution to be uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SettableToUniform.IsUniform">
            <summary>
            Ask whether the distribution instance is uniform
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogProb`1">
            <summary>
            Whether the distribution supports evaluation of its density
            </summary>
            <typeparam name="T">Domain type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogProb`1.GetLogProb(`0)">
            <summary>
            Evaluate the log of the density function at the specified domain value
            </summary>
            <param name="value">The value at which to calculate the density</param>
            <returns>The log density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ICursor.CreateSourceArray(System.Int32)">
            <summary>
            Point the cursor at a new source array.
            </summary>
            <remarks>
            The source array is allocated to have nRecords * Count positions.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ICursor.ReferenceClone">
            <summary>
            Make a new cursor object having the same source array, at the same position.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ICursor.Start">
            <summary>
            The position of the cursor in its source array.
            </summary>
            <remarks>
            Position is measured in the same units as Count.
            The instance data spans locations <c>Start, ..., Start+Count-1</c> in 
            the source array.
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.ICursor.Count">
            <summary>
            The number of positions in the source array that one instance consumes.
            </summary>
            <remarks>
            The cursor can be advanced to the next instance via
            <c>Start = Start + Count</c>.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableTo`1">
            <summary>
            Interface which allows an instance to be set to another instance of the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableTo`1.SetTo(`0)">
            <summary>
            Set the instance to the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToProduct`1">
            <summary>
            Interface which allows an instance to be set to the product of
            two instances of the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToProduct`2">
            <summary>
            Interface which allows an instance to be set to the product of
            two instances of different types
            </summary>
            <typeparam name="T">The first type</typeparam>
            <typeparam name="U">The second type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToProduct`2.SetToProduct(`0,`1)">
            <summary>
            Set this to the product of a and b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToRatio`1">
            <summary>
            Interface which allows an instance to be set to the ratio of
            two instances of the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToRatio`2">
            <summary>
            Interface which allows an instance to be set to the ratio of
            two instances of different types
            </summary>
            <typeparam name="T">The first type</typeparam>
            <typeparam name="U">The second type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToRatio`2.SetToRatio(`0,`1)">
            <summary>
            Set this to the ratio of a and b
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToPower`1">
            <summary>
            Interface which allows an instance to be set to the power of
            another instancesof the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToPower`1.SetToPower(`0,System.Double)">
            <summary>
            Set this to the given value raised to the given power
            </summary>
            <param name="value"></param>
            <param name="exponent"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.SettableToWeightedSum`1">
            <summary>
            Interface which allows an instance to be set to the weighted sum of
            two instances of the same type
            </summary>
            <typeparam name="T">The type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.SettableToWeightedSum`1.SetToSum(System.Double,`0,System.Double,`0)">
            <summary>
            Set the parameters to best match a mixture distribution.
            </summary>
            <param name="weight1">A finite nonnegative weight.</param>
            <param name="weight2">A finite nonnegative weight.</param>
            <param name="value1"></param>
            <param name="value2"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Sampleable`1">
            <summary>
            Whether the distribution supports sampling
            </summary>
            <typeparam name="T">The sample type (i.e. the domain type)</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Sampleable`1.Sample">
            <summary>
            Sample the distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Sampleable`1.Sample(`0)">
            <summary>
            Sample the distribution and provide a place to put the result.
            </summary>
            <param name="result">Where to put the result. This is ignored for value-type domains</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanSamplePrep`2">
            <summary>
            Whether the distribution supports preallocation of a workspace for sampling
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanSamplePrep`2.SamplePrep">
            <summary>
            Return an sampler delegate which owns an sampling workspace
            </summary>
            <returns>An sampler delegate</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogProbPrep`2">
            <summary>
            Whether the distribution supports preallocation of a workspace for density evaluation
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogProbPrep`2.GetLogProbPrep">
            <summary>
            Return an evaluator delegate which owns an evaluation workspace
            </summary>
            <returns>An evaluator delegate</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetMean`1">
            <summary>
            Whether the distribution supports retrieval of a mean value
            </summary>
            <typeparam name="MeanType">Type of the mean value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetMean`1.GetMean">
            <remarks><para>
            </para><para>
            This is not a property because it is not reasonable to expect that distributions
            would generally have their mean as a data member.  Computing the mean could take a long
            time for some distributions.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetVariance`1">
            <summary>
            Whether the distribution supports retrieval of a variance value
            </summary>
            <typeparam name="VarType">Type of the variance value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetVariance`1.GetVariance">
            <summary>
            Method to get the variance
            </summary>
            <returns>The variance</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2">
            <summary>
            Whether the distribution supports the joint getting of mean and variance
            where the mean and variance are reference types
            </summary>
            <typeparam name="MeanType">Mean type</typeparam>
            <typeparam name="VarType">Variance type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2.GetMeanAndVariance(`0,`1)">
            <summary>
            Get the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2">
            <summary>
            Whether the distribution supports the joint setting of mean and variance
            </summary>
            <typeparam name="MeanType"></typeparam>
            <typeparam name="VarType"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2.SetMeanAndVariance(`0,`1)">
            <summary>
            Set the parameters to produce a given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <remarks>In cases where the given mean and variance cannot be matched exactly, the mean
            should have priority.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOf`1">
            <summary>
            Whether the distribution can compute the expectation of another distribution's value.
            </summary>
            <typeparam name="T">The other distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOf`1.GetLogAverageOf(`0)">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetAverageLog`1">
            <summary>
            Whether the distribution supports the expected logarithm of one instance under another
            </summary>
            <typeparam name="T">The distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetAverageLog`1.GetAverageLog(`0)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogNormalizer">
            <summary>
            Whether the distribution can compute its normalizer.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogNormalizer.GetLogNormalizer">
            <summary>
            The logarithm of the distribution's normalizer, i.e. the integral of its minimal exponential-family representation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean and variance of the distribution.
            </summary>
            <param name="mean">Modified to contain the mean.  Must already be the correct size.</param>
            <param name="variance">Modified to contain the covariance matrix.  Must already be the correct size.</param>
            <remarks>Because the Gaussian stored its parameters in exponential form, it is more efficient
            to compute the mean and variance at the same time rather than separately.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMeanAndPrecision(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean vector and precsion matrix of the distribution
            </summary>
            <param name="mean">Modified to contain the mean.  Must already be the correct size.</param>
            <param name="precision">Modified to contain the precision matrix.  Must already be the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the mean and variance of the distribution.
            </summary>
            <param name="mean">The mean vector</param>
            <param name="variance">The covariance matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetMeanAndPrecision(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the mean and precision of the distribution.
            </summary>
            <param name="mean">The mean vector</param>
            <param name="precision">The precision matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetNatural(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the natural parameters of the distribution (mean times precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">The precision matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMean">
            <summary>
            Gets the mean of the distribution.
            </summary>
            <returns>A new Vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the mean of the distribution
            </summary>
            <param name="mean">Where to place the mean value</param>
            <returns>mean</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetVariance">
            <summary>
            Gets the variance-covariance matrix of the distribution.
            </summary>
            <returns>A new PositiveDefiniteMatrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the variance-covariance matrix of the distribution.
            </summary>
            <param name="variance">Where to place the variance-covariance</param>
            <returns>variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing mean vector
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetDomainPrototype">
            <summary>
            Gets a domain prototype. The domain for the Gaussian distribution is
            a multi-dimensional space of reals - vector of zeroes of the correct size is returned.
            </summary>
            <returns>Vector of zeroes</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToUniform">
            <summary>
            Sets this VectorGaussian instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evaluate the log of multivariate Gaussian density with specified mean vector
            and covariance matrix
            </summary>
            <param name="x">Where to evaluate the density function</param>
            <param name="mean">The mean vector</param>
            <param name="variance">A non-singular covariance matrix.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogNormalizer">
            <summary>
            Gets the normalizer for the VectorGaussian density function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the multivariate Gaussian density.
            </summary>
            <param name="x">Point to evaluate the density at.</param>
            <param name="meanTimesPrecision">Precision matrix times the mean vector.</param>
            <param name="precision">A non-singular precision matrix (inverse of covariance matrix).</param>
            <param name="L">Same size as precision.</param>
            <param name="iLb">Same size as x.</param>
            <returns>log p(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the multivariate Gaussian density.
            </summary>
            <param name="x">Point to evaluate the density at.</param>
            <param name="L">Work matrix - same size as Precision</param>
            <param name="iLb">Work vector - same size as x</param>
            <returns>log p(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProb(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the multivariate Gaussian density.
            </summary>
            <param name="x">Point to evaluate the density at.</param>
            <returns>log p(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogProbPrep">
            <summary>
            Returns an Evaluator delegate which has a pre-allocated workspace
            for efficient evaluation calculation. If you are generating many
            evaluations, call this method to get an Evaluator, then use the Evaluator
            delegate to calculate the evaluations
            </summary>
            <returns>Evaluator delegate</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetAverageLog(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Log-integral of the product of this VectorGaussian with that VectorGaussian
            </summary>
            <param name="that">That VectorGaussian</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples from a VectorGaussian distribution with the specified mean and precision
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Samples from this VectorGaussian distribution
            </summary>
            <param name="result">Where to put the result</param>
            <param name="precL">A DxD workspace</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Samples from this VectorGaussian distribution
            </summary>
            <param name="result">Where to put the result</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Sample">
            <summary>
            Sample from this VectorGaussian distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SamplePrep">
            <summary>
            Returns a sampler delegate which has a pre-allocated workspace
            for efficient sample calculation. If you are generating many
            samples, call this method to get a sampler, then use the sampler
            delegate to generate samples.
            </summary>
            <returns>Sampler delegate</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetTo(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets this VectorGaussian instance to have the parameter values of that VectorGaussian instance
            </summary>
            <param name="that">That VectorGaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets the parameters to represent the product of two VectorGaussians.
            </summary>
            <param name="g1">The first VectorGaussian</param>
            <param name="g2">The second VectorGaussian</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Creates a new VectorGaussian which the product of two other VectorGaussians
            </summary>
            <param name="a">First VectorGaussian</param>
            <param name="b">Second VectorGaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets the parameters to represent the product of two VectorGaussians.
            </summary>
            <param name="numerator">The numerator VectorGaussian</param>
            <param name="denominator">The denominator VectorGaussian</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.op_Division(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Creates a new VectorGaussian which the ratio of two other VectorGaussians
            </summary>
            <param name="numerator">numerator VectorGaussian</param>
            <param name="denominator">denominator VectorGaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToPower(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source VectorGaussian to some exponent.
            </summary>
            <param name="dist">The source VectorGaussian</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Sets the mean and covariance to match a VectorGaussian mixture.
            </summary>
            <param name="weight1">First weight</param>
            <param name="dist1">First VectorGaussian</param>
            <param name="weight2">Second weight</param>
            <param name="dist2">Second VectorGaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.WeightedSum``1(``0,System.Int32,System.Double,``0,System.Double,``0)">
            <summary>
            Creates a distribution of the specified type which matchs the mean and variance/covariance
            of a VectorGaussian mixture. The distribution type must implement <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2"/> and
            <see cref="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2"/>
            </summary>
            <typeparam name="T">Distribution type for the mixture</typeparam>
            <param name="dimension">The dimension of the domain</param>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
            <param name="result">Resulting distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this VectorGaussian
            and that VectorGaussian
            </summary>
            <param name="thatd">That VectorGaussian</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.CreateSourceArray(System.Int32)">
            <summary>
            Creates the <see cref="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.SourceArray"/> for storing the VectorGaussian parameters
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.ReferenceClone">
            <summary>
            Creates a clone of this instance, copying VectorGaussian parameters as references
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Clone">
            <summary>
            Clones this VectorGaussian. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a VectorGaussian type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor">
            <summary>
            Constructs a new VectorGaussian
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(System.Int32)">
            <summary>
            Creates a uniform VectorGaussian of a given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.Uniform(System.Int32)">
            <summary>
            Creates a uniform VectorGaussian of a given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromCursors(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a Gaussian from Cursor objects.
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">Precision</param>
            <remarks>The cursors will use their existing source array.
            The Gaussian will reference the given cursors.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a Gaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gaussian instance.</returns>
            <remarks>The mean and variance objects are copied into the Gaussian and not referenced afterwards.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.PointMass(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a VectorGaussian point mass at the specified location
            </summary>
            <param name="mean">Where to position the point mass</param>
            <returns>A new point mass VectorGaussian</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.PointMass(System.Double)">
            <summary>
            Creates a VectorGaussian point mass where the location is a
            vector of identical values
            </summary>
            <param name="mean">The value for the mean vector</param>
            <returns>A new point mass VectorGaussian</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.#ctor(System.Double,System.Double)">
            <summary>
            Creates a 1D VectorGaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromNatural(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Create a new VectorGaussian from its natural parameters (Mean times precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">Precision matrix</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a 1D VectorGaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Create a Gaussian with given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gaussian instance.</returns>
            <remarks>The mean and variance objects are copied into the Gaussian and not referenced afterwards.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndPrecision(System.Double,System.Double)">
            <summary>
            Creates a 1D VectorGaussian with given mean and precision.
            </summary>
            <param name="mean">Mean</param>
            <param name="precision">Precision</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.FromMeanAndPrecision(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Create a VectorGaussian with given mean and precision matrix.
            </summary>
            <param name="mean">Mean</param>
            <param name="precision">Precision</param>
            <returns>A new VectorGaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.IsProper">
            <summary>
            Asks whether this VectorGaussian instance is proper or not. A VectorGaussian distribution
            is proper only if its precision matrix is positive definite.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussian.GetMarginal(System.Int32)">
            <summary>
            The marginal distribution of one dimension.
            </summary>
            <param name="dim"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.MeanTimesPrecision">
            <summary>
            Gets/Sets Mean times precision
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Precision">
            <summary>
            Gets/sets precision value
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Dimension">
            <summary>
            The dimension of the VectorGaussian domain
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.SourceArray">
            <summary>
            Gets/sets the source array for the VectorGaussian parameters. These are stored
            contiguously in the SourceArray as MeanTimesPrecision followed by Precision
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Count">
            <summary>
            This is part of the <see cref="T:MicrosoftResearch.Infer.Collections.ICursor"/> interface. It returns the total count of elements in
            the VectorGaussian parameters, which are stored in <see cref="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.SourceArray"/>
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.Start">
            <summary>
            This is part of the <see cref="T:MicrosoftResearch.Infer.Collections.ICursor"/> interface. It returns the start index of the
            the VectorGaussian parameters as stored in <see cref="P:MicrosoftResearch.Infer.Distributions.VectorGaussian.SourceArray"/>
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray`1">
            <summary>
            Array of distribution objects that supports common distribution methods.
            </summary>
            <typeparam name="T">The distribution type.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.IArray`1.GetLength(System.Int32)">
            <summary>
            Get the size of a specified dimension of a multidimensional array.
            </summary>
            <param name="dimension">Zero-based dimension of the array.</param>
            <returns>The size of the specified dimension of the array.</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.IArray`1.Rank">
            <summary>
            Get the number of dimensions of the array.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ConvertibleToArray">
            <summary>
            Indicates if the object can convert to and from an array.
            </summary>
            <remarks>
            Possessing this interface implies that the object also has a constructor accepting an array type,
            such that <c>new T(this.ToArray())</c> is equivalent to <c>this.Clone()</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array`1.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array`1.Clone">
            <summary>
            Clone the array but not the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor(System.Int32)">
            <summary>
            Creates a distribution array of a specified length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor(`0[])">
            <summary>
            Creates a distribution array from an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.SetToUniform">
            <summary>
            Sets all distributions in the array to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.IsUniform">
            <summary>
            Asks whether all distributions in a list are uniform
            </summary>
            <returns>True if all uniform. GFalse otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`1.MaxDiff(System.Object)">
            <summary>
            The maximum difference across all corresponding distributions in
            this distribution array and that distribution array
            </summary>
            <param name="that">That distribution array</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray`2">
            <summary>
            An extension of DistributionArray that implements IDistribution and Sampleable
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="DomainType"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor(System.Int32)">
            <summary>
            Creates a distribution array of a specified length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor(`0[])">
            <summary>
            Creates a distribution array from an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.GetDomainPrototype">
            <summary>
            Gets a domain prototype for a distribution array
            </summary>
            <returns>An array of domain prototypes</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.GetLogProb(`1[])">
            <summary>
            Logarithm of the distribution array density function
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.Sample">
            <summary>
            Get a sample from the distribution array
            </summary>
            <returns>An array of samples</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray`2.Sample(`1[])">
            <summary>
            Get a sample from the distribution array
            </summary>
            <param name="result">Where to put the results</param>
            <returns>An array of samples</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray`2.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray`2.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2">
            <summary>
            Array of distributions requiring the distribution type to be a value type.
            </summary>
            <typeparam name="T">Distribution type.  Must be a value type all the way down, i.e. must not hold any references.</typeparam>
            <typeparam name="DomainType"></typeparam>
            <remarks>
            An extension of DistributionArray that requires T to be a value type.
            This class only exists for efficiency, to avoid unnecessary cloning.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(System.Int32)">
            <summary>
            Create a new distribution struct array of a specified length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(System.Int32,System.Converter{System.Int32,`0})">
            <summary>
            Create a new distribution struct array of a specified length and initial values.
            </summary>
            <param name="length"></param>
            <param name="init">Function that maps an index to a value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(`0,System.Int32)">
            <summary>
            Create a new distribution struct array of a specified value and length
            </summary>
            <param name="value"></param>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(`0[])">
            <summary>
            Create a new distribution struct array from an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.Clone">
            <summary>
            Clones the array but not the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.MaxDiff(System.Object)">
            <summary>
            The maximum difference across all corresponding distributions in
            this distribution array and that distribution array
            </summary>
            <param name="that">That distribution array</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            Sets this distribution struct array to another distribution struct array
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a product of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a ratio of the corrresponding distributions in two given
            distribution arrays
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},System.Double)">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a power of the corresponding element in a source distribution array
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a weighted sum of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For a DistributionArray, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionStructArray{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For a DistributionArray, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2">
            <summary>
            Array of distribution objects requiring the distribution type to be a distribution wrapper type
            </summary>
            <typeparam name="T">Distribution type.</typeparam>
            <typeparam name="DomainType"></typeparam>
            <remarks>
            An extension of DistributionArray that requires T to implement IsDistributionWrapper
            and other wrapper interfaces.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IsDistributionWrapper">
            <summary>
            Marker interface for classes which wrap distributions
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanMultiplyIntoTarget`1">
            <summary>
            Whether this instance can be multiplied with an instance of type T
            and assigned to a target of type T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanMultiplyIntoTarget`2">
            <summary>
            Whether this instance can be multiplied with an instance of type
            U and assigned to a target of type T
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="U"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanMultiplyIntoTarget`2.MultiplyIntoTarget(`0,`1)">
            <summary>
            Multiply this instance with another instance into a target
            </summary>
            <param name="target"></param>
            <param name="other"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanSetTarget`1">
            <summary>
            Whether this instance can be assigned to a target of type T
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanSetTarget`1.SetTarget(`0)">
            <summary>
            Can set target with this instance
            </summary>
            <param name="target"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanPostUpdateWith`1">
            <summary>
            Allows a distribution to update its state after a series of operations
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanPostUpdateWith`1.PostUpdateWith(`0)">
            <summary>
            Update a distribution's state from another distribution
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanPostUpdate">
            <summary>
            Allows a distribution to update its state after a series of operations
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanPostUpdate.PostUpdate">
            <summary>
            Update a distribution's state
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.#ctor(System.Int32)">
            <summary>
            Creates a distribution array of a given length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.#ctor(System.Int32,System.Converter{System.Int32,`0})">
            <summary>
            Create a distribution array of a given length and initial values.
            </summary>
            <param name="length"></param>
            <param name="init">Function that maps an index to a value.</param>
            <remarks>
            The references returned by <paramref name="init"/> are not copied.  They are placed directly into the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.#ctor(`0,System.Int32)">
            <summary>
            Creates a distribution array with a given value and length
            </summary>
            <param name="value">The value</param>
            <param name="length">The length</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.#ctor(`0[])">
            <summary>
            Creates a distribution array from an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.InitializeTo(`0[])">
            <summary>
            Initialise the values in this distribution array to clones of the values in a given array of distributions
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetTo(`0[])">
            <summary>
            Sets the values in this array to clones of the given array of values
            Allocates new items only if they are null
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.InitializeTo(`0)">
            <summary>
            Initialise all the values in this array to clones of the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetTo(`0)">
            <summary>
            Sets the values in this array to clones of the given value
            Allocates new items only if they are null
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.CopyTo(`0[])">
            <summary>
            Copies clones of values in this array to the given array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetItemsOf(`0[])">
            <summary>
            Sets items of this array to clones of the values in the given array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetItemsOf(`0[],System.Int32)">
            <summary>
            Sets items of this array to clones of the values in the given array,
            staring at a given index in this array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at in this array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.CopyTo(`0[],System.Int32)">
            <summary>
            Copies clones of values in this array to the given array
            staring at a given index in the given array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at in this array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.Clone">
            <summary>
            Clones the array and the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray{`0,`1})">
            <summary>
            Sets this distribution array to the given distribution array
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetTo(MicrosoftResearch.Infer.Distributions.IDistribution{`1[]})">
            <summary>
            Sets this distribution array to the given distribution array
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetToProduct``2(MicrosoftResearch.Infer.Distributions.DistributionArray{``0,`1},MicrosoftResearch.Infer.Distributions.DistributionArray{``1,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a product of the corrresponding distributions in two given
            distribution arrays
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetToProduct(MicrosoftResearch.Infer.Distributions.IDistribution{`1[]},MicrosoftResearch.Infer.Distributions.IDistribution{`1[]})">
            <summary>
            Set this lazy distribution array to a product of two distributions over
            the same domain array type
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionWrapperArray{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a product of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetToRatio``2(MicrosoftResearch.Infer.Distributions.DistributionArray{``0,`1},MicrosoftResearch.Infer.Distributions.DistributionArray{``1,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a ratio of the corrresponding distributions in two given
            distribution arrays
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetToRatio(MicrosoftResearch.Infer.Distributions.IDistribution{`1[]},MicrosoftResearch.Infer.Distributions.IDistribution{`1[]})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a ratio of the corrresponding distributions in two given
            distribution arrays
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionWrapperArray{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a ratio of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.MultiplyIntoTarget``2(MicrosoftResearch.Infer.Distributions.DistributionArray{``0,`1},MicrosoftResearch.Infer.Distributions.DistributionArray{``1,`1})">
            <summary>
            This distribution array multiplies itself with the secondary distribution array and
            puts its results into the target
            </summary>
            <param name="target">The target of the multiplication</param>
            <param name="other">The secondary factor</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.MultiplyIntoTarget(MicrosoftResearch.Infer.Distributions.IDistribution{`1[]},MicrosoftResearch.Infer.Distributions.IDistribution{`1[]})">
            <summary>
            This distribution array multiplies itself with the secondary distribution array and
            puts its results into the target
            </summary>
            <param name="target">The target of the multiplication</param>
            <param name="other">The secondary factor</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetTarget(MicrosoftResearch.Infer.Distributions.IDistribution{`1[]})">
            <summary>
            Sets the target distribution array with this distribution array
            </summary>
            <param name="target">The target array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray{`0,`1},System.Double)">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a power of the corresponding element in a source distribution array
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionWrapperArray{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionWrapperArray{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a weighted sum of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For a DistributionArray, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For a DistributionArray, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.PostUpdate">
            <summary>
            Allow distribution to update itself
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.PostUpdate``1(MicrosoftResearch.Infer.Distributions.DistributionArray{``0,`1})">
            <summary>
            Post update distribution from another distribution
            </summary>
            <typeparam name="T1"></typeparam>
            <param name="dist"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray`2.PostUpdateWith(MicrosoftResearch.Infer.Distributions.IDistribution{`1[]})">
            <summary>
            Post update distribution from another distribution
            </summary>
            <param name="dist"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2">
            <summary>
            Array of distribution objects.
            </summary>
            <typeparam name="T">Distribution type.</typeparam>
            <typeparam name="DomainType"></typeparam>
            <remarks>
            An extension of DistributionArray that requires T to be a reference type.
            The SetTo and CopyTo methods are overriden to use cloning instead of assignment.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(System.Int32)">
            <summary>
            Creates a distribution array given a length
            </summary>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(System.Int32,System.Converter{System.Int32,`0})">
            <summary>
            Create a distribution struct array of a specified length and initial values.
            </summary>
            <param name="length"></param>
            <param name="init">Function that maps an index to a value.</param>
            <remarks>
            The references returned by <paramref name="init"/> are not copied.  They are placed directly into the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(`0,System.Int32)">
            <summary>
            Creates a new distribution array given a value and a length
            </summary>
            <param name="value"></param>
            <param name="length"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(`0[])">
            <summary>
            Creates a new distribution array given an array of distributions
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.#ctor(MicrosoftResearch.Infer.Collections.Array{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.InitializeTo(`0[])">
            <summary>
            Initialise the values in this distribution array to clones of the values in a given array of distributions
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetTo(`0[])">
            <summary>
            Sets the values in this array to clones of the given array of values
            Allocates new items only if they are null
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.InitializeTo(`0)">
            <summary>
            Initialise all the values in this array to clones of the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetTo(`0)">
            <summary>
            Sets the values in this array to clones of the given value
            Allocates new items only if they are null
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.CopyTo(`0[])">
            <summary>
            Copies clones of values in this array to the given array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetItemsOf(`0[])">
            <summary>
            Sets items of this array to clones of the values in the given array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetItemsOf(`0[],System.Int32)">
            <summary>
            Sets items of this array to clones of the values in the given array,
            staring at a given index in this array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at in this array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.CopyTo(`0[],System.Int32)">
            <summary>
            Copies clones of values in this array to the given array
            staring at a given index in the given array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at in this array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.Clone">
            <summary>
            Clones the array and the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            Sets this distribution array to the given distribution array
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a product of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a ratio of the corrresponding distributions in two given
            distribution arrays
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},System.Double)">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a power of the corresponding element in a source distribution array
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a weighted sum of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For a DistributionArray, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionRefArray{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For a DistributionArray, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Discrete">
            <summary>
            An arbitrary distribution over integers [0,D-1].
            </summary>
            <remarks>
            The distribution is represented by a normalized Vector of length D.
            In the case of a point mass, the first element is infinity and the second element holds the point location.
            The probability of value x is available as this[x] or GetLogProb(x).
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Discrete.prob">
            <summary>
            Probability of each value (when not a point mass).
            </summary>
            <remarks>
            prob.Length == D.
            prob[i] >= 0.  sum_i prob[i] = 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetDomainPrototype">
            <summary>
            The domain of this distribution is the integer interval [0,D-1]. This
            returns 0 as a represntative domain value
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Clone">
            <summary>
            Clones this discrete distribution. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Discrete type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this discrete and that discrete
            </summary>
            <param name="that">That discrete</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="that">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToUniform">
            <summary>
            Sets this instance to a uniform discrete (i.e. probabilities all equal)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.IsUniform">
            <summary>
            Returns whether the discrete distribution is uniform or not
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogProb(System.Int32)">
            <summary>
            Evaluates the log density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The log density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogNormalizer">
            <summary>
            Gets the log normalizer of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Evaluate(System.Int32)">
            <summary>
            Evaluates the density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetAverageLog(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            The log of the integral of the product of this discrete and that discrete
            </summary>
            <param name="that">That discrete distribution</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.ProbEqual(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            The integral of the product between this discrete and that disrete. This
            is the probabity that samples from this instance and that instance are equal
            </summary>
            <param name="that">That discrete distribution</param>
            <returns>The inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetProbs">
            <summary>
            Gets the probability at each index.
            </summary>
            <returns>The vector of probabilities</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetProbs(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the probability at each index.
            </summary>
            <param name="result">When used internally, can be the same object as prob.</param>
            <returns>result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetLogProbs">
            <summary>
            Gets the vector of log probabilities for this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetWorkspace">
            <summary>
            Gets a Vector of size this.Dimension.
            </summary>
            <returns>A pointer to the internal probs Vector of the object.</returns>
            <remarks>
            This function is intended to be used with SetProbs, to avoid allocating a new Vector.
            The return value should not be interpreted as a probs vector, but only a workspace filled
            with unknown data that can be overwritten.  Until SetProbs is called, the distribution object 
            is invalid once this workspace is modified.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetProbs(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the probability of each index.
            </summary>
            <param name="probs">A vector of non-negative, finite numbers.  Need not sum to 1.</param>
            <remarks>
            Instead of allocating your own Vector to pass to SetProbs, you can call <see cref="M:MicrosoftResearch.Infer.Distributions.Discrete.GetWorkspace"/>,
            fill in the resulting Vector, and then pass it to SetProbs.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetTo(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">That instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToProduct(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the parameters to represent the product of two discrete distributions.
            </summary>
            <param name="a">The first discrete distribution</param>
            <param name="b">The second discrete distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.op_Multiply(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates a Discrete distribution which is the product of two Discrete distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the parameters to represent the ratio of two discrete distributions.
            </summary>
            <param name="numerator">The numerator discrete distribution</param>
            <param name="denominator">The denominator discrete distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.op_Division(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates a Discrete distribution which is the ratio of two Discrete distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToPower(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Sets the parameters to represent the power of a discrete distributions.
            </summary>
            <param name="dist">The discrete distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Discrete,System.Double,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Sets the parameters to represent the weighted sum of two discrete distributions.
            </summary>
            <param name="dist1">The first discrete distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second discrete distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Normalize">
            <summary>
            Normalizes this distribution - i.e. sets the probabilities to sum to 1.
            This is called internally after product operations, sum operations etc.
            </summary>
            <returns>The normalizing factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Sample">
            <summary>
            Returns a sample from this discrete distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Sample(System.Int32)">
            <summary>
            Returns a sample from this discrete distribution
            </summary>
            <param name="result">This parameter is ignored and is only present to support the Sampleable interface</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a sample from a discrete distribution with the specified probabilities
            </summary>
            <param name="probs">The parameters of the discrete distribution</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(System.Int32)">
            <summary>
            Creates a uniform Discrete distribution, from 0 to dimension-1.
            </summary>
            <param name="dimension"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Copy constructor
            </summary>
            <param name="that">The discrete instance to copy</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a Discrete distribution from the given probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.#ctor(System.Double[])">
            <summary>
            Creates a Discrete distribution from the given probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.PointMass(System.Int32,System.Int32)">
            <summary>
            Creates a Discrete distribution which allows only one value.
            </summary>
            <param name="value">The allowed value.</param>
            <param name="numValues">The number of values in the domain.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.Uniform(System.Int32)">
            <summary>
            Creates a uniform Discrete distribution over the values from 0 to numValues-1
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.ToString">
            <summary>
            Override of ToString method
            </summary>
            <returns>String representation of this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetMean">
            <summary>
            Gets the mean of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Discrete.GetVariance">
            <summary>
            Gets the variance of the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Dimension">
            <summary>
            Dimension of the discrete distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Point">
            <summary>
            Sets/gets this distribution as a point distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.IsPointMass">
            <summary>
            Whether or not this instance is a point mass.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Discrete.Item(System.Int32)">
            <summary>
            Gets or sets the probability at the given index.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Vector">
            <summary>
            1-dimensional container of double precision data.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.CreateSourceArray(System.Int32)">
            <summary>
            Creates a source array with a given number of records
            </summary>
            <param name="nRecords"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ReferenceClone">
            <summary>
            Creates a clone of this instance which references the source array
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GetEnumerator">
            <summary>
            Gets a typed enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator which yields the vector elements
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Contains(System.Double)">
            <summary>
            Returns true if the Vector contains the specified item value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies this vector to the given array starting at the specified index
            in the target array
            </summary>
            <param name="array">The target array</param>
            <param name="index">The start index in the target array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOf(System.Double)">
            <summary>
            Returns the index of the first occurence of the given value in the array.
            Returns -1 if the value is not in the array
            </summary>
            <param name="item">The item to check for</param>
            <returns>Its index in the array</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Append(System.Double)">
            <summary>
            Appends an item to a vector - returns a new vector
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Concat(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Create a vector by concatenating two vectors.
            </summary>
            <param name="first">First vector</param>
            <param name="second">Second vector</param>
            <returns>A new vector with all elements of the first vector followed by all elements of the second vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.#ctor(System.Int32)">
            <summary>
            Constructs a zero vector with the given number of elements.
            </summary>
            <param name="count">Number of elements to allocate (>= 0).</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.#ctor(System.Double[])">
            <summary>
            Constructs a vector from an array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.FromArray(System.Double[])">
            <summary>
            Constructs a vector from an array.
            </summary>
            <param name="data">1D array of elements.</param>
            <remarks>The array data is copied into new storage.
            The size of the vector is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.#ctor(System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a vector by referencing an array.
            </summary>
            <param name="data">Storage for the vector elements.</param>
            <param name="count">The number of elements in the vector.</param>
            <param name="start">The starting index in the array for the vector elements.</param>
            <remarks><para>
            The vector will not copy the array but only reference it, 
            so any numerical changes to the array will also apply to the vector.
            If the array grows larger, the extra elements are ignored.
            The array must not shrink or else the vector will become inconsistent.
            </para><para>
            Throws an exception if Data is null, start &lt; 0, or count &lt; 0.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.#ctor(System.Int32,System.Double)">
            <summary>
            Constructs a vector of a given length and assigns all elements the given value
            </summary>
            <param name="count"></param>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Clone">
            <summary>
            Clonse this vector - return as a vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.System#ICloneable#Clone">
            <summary>
            Clones this vector - return as an object
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToArray">
            <summary>
            Converts this vector to an array of doubles
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetTo(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Copies values from another vector.
            </summary>
            <param name="that">The second vector, which must have the same size as <c>this</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.EqualsAll(System.Double)">
            <summary>
            Tests if all elements are equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetTo(System.Double[])">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length matches <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSubarray(System.Double[],System.Int32)">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSubvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32)">
            <summary>
            Copies value from a vector.
            </summary>
            <param name="that">A vector whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Subvector(MicrosoftResearch.Infer.Maths.Vector,System.Int32,System.Int32)">
            <summary>
            Copy a subvector.
            </summary>
            <param name="that">A vector whose length is at least <c>count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="that"/> to copy.</param>
            <param name="count">The number of elements to copy.</param>
            <returns>A Vector of length <paramref name="count"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetSubvector(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set a subvector of this to another vector.
            </summary>
            <param name="startIndex">The index of the first element of <paramref name="this"/> to copy to.</param>
            <param name="that">A vector whose length is at most <c>this.Count - startIndex</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Sum">
            <summary>
            Returns the sum of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Median">
            <summary>
            Returns the median of all elements.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Max">
            <summary>
            Returns the maximum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Min">
            <summary>
            Returns the minimum of the elements in the vector
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.LogSumExp">
            <summary>
            Returns the log of the sum of exponentials of the elements of the vector
            computed to high accuracy
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToFunction(System.Converter{System.Double,System.Double},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the elements of this vector to a function of the elements of a given vector
            </summary>
            <param name="fun">The function which maps doubles to doubles</param>
            <param name="that">The given vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOfMinimum">
            <summary>
            Returns the index of the minimum element.
            </summary>
            <returns>The index of the minimum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.IndexOfMaximum">
            <summary>
            Returns the index of the maximum element.
            </summary>
            <returns>The index of the maximum element.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Inner(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of this vector with another vector.
            </summary>
            <param name="that">Second vector, which must have the same size as <c>this</c>.</param>
            <returns>Their inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.InnerProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product of two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>The inner product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Outer(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the outer product of this vector with another vector.
            </summary>
            <param name="that">Second vector.</param>
            <returns>Their outer product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDiagonal(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the diagonal of a matrix.
            </summary>
            <param name="m">A matrix with Rows==Cols==this.Count.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Scale(System.Double)">
            <summary>
            Multiplies this vector by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns>this</returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to a vector times a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToPower(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to the elementwise power of another vector.
            </summary>
            <param name="that">A vector, which must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="exponent">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="that"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise product of two other vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the elementwise ratio of two other vectors.
            </summary>
            <param name="a">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="b">Must have the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Multiply(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Multiplies every element of a vector by a scalar.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Multiply(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiply every element of this vector by a scalar.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_ExclusiveOr(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns a vector to some power.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A new vector with this[i] = Math.Pow(a[i],b).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Multiply(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the elementwise product of two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to the product of a matrix by a vector (i.e. A*x).
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this vector to the product of a vector by a matrix (i.e. x*A).
            </summary>
            <param name="x">A vector.  Cannot be <c>this</c>.</param>
            <param name="A">A matrix.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="x"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSum(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sets this vector to another vector plus a scalar.
            </summary>
            <param name="a">A vector, which must have the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="b">A scalar.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            If <c>this</c> and <paramref name="a"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Addition(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Add a scalar to every element of a vector.
            </summary>
            <param name="a">A vector.</param>
            <param name="b">A scalar.</param>
            <returns>A vector with the sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSum(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the sum if two other vectors.
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToSum(System.Double,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to a linear combination of two other vectors
            </summary>
            <param name="aScale">The multiplier for vector a</param>
            <param name="a">Vector a</param>
            <param name="bScale">The multiplier for vector b</param>
            <param name="b">Vector b</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Addition(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the sum of two vectors.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>The sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDifference(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this vector to the difference of two vectors
            </summary>
            <param name="a">First vector, which must have the same size as <c>this</c>.</param>
            <param name="b">Second vector, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> receives the difference, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDifference(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Set this vector to another vector minus a constant
            </summary>
            <param name="a">The other vector</param>
            <param name="b">The constant</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.SetToDifference(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set this vector to a constant minus another vector
            </summary>
            <param name="a">The constant</param>
            <param name="b">The other vector</param>
            <returns></returns>
            <remarks>Assumes the vectors are compatible</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Subtraction(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the difference of two vectors
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Subtraction(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Subtracts a scalar from each element of a vector.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">A scalar.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Subtraction(System.Double,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Subtracts a scalar from each element of a vector.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">A scalar.</param>
            <returns>The difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_UnaryNegation(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a vector which is the unary negation of a vector.
            </summary>
            <param name="a">The vector to negate.</param>
            <returns>The negation of a.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Equality(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Equality operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if the vectors have the same size and element values.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.op_Inequality(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Inequality operator.
            </summary>
            <param name="a">First vector.</param>
            <param name="b">Second vector.</param>
            <returns>True if vectors are not equal.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.Equals(System.Object)">
            <summary>
            Determines object equality.
            </summary>
            <param name="obj">Another (vector) object.</param>
            <returns>True if equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.GetHashCode">
            <summary>
            Gets a hash code for the instance.
            </summary>
            <returns>The code.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.CheckCompatible(MicrosoftResearch.Infer.Maths.Vector,System.String)">
            <summary>
            Checks that a given vector is the same size as this vector.
            Throws an exception if not with the given string
            </summary>
            <param name="that">The vector to check</param>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the maximum absolute difference between this vewctor and another vector.
            </summary>
            <param name="that">The second vector.</param>
            <returns><c>max(abs(this[i] - that[i]))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.MaxDiff(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Returns the maximum relative difference between this vector and another.
            </summary>
            <param name="that">The second vector.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>max(abs(this[i] - that[i])/(abs(this[i]) + rel))</c>. 
            Matching infinities or NaNs do not count.  
            If <c>this</c> and <paramref name="that"/> are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of <c>Equals</c>, since <c>Equals</c> is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideBy(MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Gets the solution to Ax=b, where A is an upper triangular matrix, and b is this vector.
            Equivalent to the left-division x = A\b.
            </summary>
            <param name="A">An upper triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideByTranspose(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to A'x=b, where A is a lower triangular matrix, and b is this vector.
            Equivalent to the left-division x = A'\b.
            </summary>
            <param name="A">A lower triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideBy(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to Ax=b, where A is a lower triangular matrix, and b is this vector.
            Equivalent to the left-division x = A\b.
            </summary>
            <param name="A">A lower triangular matrix.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side vector b, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Vector.PredivideBy(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Predivide this vector by the inverse of the given positive definite matrix
            </summary>
            <param name="A"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.SourceArray">
            <summary>
            Gets/sets source array for the vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.Count">
            <summary>
            Number of elements in the vector
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Vector.Start">
            <summary>
            Gets/sets the start index in the source arrat
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Lapack">
            <summary>
            Matrix implementations making use of Lapack
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Lapack.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets the matrix result to the product of the two matrix A and matrix B
            </summary>
            <param name="result">The result matrix</param>
            <param name="A">The first matrix</param>
            <param name="B">The second matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Lapack.SetToProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the vector result to the product of matrix A and vector b
            </summary>
            <param name="result">The resulting vector</param>
            <param name="A">The given matrix</param>
            <param name="v">The given vector</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Lapack.CholeskyInPlace(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Performs a Cholsky decomposition in place on matrix A
            </summary>
            <param name="A">The given matrix</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Lapack.PredivideBy(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Sets b to inv(A)*b.
            </summary>
            <param name="b"></param>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Lapack.PredivideBy(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Sets B to A\B.
            </summary>
            <param name="B"></param>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Lapack.PredivideByTranspose(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Pre-divides vector b by lower triangular matrix
            </summary>
            <param name="b"></param>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Lapack.PredivideByTranspose(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Sets B to A'\B.
            </summary>
            <param name="B"></param>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Lapack.PredivideBy(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Pre-divides vector b by upper triangular matrix A
            </summary>
            <param name="b"></param>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Lapack.PredivideBy(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Pre-divides matrix B by upper triangular matrix A
            </summary>
            <param name="B"></param>
            <param name="A"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.HashedList`1">
            <summary>
            Hash-indexed list.
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>
            The user can supply a list and it will be automatically indexed.
            However, only changes made through this interface will be indexed properly.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PoissonOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Poisson(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageConditional(System.Int32)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing EP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int f(mean,x) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <returns>The outgoing EP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int f(mean,x) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageLogarithm(System.Int32)">
            <summary>
            VMP message to 'mean'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing VMP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int log(f(mean,x)) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            VMP message to 'mean'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <returns>The outgoing VMP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int log(f(mean,x)) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PoissonOp.SampleAverageLogarithm(System.Double)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItemOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItem``1(System.Collections.Generic.IList{``0},System.Int32)"/>, given random arguments to the function.
            This factor gets an item from an array of items
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.LogEvidenceRatio``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="array">Incoming message from 'array'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ItemAverageConditional``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
            <summary>
            EP message to 'item'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'item'.
            The formula is <c>int f(item,x) q(x) dx</c> where <c>x = (array,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageConditional``2(``0,System.Int32,``1)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int f(array,x) q(x) dx</c> where <c>x = (item,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageConditional``2(`0,System.Int32,``1)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int f(array,x) q(x) dx</c> where <c>x = (item,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (item,array,index)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ItemAverageLogarithm``1(System.Collections.Generic.IList{``0},System.Int32,``0)">
            <summary>
            VMP message to 'item'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'item'.
            The formula is <c>int log(f(item,x)) q(x) dx</c> where <c>x = (array,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageLogarithm``2(``0,System.Int32,``1)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int log(f(array,x)) q(x) dx</c> where <c>x = (item,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemOp`1.ArrayAverageLogarithm``2(`0,System.Int32,``1)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int log(f(array,x)) q(x) dx</c> where <c>x = (item,index)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterPartialOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartial``1(System.Boolean[],``0,System.Int32[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GateEnterPartialOp.ForceProper">
            <summary>
            Force proper messages
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp.LogEvidenceRatio">
            <summary>
            Evidence message for EP.  Returns 0.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp.EnterPartialAverageConditional``2(``0,``1)">
            <summary>
            EP message to 'enterPartial'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'enterPartial'.
            The formula is <c>int f(enterPartial,x) q(x) dx</c> where <c>x = (cases,value,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (enterPartial,cases,value,indices)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp.EnterPartialAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'enterPartial'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'enterPartial'.
            The formula is <c>int log(f(enterPartial,x)) q(x) dx</c> where <c>x = (cases,value,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp.CasesAverageLogarithm``2(System.Collections.Generic.IList{``0},``0,System.Int32[],``1)">
            <summary>
            VMP message to 'cases'.
            </summary>
            <param name="enterPartial">Incoming message from 'enterPartial'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (enterPartial,value,indices)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialOp.ValueAverageLogarithm``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Int32[],``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="enterPartial">Incoming message from 'enterPartial'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = (enterPartial,cases,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enterPartial"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartialTwo``1(System.Boolean,System.Boolean,``0,System.Int32[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.LogEvidenceRatio">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="enterPartial">Incoming message from 'enterPartial'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enterPartial"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.EnterPartialTwoAverageConditional``2(``0,``1)">
            <summary>
            EP message to 'enterPartial'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'enterPartial'.
            The formula is <c>int f(enterPartial,x) q(x) dx</c> where <c>x = (cases,value,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (enterPartial,cases,value,indices)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.EnterPartialTwoAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'enterPartial'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'enterPartial'.
            The formula is <c>int log(f(enterPartial,x)) q(x) dx</c> where <c>x = (cases,value,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.Case0AverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32[],MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'cases'.
            </summary>
            <param name="enterPartial">Incoming message from 'enterPartial'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (enterPartial,value,indices)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterPartialTwoOp.ValueAverageLogarithm``1(System.Collections.Generic.IList{``0},MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32[],``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="enterPartial">Incoming message from 'enterPartial'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = (enterPartial,cases,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enterPartial"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterOneOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.EnterOne``1(System.Boolean[],``0,System.Int32)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GateEnterOneOp.ForceProper">
            <summary>
            Force proper messages
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp.LogEvidenceRatio">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp.EnterOneAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'enterOne'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'enterOne'.
            The formula is <c>int f(enterOne,x) q(x) dx</c> where <c>x = (cases,value,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp.ValueAverageConditional``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0,System.Int32,``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="enterOne">Incoming message from 'enterOne'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (enterOne,cases,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enterOne"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp.ValueAverageConditional``2(``0,System.Collections.Generic.IList{System.Boolean},``1,System.Int32,``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <typeparam name="TDomain">Domain type</typeparam>
            <param name="enterOne">Incoming message from 'enterOne'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="cases">Constant value from 'cases'.</param>
            <param name="value">Constant value from 'value'.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (enterOne,cases,value,index)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp.EnterOneAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'enterOne'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'enterOne'.
            The formula is <c>int log(f(enterOne,x)) q(x) dx</c> where <c>x = (cases,value,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp.CasesAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'cases'.
            </summary>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (enterOne,value,index)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOneOp.ValueAverageLogarithm``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Int32,``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="enterOne">Incoming message from 'enterOne'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = (enterOne,cases,index)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enterOne"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateEnterOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.Enter``1(System.Boolean[],``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp.LogEvidenceRatio">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp.EnterAverageConditional``2(``0,``1)">
            <summary>
            EP message to 'enter'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'enter'.
            The formula is <c>int f(enter,x) q(x) dx</c> where <c>x = (cases,value)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp.CasesAverageConditional``1(``0)">
            <summary>
            EP message to 'cases'.
            </summary>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enter"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp.ValueAverageConditional``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0,``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="enter">Incoming message from 'enter'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (enter,cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enter"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (enter,cases,value)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp.EnterAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'enter'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'enter'.
            The formula is <c>int log(f(enter,x)) q(x) dx</c> where <c>x = (cases,value)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp.CasesAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'cases'.
            </summary>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (enter,value)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateEnterOp.ValueAverageLogarithm``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="enter">Incoming message from 'enter'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = (enter,cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="enter"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.EnumSupport">
            <summary>
            Provides factors and operators for using Enum types.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumSupport.EnumToInt``1(``0)">
            <summary>
            Converts an Enum to an Int
            </summary>
            <param name="en"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumSupport.DiscreteEnum``1(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Samples an enum value from a discrete distribution.
            </summary>
            <typeparam name="TEnum">The type of the enum to sample</typeparam>
            <param name="probs">Vector of the probability of each Enum value, in order</param>
            <returns>An enum sampled from the distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumSupport.AreEqual``1(``0,``0)">
            <summary>
            Test if two enums are equal.
            </summary>
            <param name="a">First integer</param>
            <param name="b">Second integer</param>
            <returns>True if a==b.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.EnumToIntOp`1">
            <summary>
            Provides operators for converting from enums to ints.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.IntAverageConditional(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Converts DiscreteEnum to Discrete.
            </summary>
            <param name="Enum"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Converts Discrete to DiscreteEnum.
            </summary>
            <param name="Int"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.IntAverageLogarithm(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Converts DiscreteEnum to Discrete.
            </summary>
            <param name="Enum"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Converts Discrete to DiscreteEnum.
            </summary>
            <param name="Int"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.EnumToIntOp`1.EnumAverageLogarithm(System.Int32)">
            <summary>
            Converts int to DiscreteEnum point mass.
            </summary>
            <param name="Int"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichlet`1">
            <summary>
            Provides operators for discrete distributions over Enum values.
            </summary>
            <remarks>
            This class provides operators which have Enum arguments.  
            The rest are provided by DiscreteFromDirichlet.
            TODO: use of DiscreteFromDirichlet is disabled since it is not working due to a binding bug
            </remarks>
            
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichlet`1.LogEvidenceRatio(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichlet`1.LogEvidenceRatio(`0,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Constant value for 'probs'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteEnumFromDirichlet`1.ProbsAverageConditional(`0,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'probs'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'probs'.
            The formula is <c>int f(probs,x) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromBeta">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Bernoulli(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.LogAverageFactor(System.Boolean,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.LogEvidenceRatio(System.Boolean,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.SampleConditional(System.Double)">
            <summary>
            Gibbs message to 'sample'.
            </summary>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing Gibbs message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.SampleAverageConditional(System.Double)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.ProbTrueConditional(System.Boolean)">
            <summary>
            Gibbs message to 'probTrue'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing Gibbs message to the 'probTrue' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'probTrue' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.ProbTrueAverageConditional(System.Boolean)">
            <summary>
            EP message to 'probTrue'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing EP message to the 'probTrue' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'probTrue'.
            The formula is <c>int f(probTrue,x) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="probTrue">Incoming message from 'probTrue'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (probTrue)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.ProbTrueAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            EP message to 'probTrue'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
            <returns>The outgoing EP message to the 'probTrue' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'probTrue'.
            The formula is <c>int f(probTrue,x) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Incoming message from 'probTrue'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.AverageLogFactor(System.Boolean,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.SampleAverageLogarithm(System.Double)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="probTrue">Incoming message from 'probTrue'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (probTrue)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probTrue"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.ProbTrueAverageLogarithm(System.Boolean)">
            <summary>
            VMP message to 'probTrue'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <returns>The outgoing VMP message to the 'probTrue' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'probTrue'.
            The formula is <c>int log(f(probTrue,x)) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBeta.ProbTrueAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'probTrue'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'probTrue' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'probTrue'.
            The formula is <c>int log(f(probTrue,x)) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.EstimatorArray`2">
            <summary>
            Estimator array
            </summary>
            <typeparam name="T">Distribution array type</typeparam>
            <typeparam name="TDomain">Domain array type</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Estimator`1">
            <summary>
            Indicates support for retrieving an estimated distribution
            </summary>
            <typeparam name="T">Distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Estimator`1.GetDistribution(`0)">
            <summary>
            Retrieve the estimated distribution
            </summary>
            <param name="result">Where to put the result - ignored if the distribution type is a value type</param>
            <returns>The resulting estimated distribution</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Accumulator`1">
            <summary>
            Indicates support for adding an item to a distribution estimator
            </summary>
            <typeparam name="T">Type of item to add - could be a distribution type or a sample type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Accumulator`1.Add(`0)">
            <summary>
            Adds an item to the estimator
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Accumulator`1.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.DistributionPrototype">
            <summary>
            Distribution array prototype
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.DomainPrototype">
            <summary>
            Domain prototype
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.LeafDistributionType">
            <summary>
            Leaf distribution type
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.LeafDomainType">
            <summary>
            Leaf domain type
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.LeafEstimatorType">
            <summary>
            Leaf estimator type
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.DistributionArrayType">
            <summary>
            Type of (possibly jagged) array over distributions
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.Estimators">
            <summary>
            Array (possibly jagged) of leaf estimators
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.Distributions">
            <summary>
            Array (possibly jagged) of leaf distributions
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.EstimatorCreator">
            <summary>
            Estimator creator method
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.#ctor(`0)">
            <summary>
            Constructor from a distribution prototype
            </summary>
            <param name="dist"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.GetDistribution(`0)">
            <summary>
            Get the estimated distribution
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.Add(`1)">
            <summary>
            Accumulate a sample
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorArray`2.Clear">
            <summary>
            Clear the accumulators
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CreateEstimatorMethod">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.EstimatorFactory">
            <summary>
            Estimator factor. Given a distribution instance, create a compatible estimator instance
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorFactory.RegisterEstimator(System.Type,System.Type,MicrosoftResearch.Infer.Distributions.CreateEstimatorMethod)">
            <summary>
            Registers an estimator. The factory is primed with stock
            stock estimators. This function allows clients to add in custom
            estimators
            </summary>
            <param name="distType">Distribution type</param>
            <param name="estType">Estimator type</param>
            <param name="c">Method for creating the estimator</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorFactory.CreateEstimator``2(``0)">
            <summary>
            Creates an estimator instance from a distribution prototype
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TDomain"></typeparam>
            <param name="distProto">Distribution prototype</param>
            <returns>Estimator instance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.EstimatorFactory.EstimatorType(System.Type)">
            <summary>
            Creates an estimator instance from a distribution prototype
            </summary>
            <param name="distType">Distribution type</param>
            <returns>Estimator instance</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.EstimatorFactory.Instance">
            <summary>
            Estimator factory singleton instance
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ReducibleTo`1.ReduceTo(System.Int32[],MicrosoftResearch.Infer.Collections.ICursorArray{`0})">
            <summary>
            Remove dimensions via multiplication.
            </summary>
            <param name="keep">The dimensions to keep.</param>
            <param name="result">A distribution or distribution array.</param>
            <returns>An action which will perform the reduction.</returns>
            <remarks>Each element of result will be a product over the dimensions not kept.
            Result must already be the correct size.
            If keep is empty, no dimensions are kept so the result is a single distribution.
            Otherwise, result is a distribution array whose dimensions are the kept dimensions.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2">
            <summary>
            The distribution of an array of independent variables, or equivalently
            an array of distributions.
            </summary>
            <typeparam name="DistributionType"></typeparam>
            <typeparam name="DomainType"></typeparam>
            <remarks>
            This class supports all of the IDistribution methods, as well as 
            being a CursorArray<typeparamref name="DistributionType"/>.
            To support plates, it implements a ReduceTo method which removes 
            dimensions via multiplication.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.CursorArray`1">
            <summary>
            A multidimensional array of objects which share a single storage block.
            </summary>
            <remarks><para>
            A CursorArray is meant to behave like an ordinary Array, while being
            more memory-efficient.  Instead of storing multiple instances of the
            same object type, it uses a single instance as a cursor over a block
            of data.  The cursor acts like a pointer which is targeted at
            the desired part of the array (via its Start property).
            </para><para>
            The CursorArray object does not hold a pointer to the actual source data.
            It is agnostic about the actual type and layout of the 
            data that the cursor is walking over, providing a large degree of 
            flexibility in the implementation of the cursor.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.MoveTo(System.Int32[])">
            <summary>
            Position the cursor at a multidimensional index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.MoveTo(System.Int32)">
            <summary>
            Position the cursor at a linear index.
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.ForEach(MicrosoftResearch.Infer.Utils.Action)">
            <summary>
            Invoke an action for each element of an array.
            </summary>
            <param name="action">A delegate which accesses the array cursor.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.ForEach(MicrosoftResearch.Infer.Collections.ICursorArray,MicrosoftResearch.Infer.Utils.Action)">
            <summary>
            Invoke an element-wise action across two arrays.
            </summary>
            <param name="that">An array of the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="action">A delegate which accesses the array cursors.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.CursorArray`1.ForEach(MicrosoftResearch.Infer.Collections.ICursorArray,MicrosoftResearch.Infer.Collections.ICursorArray,MicrosoftResearch.Infer.Utils.Action)">
            <summary>
            Invoke an element-wise action across three arrays.
            </summary>
            <param name="a">An array of the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="b">An array of the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="action">A delegate which accesses the array cursors.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Item(System.Int32[])">
            <summary>
            Retrieve an object by multidimensional index.
            </summary>
            <remarks>
            The result is a volatile cursor object, which becomes invalid
            on the next indexer call.  This can be a source of bugs, e.g.
            <c>f(a[i],a[j])</c> will not work.  If you want to save a result 
            across calls, you must make a ReferenceClone, as in:
            <c>f(a[i].ReferenceClone(), a[j])</c>.
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Item(System.Int32)">
            <summary>
            Retrieve an object by linear index.
            </summary>
            <remarks><para>
            If the array is multidimensional, this will index the elements 
            sequentially in row-major order, i.e. the rightmost dimension varies
            fastest.
            </para><para>
            The result is a volatile cursor object, which becomes invalid
            on the next indexer call.  This can be a source of bugs, e.g.
            <c>f(a[i],a[j])</c> will not work.  If you want to save a result 
            across calls, you must make a ReferenceClone, as in:
            <c>f(a[i].ReferenceClone(), a[j])</c>.
            </para></remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Count">
            <summary>
            The total number of structures across all dimensions
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Lengths">
            <summary>
            The size of each dimension of the array.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.CursorArray`1.Rank">
            <summary>
            The number of dimensions of the array.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.ReduceTo(System.Int32[],MicrosoftResearch.Infer.Collections.ICursorArray{`0})">
            <summary>
            Apply a reduction action to produce a smaller array.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.ReduceTo(`0)">
            <summary>
            Apply a reduction action to produce a single element distribution.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.Replicate(System.Int32[],System.Int32[])">
            <summary>
            Add dimensions to an array by replication.
            </summary>
            <param name="lengths">The result array dimensions.</param>
            <param name="newPosition">For each original dimension d, newPosition[d] is its index in the 
            result dimensions.  Length == this.Rank.</param>
            <returns>A new array which uses the same storage but a different cursor.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.Split(System.Collections.Generic.IList{System.Boolean})">
            <summary>
            Make a jagged array from a multidimensional array.
            </summary>
            <param name="isOuterDimension">For each original dimension d, 
            indicates whether it will be in the outer array. Length == this.Rank.</param>
            <returns>A jagged array [outer][inner] which uses the same storage but a different cursor.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.ToString">
            <summary>
            Overrides ToString method
            </summary>
            <returns>String representation of instance</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionCursorArray`2.IsPointMass">
            <summary>
            True if all elements are constant.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Evaluator`2">
            <summary>
            Delegate type for evaluating log densities. This is used for distributions such as
            <see cref="T:MicrosoftResearch.Infer.Distributions.VectorGaussian"/> which have a large memory footprint. If a distribution
            supports <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetLogProbPrep`2"/>, then it can return a delegate of this type
            to do evaluations without recreating a workspace each time.
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
            <param name="dist">The distribution instance</param>
            <param name="value">The value at which to evaluate the log density</param>
            <returns>The delegate returns a double</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Sampler`1">
            <summary>
            Delegate type for sampling
            </summary>
            <typeparam name="T">Domain type</typeparam>
            <param name="result">Where to put the result</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Sampler`2">
            <summary>
            Delegate type for sampling a distribution. This is used for distributions such as
            <see cref="T:MicrosoftResearch.Infer.Distributions.VectorGaussian"/> which have a large memory footprint. If a distribution
            supports <see cref="T:MicrosoftResearch.Infer.Distributions.CanSamplePrep`2"/>, then it can return a delegate of this type
            to do successive sampling without recreating a workspace each time.
            </summary>
            <typeparam name="DistributionType">The distribution type</typeparam>
            <typeparam name="T">The domain type of the distribution</typeparam>
            <param name="distribution">The distribution instance</param>
            <param name="result">The value at which to evaluate the log density</param>
            <returns>The delegate's return type is the domain type</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanSetMean`1">
            <summary>
            Whether the distribution supports setting of its mean value
            </summary>
            <typeparam name="MeanType">Type of the mean value</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanSetMean`1.SetMean(`0)">
            <summary>
            Method to set the mean
            </summary>
            <param name="value">The mean value</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVarianceOut`2">
            <summary>
            Whether the distribution supports the joint getting of mean and variance
            where the mean and variance are returned as 'out' argiments
            </summary>
            <typeparam name="MeanType">Mean type</typeparam>
            <typeparam name="VarType">Variance type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVarianceOut`2.GetMeanAndVariance(`0@,`1@)">
            <summary>
            Get the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOfInverse`1">
            <summary>
            Whether the distribution supports the log-integral of the ratio of two instances
            </summary>
            <typeparam name="T">The distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogAverageOfInverse`1.GetLogAverageOfInverse(`0)">
            <summary>
            The log-integral of one distribution divided by another.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)/that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner ratio between distributions.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanGetLogPowerSum`1">
            <summary>
            Whether the distribution supports the log-integral of a distribution raised to a power
            </summary>
            <typeparam name="T">The distribution type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.CanGetLogPowerSum`1.GetLogPowerSum(System.Double)">
            <summary>
            The log-integral of a distribution raised to a power.
            </summary>
            <param name="power"></param>
            <returns>Math.Log(sum_x this.Evaluate(x)^power)</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ImproperDistributionException">
            <summary>
            Exception thrown when a distribution is improper and its expectations need to be computed.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ImproperDistributionException.#ctor(System.Object)">
            <summary>
            Create a new Improper Distribution exception
            </summary>
            <param name="distribution"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Distribution">
            <summary>
            Static class which implements useful functions on distributions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetDomainType(System.Type)">
            <summary>
            Gets the domain type of a distribution type, e.g. the domain type of 'Gaussian' is 'double'.
            </summary>
            <param name="distributionType"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.MakeDistributionArrayType(System.Type,System.Int32)">
            <summary>
            Makes a distribution array of a specified type and size
            </summary>
            <param name="elementType">Distribution type</param>
            <param name="rank">Number of dimensions</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.ToArray``1(System.Object)">
            <summary>
            Convert a distribution over an array variable to an array of element distributions.
            </summary>
            <typeparam name="ArrayType">A .NET array type, such as <c>Bernoulli[]</c> or <c>Gaussian[,][]</c>.  The array structure should match the domain of the distribution.</typeparam>
            <param name="distributionArray">A distribution over an array domain, such as <c>IDistribution&lt;bool[]&gt;</c> or <c>IDistribution&lt;double[,][]&gt;</c>.</param>
            <returns>An array of element distributions.</returns>
            <remarks>
            <typeparamref name="ArrayType"/> should match the array structure of the domain.  For example, if the input
            is <c>IDistribution&lt;bool[,]&gt;</c> then <typeparamref name="ArrayType"/> should be
            <c>Bernoulli[,]</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetArrayConverter``2">
            <summary>
            Get a converter from a distribution over an array variable to an array of element distributions.
            </summary>
            <typeparam name="TInput">A distribution type over an array domain, such as <c>IDistribution&lt;bool[]&gt;</c></typeparam>
            <typeparam name="TOutput">An array type such as <c>Bernoulli[]</c></typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.FromArray(System.Object)">
            <summary>
            Convert an array of element distributions to a distribution over an array variable.
            </summary>
            <param name="arrayOfDistributions">Array of distributions</param>
            <returns>Distribution over an array variable</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.ConvertArray``2(``0)">
            <summary>
            Convert a distribution array from one type to another
            </summary>
            <typeparam name="T">Type of source distribution array</typeparam>
            <typeparam name="U">Type of destination distribution array</typeparam>
            <param name="distributionArray"></param>
            <remarks>The element type of U is assumed to be constructable from the element type of T</remarks>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetTo``2(``0,``1)">
            <summary>
            Sets result to value and returns result.
            </summary>
            <typeparam name="T">Type of the result</typeparam>
            <typeparam name="TValue">Type of the value</typeparam>
            <param name="result">The result</param>
            <param name="value">The value</param>
            <returns>result, or a newly allocated object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetTo``3(``0,``1)">
            <summary>
            Sets result to value and returns result.
            </summary>
            <typeparam name="T">Type of the result</typeparam>
            <typeparam name="TValue">Type of the value</typeparam>
            <typeparam name="TDomain">Domain</typeparam>
            <param name="result">The result</param>
            <param name="value">The value</param>
            <returns>result, or a newly allocated object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductOfAll``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Product of all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c>, unless it is not SettableTo&lt;T&gt; in which case an element of dists may be returned.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductOfAll``2(``0,``1[])">
            <summary>
            Sets a distribution to the product of an array of ditributions
            </summary>
            <typeparam name="T">Domain type of the result distribution</typeparam>
            <typeparam name="U">Domain type of the array of distributions</typeparam>
            <param name="result">The result distribution</param>
            <param name="dists">The array of distributions</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAllExcept``2(``0,System.Collections.Generic.IList{``1},System.Int32)">
            <summary>
            Multiplies result by all distributions in an array, except for one index.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <param name="index"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAllExcept``2(``0,``1[],System.Int32)">
            <summary>
            Multiplies result by all distributions in an array, except for one index.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <param name="index"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAll``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Multiplies result by all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAll``2(``0,``1[])">
            <summary>
            Multiplies result by all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAllExcept``3(``0,System.Collections.Generic.IList{``1},System.Int32)">
            <summary>
            Multiplies result by all distributions in an array, except for one index.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <param name="index"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductWithAll``3(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Multiplies result by all distributions in an array.
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProductOfAllExcept``2(``0,System.Collections.Generic.IList{``1},System.Int32,System.Int32)">
            <summary>
            Product of distributions in an array.
            </summary>
            <param name="result">A reference in which to place the results.</param>
            <param name="dists">An array of distributions.</param>
            <param name="count">The number of distributions in the array to multiply (starting from index 0).</param>
            <param name="index">An array index to omit in the multiplication.  If index == count, no index is omitted and all distributions are multiplied.</param>
            <returns><c>result</c>, unless it is not SettableTo&lt;T&gt; in which case an element of dists may be returned.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.MultiplyAllIntoTargetExcept``3(``0,System.Collections.Generic.IList{``1},System.Int32)">
            <summary>
            Multiplies all distributions in an array, except for one index, into a target
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <param name="index"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.MultiplyAllIntoTarget``3(``0,System.Collections.Generic.IList{``1})">
            <summary>
            Multiplies all distributions in an array, except for one index, into a target
            </summary>
            <param name="result"></param>
            <param name="dists"></param>
            <returns><c>result</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.LogInnerProduct``1(System.Collections.Generic.IList{``0})">
            <summary>
            Log-probability that all distributions in the list would produce the same value.
            </summary>
            <param name="dists"></param>
            <returns><c>sum_x prod_i dists[i](x)</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.MaxDiff``2(``0[],``1[])">
            <summary>
            Max difference between two arrays of distributions
            </summary>
            <typeparam name="T">Domain type for fisrt array of distributions</typeparam>
            <typeparam name="U">Domain type for second array of distributions</typeparam>
            <param name="a">First array of distributions</param>
            <param name="b">Second array of distributions</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProduct``2(``0[],``1[],``1[])">
            <summary>
            Sets each element of result to the product of the corresponding distributions in two given
            arrays
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the two distribution arrays</typeparam>
            <param name="result">Result</param>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToProduct``4(``0[],``1[],``2[])">
            <summary>
            Sets each element of the result to the product of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the numerator distribution arrays</typeparam>
            <typeparam name="T3">Element type of the denominator distribution array</typeparam>
            <typeparam name="TDomain">Domian type</typeparam>
            <param name="result">Result distribution array</param>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToRatio``2(``0[],``1[],``1[])">
            <summary>
            Sets each element of the result to the ratio of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the numerator and denominator distribution arrays</typeparam>
            <param name="result">Result distribution array</param>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToRatio``4(``0[],``1[],``2[])">
            <summary>
            Sets each element of the result to the ratio of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the numerator distribution arrays</typeparam>
            <typeparam name="T3">Element type of the denominator distribution array</typeparam>
            <typeparam name="TDomain">Domian type</typeparam>
            <param name="result">Result distribution array</param>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.MultiplyIntoTarget``4(``0[],``1[],``2[])">
            <summary>
            Controlling factor multiplies itself with the secondary factor and
            puts its results into the target
            </summary>
            <typeparam name="T1">Element type of the controlling factor</typeparam>
            <typeparam name="T2">Element type of the target of the multiplication</typeparam>
            <typeparam name="T3">Element type of the secondary factor</typeparam>
            <typeparam name="TDomain">The domain type</typeparam>
            <param name="factor1">The controlling factor</param>
            <param name="target">The target of the multiplication</param>
            <param name="factor2">The secondary factor</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetTarget``3(``0[],``1[])">
            <summary>
            Set the target distribution array from the source
            </summary>
            <typeparam name="T1">Type of the source distribution</typeparam>
            <typeparam name="T2">Type of the target distribution</typeparam>
            <typeparam name="TDomain">Common domain type</typeparam>
            <param name="source">The source</param>
            <param name="target">The target</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToPower``2(``0[],``1[],System.Double)">
            <summary>
            Sets each element of the result to a power of the corresponding element in a source distribution array
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the source distribution array</typeparam>
            <param name="result">Result distribution array</param>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToPowerLazy``2(``0[],``1[],System.Double)">
            <summary>
            Sets each element of the result to a power of the corresponding element in a source distribution array
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the source distribution array</typeparam>
            <param name="result">Result distribution array</param>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToSum``2(``0[],System.Double,``1[],System.Double,``1[])">
            <summary>
            Sets each element of result to a weighted sum of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the two source distribution arrays</typeparam>
            <param name="result">Result distribution array</param>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetToSumLazy``2(``0[],System.Double,``1[],System.Double,``1[])">
            <summary>
            Sets each element of result to a weighted sum of the corresponding distributions in two given
            arrays.
            </summary>
            <typeparam name="T1">Element type of the result distribution array</typeparam>
            <typeparam name="T2">Element type of the two source distribution arrays</typeparam>
            <param name="result">Result distribution array</param>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetLogAverageOf``2(``0[],``1[])">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <typeparam name="T1">Element type of this distribution array</typeparam>
            <typeparam name="T2">Element type of that distribution array</typeparam>
            <param name="thisDist">This distribution array</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For an array, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetLogAverageOfLazy``2(``0[],``1[])">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <typeparam name="T1">Element type of this distribution array</typeparam>
            <typeparam name="T2">Element type of that distribution array</typeparam>
            <param name="thisDist">This distribution array</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For an array, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetAverageLog``2(``0[],``1[])">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <typeparam name="T">Type of this distribution</typeparam>
            <typeparam name="TValue">Type of the distribution to take the logarithm of</typeparam>
            <param name="thisDist">This distribution</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For an array, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.GetAverageLogLazy``2(``0[],``1[])">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <typeparam name="T1">Element type of this distribution array</typeparam>
            <typeparam name="T2">Element type of thatd istribution array</typeparam>
            <param name="thisDist">This distribution array</param>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For an array, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.PointMass``1(``0)">
            <summary>
            Creates a point mass at the specified location.
            </summary>
            <param name="point">The point at which to place the point mass</param>
            <returns>The PointMass object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution.SetPoint``2(``0,``1)">
            <summary>
            Set a distribution to a point mass
            </summary>
            <typeparam name="TDist"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="dist"></param>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Distribution`1">
            <summary>
            Static class which implements useful functions on distributions.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(System.Int32,System.Converter{System.Int32,``0})">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="length">The length of the array.</param>
            <param name="init">A function providing the distribution of each array element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[0:,0:])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(System.Int32,System.Int32,MicrosoftResearch.Infer.Utils.Func{System.Int32,System.Int32,``0})">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="length1">The first dimension of the array.</param>
            <param name="length2">The second dimension of the array.</param>
            <param name="init">A function providing the distribution of each array element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[][])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[][0:,0:])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[0:,0:][])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Distribution`1.Array``1(``0[][][])">
            <summary>
            Create a distribution over an array domain from independent distributions over the elements.
            </summary>
            <typeparam name="Distribution">Distribution type for an array element.</typeparam>
            <param name="array">The distribution of each element.</param>
            <returns>A single distribution object over the array domain.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MMath">
            <summary>
            This class provides mathematical constants and special functions, 
            analogous to System.Math.
            It cannot be instantiated and consists of static members only.
            </summary>
            <remarks>
            <para>
            In order to provide the highest accuracy, some routines return their results in log form or logit form.
            These transformations expand the domain to cover the full range of double-precision values, ensuring 
            all bits of the representation are utilized.  A good example of this is the NormalCdf function, whose 
            value lies between 0 and 1.  Numbers between 0 and 1 use only a small fraction of the capacity of a 
            double-precision number.  The function NormalCdfLogit transforms the result p according to log(p/(1-p)), 
            providing full use of the range from -Infinity to Infinity and (potentially) much higher precision.
            </para><para>
            To get maximal use out of these transformations, you want to stay in the expanded form as long as 
            possible.  Everytime you transform into a smaller domain, you lose precision.  Thus helper functions 
            are provided which allow you to perform common tasks directly in the log form and logit form. 
            For logs, you have addition.  For logit, you have averaging. 
            </para>
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.EulerGamma">
            <summary>
            The Euler-Mascheroni Constant.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Sqrt2PI">
            <summary>
            Math.Sqrt(2*Math.PI)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.LnSqrt2PI">
            <summary>
            Math.Log(Math.Sqrt(2*Math.PI)).
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.LnPI">
            <summary>
            Math.Log(Math.PI)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Ln2">
            <summary>
            Math.Log(2)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Sqrt2">
            <summary>
            Math.Sqrt(2)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.SqrtHalf">
            <summary>
            Math.Sqrt(0.5)
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_g">
            <summary>
            Expansion point of the Lanczos method, used in Gamma and GammaLn.
            Must be consistent with <see cref="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_series"/>.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.Zeta2">
            <summary>
            Zeta(2) = pi^2/6.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_trigamma_large">
            <summary>
            The threshold for applying de Moivre's expansion for the trigamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_trigamma_small">
            <summary>
            The threshold for applying de Moivre's expansion for the trigamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.M2Zeta3">
            <summary>
            -2 Zeta(3)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1PlusExpGaussian(System.Double,System.Double)">
            <summary>
            Evaluates E[log(1+exp(x))] under a Gaussian distribution with specified mean and variance.
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Gamma(System.Double)">
            <summary>
            Evaluates Gamma(x), defined as the integral from 0 to x of t^(x-1)*exp(-t) dt.
            </summary>
            <param name="x">Any real value.</param>
            <returns>Gamma(x).</returns>
            <remarks>
            Uses the Lanczos approximation described in: 
            A Precision Approximation of the Gamma Function, J. SIAM Numer. Anal. Ser. B 1: 86-96, 1964.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaLn(System.Double)">
            <summary>
            Computes the natural logarithm of the Gamma function.
            </summary>
            <param name="x">A real value >= 0.</param>
            <returns>ln(Gamma(x)).</returns>
            <remarks>This function provides higher accuracy than <c>Math.Log(Gamma(x))</c>, which may fail for large x.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.GammaLn(System.Double,System.Double)">
            <summary>
            Computes the natural logarithm of the multivariate Gamma function.
            </summary>
            <param name="x">A real value >= 0.</param>
            <param name="d">The dimension, an integer > 0.</param>
            <returns>ln(Gamma_d(x))</returns>
            <remarks>The <a href="http://en.wikipedia.org/wiki/Multivariate_gamma_function">multivariate Gamma function</a> 
            is defined as Gamma_d(x) = pi^(d*(d-1)/4)*prod_(i=1..d) Gamma(x + (1-i)/2)</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Digamma(System.Double)">
            <summary>
            Evaluates Digamma(x), the derivative of ln(Gamma(x)).
            </summary>
            <param name="x">Any real value.</param>
            <returns>Digamma(x).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Trigamma(System.Double)">
            <summary>
            Evaluates Trigamma(x), the derivative of Digamma(x).
            </summary>
            <param name="x">Any real value.</param>
            <returns>Trigamma(x).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ChooseLn(System.Double,System.Double)">
            <summary>
            Evaluates the natural logarithm of Gamma(n+1)/(Gamma(k+1)*Gamma(n-k+1))
            </summary>
            <param name="n"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ChooseLn(System.Double,System.Double[])">
            <summary>
            Evaluates the natural logarithm of Gamma(n+1)/(prod_i Gamma(k[i]+1))
            </summary>
            <param name="n"></param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Erfc(System.Double)">
            <summary>
            Computes the complementary error function. This function is defined by 2/sqrt(pi) * integral from x to infinity of exp (-t^2) dt.
            </summary>
            <param name="x">Any real value.</param>
            <returns>The complementary error function at x.</returns>
            <remarks>This method uses a Chebyshev series approximation which is exact in the whole range up to 1 * 10^{-7}.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ErfcInv(System.Double)">
            <summary>
            Computes the inverse of the complementary error function, i.e.
            <c>erfcinv(erfc(x)) == x</c>.
            </summary>
            <param name="y">A real number between 0 and 2.</param>
            <returns>A number x such that <c>erfc(x) == y</c>.</returns>
            <remarks>This function uses a polynomial approximation together with one step of Halley's rational method.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdf(System.Double)">
            <summary>
            Computes the cumulative Gaussian distribution, defined as the
            integral from -infinity to x of N(t;0,1) dt.  
            For example, <c>NormalCdf(0) == 0.5</c>.
            </summary>
            <param name="x">Any real number.</param>
            <returns>The cumulative Gaussian distribution at <paramref name="x"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfLn(System.Double)">
            <summary>
            The natural logarithm of the cumulative Gaussian distribution.
            </summary>
            <param name="x">Any real number.</param>
            <returns>ln(NormalCdf(x)).</returns>
            <remarks>This function provides higher accuracy than <c>Math.Log(NormalCdf(x))</c>, which can fail for x &lt; -7.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfLogit(System.Double)">
            <summary>
            The log-odds of the cumulative Gaussian distribution.
            </summary>
            <param name="x">Any real number.</param>
            <returns>ln(NormalCdf(x)/(1-NormalCdf(x))).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfInv(System.Double)">
            <summary>
            Computes the inverse of the cumulative Gaussian distribution,
            i.e. <c>NormalCdf(NormalCdfInv(p)) == p</c>.
            For example, <c>NormalCdfInv(0.5) == 0</c>.
            This is also known as the Gaussian quantile function.  
            </summary>
            <param name="p">A real number in [0,1].</param>
            <returns>A number x such that <c>NormalCdf(x) == p</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdf(System.Double,System.Double,System.Double)">
            <summary>
            Computes the cumulative bivariate normal distribution.
            </summary>
            <param name="x">First upper limit.</param>
            <param name="y">Second upper limit.</param>
            <param name="r">Correlation coefficient.</param>
            <returns><c>phi(x,y,r)</c></returns>
            <remarks>
            The cumulative bivariate normal distribution is defined as
            <c>int_(-inf)^x int_(-inf)^y N([x;y],[0;0],[1 r; r 1]) dx dy</c>
            where <c>N([x;y],[0;0],[1 r; r 1]) = exp(-0.5*(x^2+y^2-2*x*y*r)/(1-r^2))/(2*pi*sqrt(1-r^2))</c>.
            The double integral is transformed into a single integral which is approximated by quadrature.
            For full details, see: 
            "Numerical Computation of Rectangular Bivariate and Trivariate Normal and t Probabilities"
            Alan Genz, Statistics and Computing, 14 (2004), pp. 151-160
            http://www.math.wsu.edu/faculty/genz/genzhome/research.html
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.NormalCdfLn(System.Double,System.Double,System.Double)">
            <summary>
            Computes the natural logarithm of the cumulative bivariate normal distribution.
            </summary>
            <param name="x">First upper limit.</param>
            <param name="y">Second upper limit.</param>
            <param name="r">Correlation coefficient.</param>
            <returns><c>ln(phi(x,y,r))</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Logistic(System.Double)">
            <summary>
            Computes the logistic function 1/(1+exp(-x)).
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>1/(1+exp(-x)).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogisticLn(System.Double)">
            <summary>
            Compute the natural logarithm of the logistic function, i.e. -log(1+exp(-x)).
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>-log(1+exp(-x)).</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>-log(1+exp(-x))</c>, 
            which can fail for x &lt; -50 and x > 36.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1Plus(System.Double)">
            <summary>
            Computes the natural logarithm of 1+x.
            </summary>
            <param name="x">A non-negative real number: 0 &lt;= x &lt;= Inf, or NaN.</param>
            <returns>log(1+x), which is always >= 0.</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(1+x)</c>,
            particularly when <paramref name="x"/> is small.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1PlusExp(System.Double)">
            <summary>
            Computes log(1 + exp(x)) to high accuracy.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>log(1+exp(x)), which is always >= 0.</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(1+exp(x))</c>,
            particularly when x &lt; -36 or x > 50.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Log1MinusExp(System.Double)">
            <summary>
            Computes log(1 - exp(x)) to high accuracy.
            </summary>
            <param name="x">A non-positive real number: -Inf &lt;= x &lt;= 0, or NaN.</param>
            <returns>log(1-exp(x)), which is always &lt;= 0.</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(1-exp(x))</c>,
            particularly when x &lt; -7.5 or x > -1e-5.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.ExpMinus1(System.Double)">
            <summary>
            Computes the exponential of x and subtracts 1.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <returns>exp(x)-1</returns>
            <remarks>
            This function is more accurate than a direct evaluation of <c>exp(x)-1</c> when x is small.
            It is the inverse function to Log1Plus: <c>ExpMinus1(Log1Plus(x)) == x</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogExpMinus1(System.Double)">
            <summary>
            Computes <c>log(exp(x)-1)</c> for non-negative x.
            </summary>
            <param name="x">A non-negative real number: 0 &lt;= x &lt;= Inf, or NaN.</param>
            <returns><c>log(exp(x)-1)</c></returns>
            <remarks>
            This function is more accurate than a direct evaluation of <c>log(exp(x)-1)</c> when x &lt; 1e-3
            or x > 50.
            It is the inverse function to Log1PlusExp: <c>LogExpMinus1(Log1PlusExp(x)) == x</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogSumExp(System.Double,System.Double)">
            <summary>
            Computes log(exp(x) + exp(y)) to high accuracy.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <param name="y">Any real number from -Inf to Inf, or NaN.</param>
            <returns>log(exp(x)+exp(y)), which is always >= max(x,y).</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of <c>log(exp(x)+exp(y))</c>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.DiffLogSumExp(System.Double,System.Double,System.Double)">
            <summary>
            Computes log(exp(x)+exp(a))-log(exp(x)+exp(b)) to high accuracy.
            </summary>
            <param name="x">Any real number from -Inf to Inf, or NaN.</param>
            <param name="a">A finite real number.</param>
            <param name="b">A finite real number.</param>
            <returns>log(exp(x)+exp(a))-log(exp(x)+exp(b))</returns>
            <remarks>This function provides higher accuracy than a direct evaluation of 
            <c>LogSumExp(x,a)-LogSumExp(x,b)</c>, particularly when x is large.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Logit(System.Double)">
            <summary>
            Computes the log-odds function log(p/(1-p)).
            </summary>
            <param name="p">Any number between 0 and 1, inclusive.</param>
            <returns>log(p/(1-p))</returns>
            <remarks>This function is the inverse of the logistic function, 
            i.e. <c>Logistic(Logit(p)) == p.</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogitFromLog(System.Double)">
            <summary>
            Compute log(p/(1-p)) from log(p).
            </summary>
            <param name="logp">Any number between -infinity and 0, inclusive.</param>
            <returns>log(exp(logp)/(1-exp(logp))) = -log(exp(-logp)-1).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Softmax(System.Double[])">
            <summary>
            Exponentiate array elements and normalize to sum to 1.
            </summary>
            <param name="x">May be +/-infinity</param>
            <returns>A Vector p where <c>p[k] = exp(x[k])/sum_j exp(x[j])</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Max(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the maximum of a list of doubles
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Min(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the minimum of a list of doubles
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.LogSumExp(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the log of the sum of exponentials of a list of doubles
            </summary>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMinimum``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns the index of the minimum element, or -1 if empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.IndexOfMaximum``1(System.Collections.Generic.IList{``0})">
            <summary>
            Returns the index of the maximum element, or -1 if empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Median(System.Double[])">
            <summary>
            Returns the median of the array elements.
            </summary>
            <param name="array"></param>
            <returns>The median ignoring NaNs.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.Median(System.Double[],System.Int32,System.Int32)">
            <summary>
            Returns the median of elements in a subrange of an array.
            </summary>
            <param name="array"></param>
            <param name="start">Starting index of the range.</param>
            <param name="length">The number of elements in the range.</param>
            <returns>The median of array[start:(start+length-1)], ignoring NaNs.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.RemoveNaNs(System.Double[],System.Int32,System.Int32)">
            <summary>
            Given an array, returns a new array with all NANs removed.
            </summary>
            <param name="array">The source array</param>
            <param name="start">The start index in the source array</param>
            <param name="length">How many items to look at in the source array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.AbsDiff(System.Double,System.Double,System.Double)">
            <summary>
            Returns the relative distance between two numbers.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns><c>abs(x - y)/(abs(x) + rel)</c>. 
            Matching infinities give zero.
            </returns>
            <remarks>
            This routine is often used to measure the error of y in estimating x.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MMath.AbsDiff(System.Double,System.Double)">
            <summary>
            Returns the distance between two numbers.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns><c>abs(x - y)</c>. 
            Matching infinities give zero.
            </returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_series">
            <summary>
            Coefficients of the Lanczos series for Gamma, determined by
            the expansion point <see cref="F:MicrosoftResearch.Infer.Maths.MMath.c_gamma_g"/>.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_digamma_series">
            <summary>
            Coefficients of de Moivre's expansion for the digamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_trigamma_series">
            <summary>
            Coefficients of de Moivre's expansion for the trigamma function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MMath.c_normcdfln_series">
            <summary>
            Coefficients of the asymptotic expansion of NormalCdfLn.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)"/> and <see cref="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogFactorValue(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for Gibbs.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's value at the given arguments.</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleConditional(System.Double,System.Double)">
            <summary>
            Gibbs message to 'sample'.
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing Gibbs message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanConditional(System.Double,System.Double)">
            <summary>
            Gibbs message to 'mean'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing Gibbs message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionConditional(System.Double,System.Double)">
            <summary>
            Gibbs message to 'precision'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing Gibbs message to the 'precision' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianOp.ForceProper">
            <summary>
            Static flag to force a proper distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int f(mean,x) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'precision'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing EP message to the 'precision' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int f(precision,x) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing EP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int f(mean,x) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianOp.QuadratureNodeCount">
            <summary>
            Number of quadrature nodes to use for computing the messages.
            Reduce this number to save time in exchange for less accuracy.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int f(mean,x) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int f(mean,x) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'precision'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'precision' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int f(precision,x) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'precision'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'precision' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int f(precision,x) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'precision'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'precision' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int f(precision,x) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.QuadratureNodesAndWeights(MicrosoftResearch.Infer.Distributions.Gamma,System.Double[],System.Double[])">
            <summary>
            Quadrature nodes for Gamma expectations
            </summary>
            <param name="precision">'precision' message</param>
            <param name="nodes">Place to put the nodes</param>
            <param name="weights">Place to put the weights</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.TPdfLn(System.Double,System.Double,System.Double)">
            <summary>
            Logarithm of Student T density.
            </summary>
            <param name="x">sample</param>
            <param name="v">variance parameter</param>
            <param name="n">degrees of freedom plus 1</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'mean'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int log(f(mean,x)) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'mean'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>The outgoing VMP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int log(f(mean,x)) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'mean'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int log(f(mean,x)) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.SampleAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.MeanAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'mean'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int log(f(mean,x)) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'precision'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing VMP message to the 'precision' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int log(f(precision,x)) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'precision'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'precision' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int log(f(precision,x)) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'precision'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <returns>The outgoing VMP message to the 'precision' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int log(f(precision,x)) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.PrecisionAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'precision'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'precision' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int log(f(precision,x)) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double,System.Double)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CopyOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Copy``1(``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.LogEvidenceRatio``1(``0)">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.InputAverageConditional``1(``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="Output">Incoming message from 'copy'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'value' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (copy)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Output"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.OutputAverageConditional``1(``0)">
            <summary>
            EP message to 'copy'.
            </summary>
            <param name="Input">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'copy' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'copy'.
            The formula is <c>int f(copy,x) q(x) dx</c> where <c>x = (value)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Input"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (copy,value)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.InputAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="Output">Incoming message from 'copy'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'value' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = (copy)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Output"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CopyOp`1.OutputAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'copy'.
            </summary>
            <param name="Input">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'copy' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'copy'.
            The formula is <c>int log(f(copy,x)) q(x) dx</c> where <c>x = (value)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Input"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BetaOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BetaFromMeanAndTotalCount(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (prob,mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'Prob'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'Prob' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            VMP message to 'Prob'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'Prob' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.ProbAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'Prob'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'Prob' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Nonconjugate VMP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'Mean' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Nonconjugate VMP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'Mean' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,System.Double,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Nonconjugate VMP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'Mean' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Nonconjugate VMP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'Mean' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Nonconjugate VMP message to 'totalCount'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'totalCount' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BetaOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Nonconjugate VMP message to 'totalCount'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'totalCount' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanAndOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.And(System.Boolean,System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'and'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int f(and,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'and'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int f(and,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'and'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int f(and,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Incoming message from 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (and,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Incoming message from 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Incoming message from 'and'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Incoming message from 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.LogEvidenceRatio(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (and,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'and'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int log(f(and,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'and'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int log(f(and,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AndAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'and'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'and' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'and'.
            The formula is <c>int log(f(and,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.AAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (and,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="and">Incoming message from 'and'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="and"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAndOp.BAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="and">Constant value for 'and'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (and,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Wishart">
            <summary>
            A Wishart distribution on positive definite matrices.
            </summary>
            <remarks><para>
             In the matrix case, the distribution is
              <c>p(X) = |X|^(a-(d+1)/2)*exp(-tr(X*B))*|B|^a/Gamma_d(a)</c>.
            In this code, the <c>a</c> parameter is called the "Shape" and the <c>B</c> parameter
            is called the "Rate".  The
            mean of the distribution is <c>a/B</c> and the diagonal variance is 
            <c>var(X_ii) = a*C_ii^2</c> where <c>C=inv(B)</c>.  The non-diagonal variances are
            <c>var(X_ij) = a*0.5*(C_ij^2 + C_ii*C_jj)</c> where <c>C=inv(B)</c>.
            </para><para>
            The distribution is represented by a one-dimensional Vector for <c>a</c> and 
            a PositiveDefiniteMatrix for <c>B</c>.  Because both are Cursors, any Wishart instance
            can be used as a cursor.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMean">
            <summary>
            Gets the mean of the distribution.
            </summary>
            <returns>A new PositiveDefiniteMatrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMean(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean of the distribution.
            </summary>
            <param name="mean">Where to put the mean matrix</param>
            <returns>The mean matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetVariance">
            <summary>
            Gets the variance of the distribution
            </summary>
            <returns>The variance matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the variance of the distribution
            </summary>
            <param name="variance">Where to put the variance</param>
            <returns>The variance matrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMeanAndVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the mean and variance matrices.
            </summary>
            <param name="mean">Where to put the mean - assumed to be of the correct size</param>
            <param name="variance">Where to put the variance - assumed to be of the correct size</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetMeanAndVariance(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the parameters to produce a given mean and variance.
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <remarks>
            The mean is always matched, but the variance may not match exactly, since the distribution
            has only one scalar parameter for variance.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the shape parameter and the scale matrix parameter for this instance
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets the shape parameter and the rate matrix parameter for this instance
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="rate">The rate matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetMeanLogDeterminant">
            <summary>
            Gets the mean log determinant
            </summary>
            <returns>The mean log determinant</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing rate matrix
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetDomainPrototype">
            <summary>
            Gets a domain prototype.
            </summary>
            <returns>A default PositiveDefiniteMatrix</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToUniform">
            <summary>
            Sets this instance to have uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.IsProper">
            <summary>
            Asks whether this instance is proper
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.IsProper(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Asks whether a Wishart distribution of the specified shape and rate is proper
            </summary>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate matrix</param>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogProb(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evaluates the logarithm of a Wishart density function at a given point
            </summary>
            <param name="x">Where to evaluate the density</param>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate matrix</param>
            <returns>The log density</returns>
            <remarks>
            The distribution is <c>p(X) = |X|^(a-(d+1)/2)*exp(-tr(X*B))*|B|^a/Gamma_d(a)</c>.
            When a &lt;= (d-1)/2 the <c>Gamma_d(a)</c> term is dropped.
            When B &lt;= 0 the <c>|B|^a</c> term is dropped.
            Thus if shape = (d+1)/2 and rate = 0 the density is 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogProb(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evaluates the logarithm of this Wishart density function at a given point
            </summary>
            <param name="X">Where to evaluate the density</param>
            <returns>The log density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogNormalizer(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Gets the normalizer for a Wishart density function specified by shape and rate matrix
            </summary>
            <param name="shape">Shape parameter</param>
            <param name="rate">rate matrix</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogNormalizer">
            <summary>
            Gets the normalizer for the density function of this Wishart distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetAverageLog(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Gets the log-integral of the product of this Wishart with another Wishart
            </summary>
            <param name="that">The other Wishart</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Samples this Wishart distribution
            </summary>
            <param name="result">Where to put the sample</param>
            <param name="cholB">A workspace matrix of the same dimension as the distribution</param>
            <param name="cholX">A workspace matrix of the same dimension as the distribution</param>
            <param name="cholXt">A workspace matrix of the same dimension as the distribution</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples this Wishart distribution. Workspaces are allocated behind the scenes
            </summary>
            <param name="result">Where to put the sample</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample">
            <summary>
            Samples this Wishart distribution. Workspaces and sample matrix are allocated
            behind the scenes
            </summary>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Sample(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Samples a Wishart distribution of specified shape and rate.
            Workspaces are allocated behind the scenes
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
            <param name="result">Where to put the sample</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetTo(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Sets this Wishart instance to have the parameter values of another Wishart instance
            </summary>
            <param name="that">The other Wishart</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToProduct(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Sets the parameters to represent the product of two Wisharts.
            </summary>
            <param name="g1">The first Wishart</param>
            <param name="g2">The second Wishart</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.op_Multiply(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Creates a new Wishart which the product of two other Wisharts
            </summary>
            <param name="a">First Wishart</param>
            <param name="b">Second Wishart</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToRatio(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Sets the parameters to represent the ratio of two Wisharts.
            </summary>
            <param name="numerator">The numerator Wishart</param>
            <param name="denominator">The denominator Wishart</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.op_Division(MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Creates a new Wishart which is the ratio of two other Wishart
            </summary>
            <param name="numerator">numerator Wishart</param>
            <param name="denominator">denominator Wishart</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToPower(MicrosoftResearch.Infer.Distributions.Wishart,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Wishart to some exponent.
            </summary>
            <param name="dist">The source Wishart</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Wishart,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Wishart,System.Double,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Weighted mixture distribution for two Wisharts
            </summary>
            <param name="weight1">First weight</param>
            <param name="dist1">First Wishart</param>
            <param name="weight2">Second weight</param>
            <param name="dist2">Second Wishart</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.WeightedSum``1(``0,System.Int32,System.Double,``0,System.Double,``0)">
            <summary>
            Creates a weighted mixture distribution for distributions whose mean and variance are both
            of type PositiveDefiniteMatrix. The distribution type must implement <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVariance`2"/> and
            <see cref="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2"/>
            </summary>
            <typeparam name="T">Distribution type for the mixture</typeparam>
            <param name="dimension">The dimension of the domain</param>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
            <param name="result">Resulting distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Wishart
            and that Wishart
            </summary>
            <param name="thatd">That Wishart</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.CreateSourceArray(System.Int32)">
            <summary>
            Creates the <see cref="P:MicrosoftResearch.Infer.Distributions.Wishart.SourceArray"/> for storing the Wishart parameters
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.ReferenceClone">
            <summary>
            Creates a clone of this instance, copying Wishart parameters as references
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Clone">
            <summary>
            Clones this Wishart. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Wishart type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Int32)">
            <summary>
            Constructs a uniform Wishart distribution of the given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.Uniform(System.Int32)">
            <summary>
            Constructs a uniform Wishart distribution of the given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Double,System.Double)">
            <summary>
            Creates a one-dimensional Wishart with given shape and scale
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The one-dimesional scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Int32,System.Double,System.Double)">
            <summary>
            Constructs a multi-dimensional Wishart with given shape and with
            a scale matrix which is set to a scaled identity matrix
            </summary>
            <param name="dimension">The dimension</param>
            <param name="shape">The shape parameter</param>
            <param name="scale">Used to scale the identity matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.#ctor(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Constructs a multi-dimensional Wishart with given shape and scale matrix
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndScale(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a new multi-dimensional Wishart with given shape and scale matrix
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="scale">The scale matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndScale(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a multi-dimensional Wishart with given shape and with
            a scale matrix which is set to a scaled identity matrix
            </summary>
            <param name="dimension">The dimension</param>
            <param name="shape">The shape parameter</param>
            <param name="scale">Used to scale the identity matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndRate(System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a multi-dimensional Wishart with given shape and rate matrix
            </summary>
            <param name="shape">The shape parameter</param>
            <param name="rate">The rate matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromShapeAndRate(System.Int32,System.Double,System.Double)">
            <summary>
            Creates a multi-dimensional Wishart with given shape and with
            a rate matrix which is set to a scaled identity matrix
            </summary>
            <param name="dimension">The dimension</param>
            <param name="shape">The shape parameter</param>
            <param name="rate">Used to scale the identity matrix</param>
            <returns>A new Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.PointMass(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Creates a Wishart point mass at the specified location
            </summary>
            <param name="mean">The location of the point-mass</param>
            <returns>A new point mass Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.PointMass(System.Double)">
            <summary>
            Creates a Wishart point mass at the specified location
            </summary>
            <param name="mean">The location of the point-mass is a vector where every element equals this value</param>
            <returns>A new point mass Wishart distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.FromCursors(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a Wishart from Cursor objects.
            </summary>
            <param name="rate"></param>
            <param name="shape"></param>
            <remarks>The cursors will use their existing source array.
            The Wishart will reference the given cursors.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Wishart.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Rate">
            <summary>
            Sets/gets the rate matrix
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Shape">
            <summary>
            Sets/gets the shape value
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Point">
            <summary>
            Sets/gets this instance as a point-mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Dimension">
            <summary>
            Dimension of this distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.SourceArray">
            <summary>
            Gets/sets the source array for the Wishart parameters. These are stored
            contiguously in the SourceArray as Rate matrix followed by shape
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Count">
            <summary>
            This is part of the <see cref="T:MicrosoftResearch.Infer.Collections.ICursor"/> interface. It returns the total count of elements in
            the Wishart parameters, which are stored in <see cref="P:MicrosoftResearch.Infer.Distributions.Wishart.SourceArray"/>
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Wishart.Start">
            <summary>
            This is part of the <see cref="T:MicrosoftResearch.Infer.Collections.ICursor"/> interface. It returns the start index of the
            the Wishart parameters as stored in <see cref="P:MicrosoftResearch.Infer.Distributions.Wishart.SourceArray"/>
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a priority queue filled with count items equal to default(T).
            </summary>
            <param name="count"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Create a priority queue filled with count items equal to default(T).
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0},MicrosoftResearch.Infer.Utils.Action{`0,System.Int32})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
            <param name="comparer"></param>
            <param name="moved"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.#ctor(System.Collections.Generic.IEnumerable{`0},MicrosoftResearch.Infer.Utils.Action{`0,System.Int32})">
            <summary>
            Create a priority queue initialized with the contents of list.
            </summary>
            <param name="list"></param>
            <param name="moved"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.Add(`0)">
            <summary>
            Add a new item to the queue.
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add several new items to the queue.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.Changed(System.Int32)">
            <summary>
            Reposition node i to restore the heap property.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.SiftUp(System.Int32)">
            <summary>
            Move Items[i] upward until it is greater than or equal to its parent.
            </summary>
            <param name="i">An index into Items.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.SiftDown(System.Int32)">
            <summary>
            Move Items[i] downward until it is less than or equal to its children.
            </summary>
            <param name="i"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.PriorityQueue`1.SiftAll">
            <summary>
            Rearrange all items to satisfy the heap property.
            </summary>
        </member>
        <member name="E:MicrosoftResearch.Infer.Collections.PriorityQueue`1.Moved">
            <summary>
            Raised when an item has changed position.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Stochastic">
            <summary>
            When applied to a method, indicates that the method is non-deterministic.
            </summary>
            <remarks>
            A method is non-deterministic if its return value is not completely determined by its arguments.
            For a void method, this attribute is meaningless.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Rand">
            <summary>
            This class provides a source of non-uniform random numbers.
            It cannot be instantiated and consists of only static functions.
            </summary>
            <remarks>A static <c>System.Random</c> object provides the underlying random numbers.</remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand.gen">
            <summary>
            Supplies uniform random numbers.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand.usePreviousSample">
            <summary>
            If true, Normal() returns previousSample.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Rand.previousSample">
            <summary>
            If usePreviousSample = true, this is the next value Normal() 
            will return.  Otherwise its value is unspecified.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Restart(System.Int32)">
            <summary>
            Restarts the random number sequence.
            </summary>
            <param name="seed">A number used to calculate a starting value for the pseudo-random number sequence.
            If a negative number is specified, the absolute value of the number is used.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Int">
            <summary>
            Generates a non-negative random integer.
            </summary>
            <returns>A random integer &gt;= 0.</returns>
            <remarks>Same as <see cref="M:System.Random.Next"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Int(System.Int32)">
            <summary>
            Generates a random integer x, 0 &lt;= x &lt; <paramref name="maxPlus1"/>
            </summary>
            <param name="maxPlus1">Upper bound.  Must be &gt;= 0.</param>
            <returns>A random integer x, 0 &lt;= x &lt; <paramref name="maxPlus1"/>.  If <paramref name="maxPlus1"/> is zero, zero is returned.</returns>
            <remarks>Same as <see cref="M:System.Random.Next(System.Int32)"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Int(System.Int32,System.Int32)">
            <summary>
            Generates a random integer x, <paramref name="min"/> &lt;= x &lt; <paramref name="maxPlus1"/>.
            </summary>
            <param name="min">Minimum value.</param>
            <param name="maxPlus1">Maximum value.  Must be &gt;= <paramref name="min"/>.</param>
            <returns>A random integer x, <paramref name="min"/> &lt;= x &lt; <paramref name="maxPlus1"/>.  If <paramref name="maxPlus1"/> == <paramref name="min"/>, <paramref name="min"/> is returned.</returns>
            <remarks>Same as <see cref="M:System.Random.Next(System.Int32,System.Int32)"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Double">
            <summary>
            Generates a random double-precision value in [0,1).
            </summary>
            <returns>A random double.</returns>
            <remarks>Same as <see cref="M:System.Random.NextDouble"/>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Perm(System.Int32)">
            <summary>
            Generates a random permutation.
            </summary>
            <param name="n">The length of permutation to make. Must be > 0.</param>
            <returns>An array of <paramref name="n"/> unique integers, each in the range [0,<paramref name="n"/>-1].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a finite discrete distribution.
            </summary>
            <param name="prob">prob[i] &gt;= 0 is the probability of outcome i, times an arbitrary constant.</param>
            <returns>An integer from 0 to <c>prob.Count</c>-1.</returns>
            <exception cref="T:MicrosoftResearch.Infer.Maths.AllZeroException">Thrown when prob is all zeros.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Sample(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Generates a random sample from a finite discrete distribution.
            </summary>
            <param name="prob">prob[i] is the probability of outcome i, times <paramref name="Z"/>.  Must be >= 0.</param>
            <param name="sum">The sum of the prob array.  Must be > 0.</param>
            <returns>An integer from 0 to <c>prob.Count</c>-1.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Normal">
            <summary>
            Generates a random sample from a normal distribution.
            </summary>
            <returns>A finite real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Normal(System.Double,System.Double)">
            <summary>
            Generates a random sample from a normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="stdDev">The standard deviation (sqrt of the variance).</param>
            <returns>A finite real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Normal(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="variance">The covariance matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalP(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="precision">The inverse of the covariance matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalChol(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="varChol">The lower triangular Cholesky factor of the covariance matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.NormalPChol(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.UpperTriangularMatrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Generates a random sample from a multivariate normal distribution.
            </summary>
            <param name="mean">The mean of the distribution.  Must be finite.</param>
            <param name="precCholT">The upper triangular transpose of the Cholesky factor of the precision matrix.  Must be positive-definite.</param>
            <param name="result">Receives the result.  Must be non-null and the correct size.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Gamma(System.Double)">
            <summary>
            Generates a random sample from a Gamma distribution.
            </summary>
            <param name="a">The shape parameter.  Must be finite and > 0.</param>
            <returns>A positive finite real number.</returns>
            <remarks>The distribution is defined as p(x) = x^(a-1)*exp(-x)/Gamma(a).
            To incorporate a scale parameter b, multiply the result by b.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Wishart(System.Double,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Generates a random sample from a Wishart distribution.
            </summary>
            <param name="a">The shape parameter.  Must be finite and > 0.</param>
            <param name="result">Receives the lower triangular Cholesky factor of the sampled matrix.  Must be non-null, square, and already allocated to the desired size.</param>
            <remarks><para>
            The <a href="http://en.wikipedia.org/wiki/Wishart_distribution">Wishart distribution</a> 
            is defined as
            </para><para>
            p(X) = |X|^((n-d-1)/2)*exp(-tr(X))/Gamma_d(n/2) (using parameter n)
            </para><para>
            or 
            </para><para>
            p(X) = |X|^(a-(d+1)/2)*exp(-tr(X))/Gamma_d(a) (using parameter a)
            </para><para>
            This routine returns chol(X).  To incorporate a scale parameter C, 
            set Y = chol(C)*X*chol(C)', which implies chol(Y) = chol(C)*chol(X). 
            If you invert and transpose chol(X), then you have chol(inv(X)), 
            where inv(X) is a sample from the inverse Wishart distribution: 
            </para><para>
            p(X) = |X|^(-a-(d+1)/2)*exp(-tr(inv(X)))/Gamma_d(a)
            </para></remarks>
            <example>
            <code>
            Matrix L = new Matrix(d,d);
            Rand.Wishart(a,L);
            Matrix X = new Matrix(d,d);
            X.SetToProduct(L, L.Transpose());
            </code>
            </example>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Beta(System.Double,System.Double)">
            <summary>
            Generates a random sample from the Beta distribution with given parameters.
            </summary>
            <param name="trueCount"></param>
            <param name="falseCount"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Binomial(System.Int32,System.Double)">
            <summary>
            Generates a random sample from the Binomial distribution with parameters p and n.
            </summary>
            <param name="n">Number of trials</param>
            <param name="p">Probability of success per trial</param>
            <remarks>
            References:
             [1]  L. Devroye, "Non-Uniform Random Variate Generation", 
             Springer-Verlag, 1986.
             [2] Kachitvichyanukul, V., and Schmeiser, B. W. "Binomial Random Variate Generation." 
             Comm. ACM, 31, 2 (Feb. 1988), 216.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Rand.Multinomial(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Multinomial distribution with specified probabilities and number of trials.
            </summary>
            <param name="trialCount">Number of trials, >= 0</param>
            <param name="probs">Must sum to 1</param>
            <returns>An array of length <c>probs.Count</c> of integers between 0 and trialCount, whose sum is trialCount.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.AllZeroException">
            <summary>
            Exception type thrown when probability vector = (0,0,0,...,0).
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.AllZeroException.#ctor">
            <summary>
            Constructs the exception.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.AllZeroException.#ctor(System.String)">
            <summary>
            Constructs the exception with a message
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItem2DOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItem2D``1(``0[0:,0:],System.Int32,System.Int32)"/>, given random arguments to the function.
            This factor gets an item from an array of items
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.LogEvidenceRatio``1(``0,MicrosoftResearch.Infer.Collections.IArray2D{``0})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="array">Incoming message from 'array'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.LogEvidenceRatio``1(`0,MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32)">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="Distribution"></typeparam>
            <param name="item"></param>
            <param name="array"></param>
            <param name="index1"></param>
            <param name="index2"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ItemAverageConditional``1(MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32,``0)">
            <summary>
            EP message to 'item'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'item'.
            The formula is <c>int f(item,x) q(x) dx</c> where <c>x = (array,index1,index2)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageConditional``2(``0,System.Int32,System.Int32,``1)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int f(array,x) q(x) dx</c> where <c>x = (item,index1,index2)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageConditional``2(`0,System.Int32,System.Int32,``1)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int f(array,x) q(x) dx</c> where <c>x = (item,index1,index2)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (item,array,index)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ItemAverageLogarithm``1(MicrosoftResearch.Infer.Collections.IArray2D{``0},System.Int32,System.Int32,``0)">
            <summary>
            VMP message to 'item'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'item'.
            The formula is <c>int log(f(item,x)) q(x) dx</c> where <c>x = (array,index1,index2)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageLogarithm``2(``0,System.Int32,System.Int32,``1)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="item">Incoming message from 'item'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int log(f(array,x)) q(x) dx</c> where <c>x = (item,index1,index2)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="item"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItem2DOp`1.ArrayAverageLogarithm``2(`0,System.Int32,System.Int32,``1)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="item">Constant value for 'item'.</param>
            <param name="index1">Constant value for 'index1'.</param>
            <param name="index2">Constant value for 'index2'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int log(f(array,x)) q(x) dx</c> where <c>x = (item,index1,index2)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExitingVariableOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ExitingVariable``1(``0,``0)"/>, given random arguments to the function.
            </summary>
            <remarks><para>
            This factor is like ReplicateWithMarginal except Uses[0] plays the role of Def, and Def is
            considered a Use.  Needed only when a variable exits a gate in VMP.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExitingVariableOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (Uses,Def,Marginal)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExitingVariableOp.MarginalAverageLogarithm``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'Marginal'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Marginal'.
            The formula is <c>int log(f(Marginal,x)) q(x) dx</c> where <c>x = (Uses,Def)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExitingVariableOp.UsesAverageLogarithm``1(System.Collections.Generic.IList{``0},``0,System.Int32,``0)">
            <summary>
            VMP message to 'Uses'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'.</param>
            <param name="Def">Incoming message from 'Def'.</param>
            <param name="resultIndex">Index of the 'Uses' array for which a message is desired.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Uses'.
            The formula is <c>int log(f(Uses,x)) q(x) dx</c> where <c>x = (Def,Marginal)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExitingVariableOp.DefAverageLogarithm``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'Def'.
            </summary>
            <param name="Uses">Incoming message from 'Uses'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Def'.
            The formula is <c>int log(f(Def,x)) q(x) dx</c> where <c>x = (Uses,Marginal)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Uses"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateExitOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.Exit``1(System.Boolean[],``0[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp.LogEvidenceRatio``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0})">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp.ValuesAverageConditional``2(``0,``1)">
            <summary>
            EP message to 'values'.
            </summary>
            <param name="exit">Incoming message from 'exit'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'values'.
            The formula is <c>int f(values,x) q(x) dx</c> where <c>x = (exit,cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exit"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp.ExitAverageConditional2``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>
            EP message to 'exit'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'exit'.
            The formula is <c>int f(exit,x) q(x) dx</c> where <c>x = (cases,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp.CasesAverageConditional``3(``0,System.Collections.Generic.IList{``1},``2)">
            <summary>
            EP message to 'cases'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int f(cases,x) q(x) dx</c> where <c>x = (exit,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp.ExitAverageConditional``2(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``1},``0)">
            <summary>
            EP message to 'exit'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'exit'.
            The formula is <c>int f(exit,x) q(x) dx</c> where <c>x = (cases,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp.AverageLogFactor``1(``0,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0})">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (exit,cases,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp.ValuesAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'values'.
            </summary>
            <param name="exit">Incoming message from 'exit'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'values'.
            The formula is <c>int log(f(values,x)) q(x) dx</c> where <c>x = (exit,cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exit"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp.CasesAverageLogarithm``2(``0,System.Collections.Generic.IList{``0},``1)">
            <summary>
            VMP message to 'cases'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (exit,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitOp.ExitAverageLogarithm``1(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'exit'.
            </summary>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'exit'.
            The formula is <c>int log(f(exit,x)) q(x) dx</c> where <c>x = (cases,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateExitTwoOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.Exit``1(System.Boolean[],``0[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ValuesAverageConditional``2(``0,``1)">
            <summary>
            EP message to 'values'.
            </summary>
            <param name="exit">Incoming message from 'exit'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'values'.
            The formula is <c>int f(values,x) q(x) dx</c> where <c>x = (exit,cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exit"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case0AverageConditional``1(System.Collections.Generic.IList{``0})">
            <summary>
            EP message to 'case0'.
            </summary>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'case0'.
            The formula is <c>int f(cases,x) q(x) dx</c> where <c>x = (exit,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case1AverageConditional``1(System.Collections.Generic.IList{``0})">
            <summary>
            EP message to 'case1'.
            </summary>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'case1'.
            The formula is <c>int f(cases,x) q(x) dx</c> where <c>x = (exit,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ExitTwoAverageConditional``1(``0,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``0},``0)">
            <summary>
            EP message to 'exit'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'exit'.
            The formula is <c>int f(exit,x) q(x) dx</c> where <c>x = (cases,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case0AverageConditional``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            EP message to 'case0'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'case0'.
            The formula is <c>int f(cases,x) q(x) dx</c> where <c>x = (exit,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case1AverageConditional``2(``0,System.Collections.Generic.IList{``1})">
            <summary>
            EP message to 'case1'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'case1'.
            The formula is <c>int f(cases,x) q(x) dx</c> where <c>x = (exit,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ExitTwoAverageConditional``2(``0,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``1},``0)">
            <summary>
            EP message to 'exit'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'exit'.
            The formula is <c>int f(exit,x) q(x) dx</c> where <c>x = (cases,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.AverageLogFactor``1(``0,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``0})">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (exit,cases,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ValuesAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'values'.
            </summary>
            <param name="exit">Incoming message from 'exit'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'values'.
            The formula is <c>int log(f(values,x)) q(x) dx</c> where <c>x = (exit,cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exit"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case0AverageLogarithm``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
            VMP message to 'case0'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (exit,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.Case1AverageLogarithm``1(``0,System.Collections.Generic.IList{``0})">
            <summary>
            VMP message to 'case1'.
            </summary>
            <param name="exit">Incoming message from 'exit'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (exit,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitTwoOp.ExitTwoAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'exit'.
            </summary>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'exit'.
            The formula is <c>int log(f(exit,x)) q(x) dx</c> where <c>x = (cases,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GateExitRandomOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.ExitRandom``1(System.Boolean[],``0[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (Exit,cases,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ValuesAverageLogarithm``2(``0,``1)">
            <summary>
            VMP message to 'values'.
            </summary>
            <param name="exit">Incoming message from 'Exit'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'values'.
            The formula is <c>int log(f(values,x)) q(x) dx</c> where <c>x = (Exit,cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exit"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.CasesAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'cases'.
            </summary>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (Exit,values)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GateExitRandomOp.ExitAverageLogarithm``1(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},System.Collections.Generic.IList{``0},``0)">
            <summary>
            VMP message to 'Exit'.
            </summary>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="values">Incoming message from 'values'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Exit'.
            The formula is <c>int log(f(Exit,x)) q(x) dx</c> where <c>x = (cases,values)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="values"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.WishartEstimator">
            <summary>
            Estimates a Wishart distribution from samples.
            </summary>
            <remarks><code>
            The distribution is estimated via moment matching (not maximum-likelihood).
            E[X] = (a+(d+1)/2)/B
            var(X_ii) = (a+(d+1)/2)*diag(inv(B))^2
            because X_ii ~ Gamma(a+(d+1)/2, 1/diag(inv(B))).
            Therefore: 
            a = E[X_ii]^2/var(X_ii) - (d+1)/2
            B = (a+(d+1)/2)/E[X]
            </code></remarks>
            In the one-dimensional case,
            E[log(x)] = -log(b) + digamma(a+1) 
                      =approx -log(b) + log(a+1) - 1/2/(a+1) 
                      = log(E[x]) - 1/2/(a+1)
            In the Wishart case,
            E[logdet(X)] = -logdet(B) + sum_{i=0..d-1} digamma(a + (d+1-i)/2)
                         =approx -logdet(B) + d*digamma(a+(d+1)/2)
                         =approx -logdet(B) + d*log(a+(d+1)/2) - d/2/(a+(d+1)/2) 
                         = log(E[X}) - d/2/(a+(d+1)/2)
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.WishartEstimator.mva">
            <summary>
            Where to accumulate mean and variance matrices
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new Wishart estimator
            </summary>
            <param name="dimension">The dimension of the Wishart distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Retrieves the Wishart estimator
            </summary>
            <param name="result">Where to put the result</param>
            <returns>The resulting distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Add(MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Adds a Wishart distribution item to the estimator
            </summary>
            <param name="item">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Add(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="item">The sample to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.SetTo(MicrosoftResearch.Infer.Distributions.WishartEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.WishartEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.WishartEstimator.Dimension">
            <summary>
            The dimension of the Wishart distribution
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Mixture`1">
            <summary>
            A mixture of distributions of the same type 
            </summary>
            <typeparam name="T">The distribution type</typeparam>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Mixture`1.Components">
            <summary>
            The components
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Mixture`1.Weights">
            <summary>
            The mixing weight of each component.  Does not necessarily sum to 1.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Add(`0,System.Double)">
            <summary>
            Add a component to the mixture with a given weight
            </summary>
            <param name="item">The component to add</param>
            <param name="weight">The weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Add(`0)">
            <summary>
            Add a component to the mixture. A weight of 1 is assumed
            </summary>
            <param name="item">The component to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.WeightSum">
            <summary>
            The sum of the component weights
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Normalize">
            <summary>
            Normalize the weights to add to 1
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.GetDistribution(MicrosoftResearch.Infer.Distributions.Mixture{`0})">
            <summary>
            The the resulting mixture
            </summary>
            <param name="result">Where to put the resulting mixture</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.#ctor">
            <summary>
            Create a mixture model
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Mixture`1.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Gaussian">
            <summary>
            Represents a one-dimensional Gaussian distribution.
            </summary>
            <remarks><para>
            The distribution is represented by two parameters: MeanTimesPrecision and Precision.
            Precision is the inverse of the variance, so a Gaussian with mean m and variance v is
            represented as Precision = 1/v, MeanTimesPrecision = m/v.
            </para><para>
            Some special cases:
            If the Precision is zero, then the distribution is uniform.
            If the Precision is infinite, then the distribution is a point mass.  The Point property
            gives the location of the point mass.
            </para><para>
            The formula for the distribution is:
            <c>N(x;m,v) = 1/sqrt(2*pi*v) * exp(-(x-m)^2/(2v))</c>.
            When v=0, this reduces to delta(x-m).
            When v=infinity, the density is redefined to be 1.
            When v &lt; 0, the density is redefined to be <c>exp(-0.5*x^2*(1/v) + x*(m/v))</c>, 
            i.e. we drop the terms <c>exp(-m^2/(2v))/sqrt(2*pi*v)</c>.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gaussian.MeanTimesPrecision">
            <summary>
            Mean times precision
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gaussian.Precision">
            <summary>
            Precision
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMeanAndVarianceImproper(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance, even if the distribution is improper
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMeanAndPrecision(System.Double@,System.Double@)">
            <summary>
            Gets the mean and precision
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="precision">Where to put the precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetMeanAndPrecision(System.Double,System.Double)">
            <summary>
            Sets the mean and precision
            </summary>
            <param name="mean">Mean</param>
            <param name="precision">Precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetNatural(System.Double@,System.Double@)">
            <summary>
            Gets the natural parameters of the distribution (mean time precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Where to put the mean times precision</param>
            <param name="precision">Where to put the precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetNatural(System.Double,System.Double)">
            <summary>
            Sets the natural parameters of the distribution (mean time precision, and precision)
            </summary>
            <param name="meanTimesPrecision">Mean times precision</param>
            <param name="precision">Precision</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetMean">
            <summary>
            Gets the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetVariance">
            <summary>
            Gets the variance
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing mean
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetDomainPrototype">
            <summary>
            Gets a domain prototype. The domain for the Gaussian distribution is
            the real line, so a value of 0.0 is returned.
            </summary>
            <returns>0.0</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToUniform">
            <summary>
            Sets this Gaussian instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.IsProper">
            <summary>
            Asks whether this Gaussian instance is proper or not. A Gaussian distribution
            is proper only if Precision > 0.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogProb(System.Double,System.Double,System.Double)">
            <summary>
            Evaluates the log of one-dimensional Gaussian density.
            </summary>
            <param name="x">Must be finite.</param>
            <param name="mean">Must be finite.</param>
            <param name="variance">Any real number.  May be zero or negative.</param>
            <remarks>
            <c>N(x;m,v) = 1/sqrt(2*pi*v) * exp(-(x-m)^2/(2v))</c>.
            When v=0, this reduces to delta(x-m).
            When v=infinity, the density is redefined to be 1.
            When v &lt; 0, the density is redefined to be <c>exp(-0.5*x^2*(1/v) + x*(m/v))</c>, 
            i.e. we drop the terms <c>exp(-m^2/(2v))/sqrt(2*pi*v)</c>.
            </remarks>
            <returns><c>log(N(x;mean,variance))</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogProb(System.Double)">
            <summary>
            Evaluates the log of this one-dimensional Gaussian density.
            </summary>
            <param name="x">Must be finite.</param>
            <returns><c>log(N(x;mean,variance))</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogNormalizer">
            <summary>
            Gets the log of the normalizer for the Gaussian density function
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetAverageLog(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gets the expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double,System.Double)">
            <summary>
            Samples from a Gaussian distribution with the specified mean and precision
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample">
            <summary>
            Samples from this Gaussian distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Sample(System.Double)">
            <summary>
            Samples from this Gaussian distribution. This override is only
            present to support the Sampleable interface
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetTo(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets this Gaussian instance to have the parameter values of that Gaussian instance
            </summary>
            <param name="that">That Gaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToProduct(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets the parameters to represent the product of two Gaussians.
            </summary>
            <param name="a">The first Gaussian</param>
            <param name="b">The second Gaussian</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_Multiply(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Creates a new Gaussian which is the product of two other Gaussians
            </summary>
            <param name="a">First Gaussian</param>
            <param name="b">Second Gaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets the parameters to represent the ratio of two Gaussians.
            </summary>
            <param name="numerator">The numerator Gaussian</param>
            <param name="denominator">The denominator Gaussian</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToRatioProper(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets the parameters to represent the ratio of two Gaussians, forcing the precision to be non-negative.
            </summary>
            <param name="numerator">The numerator Gaussian</param>
            <param name="denominator">The denominator Gaussian</param>
            <remarks>
            The result is always proper.  Multiplying the result and <paramref name="denominator"/> will always give the same mean
            as <paramref name="numerator"/>, but the variance may be smaller than <paramref name="numerator"/>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_Division(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Creates a new Gaussian which is the ratio of two other Gaussians
            </summary>
            <param name="numerator">numerator Gaussian</param>
            <param name="denominator">denominator Gaussian</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToPower(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Gaussian to some exponent.
            </summary>
            <param name="dist">The source Gaussian</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Sets the mean and variance to match a Gaussian mixture.
            </summary>
            <param name="weight1">First weight</param>
            <param name="g1">First Gaussian</param>
            <param name="weight2">Second weight</param>
            <param name="g2">Second Gaussian</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.WeightedSum``1(``0,System.Double,``0,System.Double,``0)">
            <summary>
            Creates a distribution of the specified type which matchs the mean and variance
            of a Gaussian mixture. The distribution type must implement <see cref="T:MicrosoftResearch.Infer.Distributions.CanGetMeanAndVarianceOut`2"/>,
            </summary>
            <see cref="T:MicrosoftResearch.Infer.Distributions.CanSetMeanAndVariance`2"/>, and <see cref="T:MicrosoftResearch.Infer.Distributions.SettableToUniform"/>
            <typeparam name="T">Distribution type for the mixture</typeparam>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second distribution</param>
            <param name="result">Resulting distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gets the integral of the product of two Gaussians.
            </summary>
            <param name="that"></param>
            <remarks>
            <c>this = N(x;m1,v1)</c>.
            <c>that = N(x;m2,v2)</c>.
            <c>int_(-infinity)^(infinity) N(x;m1,v1) N(x;m2,v2) dx = N(m1; m2, v1+v2)</c>.
            When improper, the density is redefined to be <c>exp(-0.5*x^2*(1/v) + x*(m/v))</c>, 
            i.e. we drop the terms <c>exp(-m^2/(2v))/sqrt(2*pi*v)</c>.
            </remarks>
            <returns>log(N(m1;m2,v1+v2)).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetLogAverageOfInverse(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gets the integral of the ratio of two Gaussians.
            </summary>
            <param name="that"></param>
            <remarks>
            <c>this = N(x;m1,v1)</c>.
            <c>that = N(x;m2,v2)</c>.
            <c>int_(-infinity)^(infinity) N(x;m1,v1) / N(x;m2,v2) dx = v2/(v2-v1)/N(m1; m2, v2-v1)</c>.
            When v=infinity, we treat N(x;m,v) as 1.
            When v &lt; 0, the density is redefined to be <c>exp(-0.5*x^2*(1/v) + x*(m/v))</c>, 
            i.e. we drop the terms <c>exp(-m^2/(2v))/sqrt(2*pi*v)</c>.
            </remarks>
            <returns>log(v2/(v2-v1)/N(m1;m2,v2-v1)).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Gaussian
            and that Gaussian
            </summary>
            <param name="thatd">That Gaussian</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.#ctor(System.Double,System.Double)">
            <summary>
            Creates a Gaussian distribution with specified mean and variance.
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.#ctor(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Clone">
            <summary>
            Clones this Gaussian. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Gaussian type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a Gaussian distribution with given mean and variance.
            </summary>
            <param name="mean">The desired mean.</param>
            <param name="variance">The desired variance.</param>
            <returns>A new Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.FromMeanAndPrecision(System.Double,System.Double)">
            <summary>
            Creates a Gaussian distribution with given mean and precision.
            </summary>
            <param name="mean">The desired mean.</param>
            <param name="precision">precision = 1/variance.</param>
            <returns>A new Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.FromNatural(System.Double,System.Double)">
            <summary>
            Creates a new Gaussian distribution from its natural parameters
            (Mean times precision, and Precision)
            </summary>
            <param name="meanTimesPrecision">Mean time precision</param>
            <param name="precision">Precision</param>
            <returns>A new Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.Uniform">
            <summary>
            Creates a new uniform Gaussian distribution
            </summary>
            <returns>A new uniform Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.PointMass(System.Double)">
            <summary>
            Creates a new point mass Gaussian distribution at a specified location
            </summary>
            <param name="mean">The location for the point mass</param>
            <returns>A new point mass Gaussian distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gaussian.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gaussian.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gaussian.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistWithSample`2">
            <summary>
            A distribution and sample pair. This is used for message
            passing in some algorithms such as Gibbs Sampling
            </summary>
            <typeparam name="TDist">Distribution type</typeparam>
            <typeparam name="T">Domain of distribution</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.#ctor(`0)">
            <summary>
            Constructs a DistWithSample from a distribution
            </summary>
            <param name="dist"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.#ctor(`0,`1)">
            <summary>
            Constructs a DistWithSample from a distribution and sample
            </summary>
            <param name="dist"></param>
            <param name="sample"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.op_Explicit(`0)~MicrosoftResearch.Infer.Distributions.DistWithSample{`0,`1}">
            <summary>
            Explicit conversion from unlderlying distribution
            </summary>
            <param name="dist"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToUniform">
            <summary>
            Sets the dist/sample to be uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.IsUniform">
            <summary>
            Returns true if uniform
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.Clone">
            <summary>
            Clone this DistWithSample
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.GetDomainPrototype">
            <summary>
            Gets a domain prototype
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this distribution
            and that distribution
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.GetLogProb(`1)">
            <summary>
            Gets log density at the given value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetTo(MicrosoftResearch.Infer.Distributions.DistWithSample{`0,`1})">
            <summary>
            Sets this dist/sample from another dist/sample
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetTo(`0)">
            <summary>
            Sets this dist/sample from another dist/sample
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetTo(MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Sets this dist/sample from a compatible distribution
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.Sample">
            <summary>
            Sample and set the CurrentSample to the new sample
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.Sample(`1)">
            <summary>
            Sample and set the CurrentSample to the new sample
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToProduct(`0,`0)">
            <summary>
            Set this DistWithSample to a product of two TDists
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistWithSample{`0,`1},`0)">
            <summary>
            Set this DistWithSample to a product of a DistWithSample and a TDist
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToProduct(`0,MicrosoftResearch.Infer.Distributions.DistWithSample{`0,`1})">
            <summary>
            Set this DistWithSample to a product of a TDist and a DistWithSample
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistWithSample{`0,`1},MicrosoftResearch.Infer.Distributions.DistWithSample{`0,`1})">
            <summary>
            Set this DistWithSample to a product of two other DistWithSample over this domain
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToProduct(MicrosoftResearch.Infer.Distributions.IDistribution{`1},MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Set this DistWithSample to a product of two other distributions over this domain
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToRatio(`0,`0)">
            <summary>
            Set this DistWithSample to a ratio of two TDists
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistWithSample{`0,`1},`0)">
            <summary>
            Set this DistWithSample to a ratio of a DistWithSample and a TDist
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToRatio(`0,MicrosoftResearch.Infer.Distributions.DistWithSample{`0,`1})">
            <summary>
            Set this DistWithSample to a ratio of a TDist and a DistWithSample
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistWithSample{`0,`1},MicrosoftResearch.Infer.Distributions.DistWithSample{`0,`1})">
            <summary>
            Set this DistWithSample to a ratio of two other DistWithSample over this domain
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToRatio(MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1},`0)">
            <summary>
            Set this DistWithSample to a ratio of a Gibbs marginal and a TDist
            This is used to update the sample
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetToRatio(MicrosoftResearch.Infer.Distributions.IDistribution{`1},MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Set this DistWithSample to a ratio of two other distributions over this domain
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.ToString">
            <summary>
            String representation of current instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.PostUpdate">
            <summary>
            Does nothing for DistWithSample
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.PostUpdateWith(MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Post update from a distribution
            </summary>
            <param name="dist"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.PostUpdateWith(MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1})">
            <summary>
            Post update from Gibbs marginal
            </summary>
            <param name="dist"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.MultiplyIntoTarget(`0,`0)">
            <summary>
            Multiply this instance with another instance and set the target
            </summary>
            <param name="target"></param>
            <param name="other"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.MultiplyIntoTarget(MicrosoftResearch.Infer.Distributions.IDistribution{`1},MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Multiply this instance with another instance and set the target
            </summary>
            <param name="target"></param>
            <param name="other"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetTarget(`0)">
            <summary>
            Set the target distribution. As this may be a struct, the
            target is returned
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistWithSample`2.SetTarget(MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Set the target distribution. As this may be a struct, the
            target is returned
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistWithSample`2.Distribution">
            <summary>
            Distribution reference
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistWithSample`2.CurrentSample">
            <summary>
             sample
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistWithSample`2.Point">
            <summary>
            Gets/sets this distrution as a point
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistWithSample`2.IsPointMass">
            <summary>
            Returns true if the underlying distribution is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Beta">
            <summary>
            A Beta distribution over the interval [0,1].
            </summary>
            <remarks><para>
            The Beta is often used as a distribution on probability values.
            The formula for the distribution is <c>p(x) = (Gamma(trueCount+falseCount)/Gamma(trueCount)/Gamma(falseCount)) x^{trueCount-1} (1-x)^(falseCount-1)</c>
            subject to the constraint 0 &lt;= x &lt;= 1.
            </para><para>
            If trueCount = falseCount = 1, the distribution is uniform.
            If falseCount = infinity, the distribution is redefined to be a point mass on trueCount.
            When trueCount &lt;= 0 or falseCount &lt;= 0, the distribution is improper.
            In this case, the density is redefined to not include the Gamma terms, i.e.
            there is no normalizer.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Beta.TrueCount">
            <summary>
            True count
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Beta.FalseCount">
            <summary>
            False count
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.IsProper">
            <summary>
            Whether the distribution is proper or not. It is improper
            when trueCount &lt;= 0 or falseCount &lt;= 0 in which case it
            cannot be normalised
            </summary>
            <returns>true if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMean">
            <summary>
            The expected value E[p].
            </summary>
            <returns><c>TrueCount/TotalCount</c></returns>
            <remarks>The result must be between 0 and 1.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanSquare">
            <summary>
            The expected square E[p^2].
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanCube">
            <summary>
            The expected cube E[p^3].
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanLog">
            <summary>
            The expected logarithm E[log(p)].
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanLogs(System.Double@,System.Double@)">
            <summary>
            The expected logarithms E[log(p)] and E[log(1-p)].
            </summary>
            <param name="eLogP"></param>
            <param name="eLogOneMinusP"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetVariance">
            <summary>
            The variance var(p).
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance for this instance
            </summary>
            <param name="mean">Mean value - output</param>
            <param name="variance">Variance - output</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance for this instance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetDomainPrototype">
            <summary>
            The type of the domain of Beta is double (the domain is the interval [0.0,1.0].
            A value of 0.0 is returned as the domain prototype
            </summary>
            <returns>0.0</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Clone">
            <summary>
            Clones this Beta. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Beta type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.MaxDiff(System.Object)">
            <summary>
            The maximum 'difference' between the parameters of this instance and of that instance.
            </summary>
            <param name="thatd">That distribution</param>
            <returns>The resulting maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="that">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToUniform">
            <summary>
            Sets this instance to be uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.IsUniform">
            <summary>
            Whether the distribution is uniform
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogProb(System.Double)">
            <summary>
            Evaluates the logarithm of the density function
            </summary>
            <param name="value">Domain value</param>
            <returns>Log of the probability density for the given domain value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogNormalizer">
            <summary>
            Gets the log normalizer for the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.BetaLn(System.Double,System.Double)">
            <summary>
            Computes the log Beta function: <c>GammaLn(trueCount)+GammaLn(falseCount)-GammaLn(trueCount+falseCount)</c>.
            </summary>
            <param name="trueCount">Any real number.</param>
            <param name="falseCount">Any real number.</param>
            <returns><c>GammaLn(trueCount)+GammaLn(falseCount)-GammaLn(trueCount+falseCount)</c></returns>
            <remarks>
            If trueCount &lt;= 0 or falseCount &lt;= 0, the result is defined to be 0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetAverageLog(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetTo(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">that instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToProduct(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Sets the parameters to represent the product of two Betas.
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <remarks>
            The result may not be proper, i.e. its parameters may be negative.
            For example, if you multiply Beta(0.1,0.1) by itself you get Beta(-0.8, -0.8).
            No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_Multiply(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Static product operator. Create a Beta distribution which is the product of
            two Beta distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToRatio(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Sets the parameters to represent the ratio of two Betas.
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <remarks>
            The result may not be proper, i.e. its parameters may be negative.
            No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_Division(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Static ratio operator. Create a Beta distribution which is the ratio of 
            two Beta distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToPower(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Sets the parameters to represent the a Beta raised to some power.
            </summary>
            <param name="dist">The distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Beta,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Beta.AllowImproperSum">
            <summary>
            Property to allow an improper sum
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Beta,System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Sets the parameters to represent the weighted sum of two Betas.
            </summary>
            <param name="dist1">The first distribution</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            The log of the integral of the product of this Beta and that Beta
            </summary>
            <param name="that">That beta</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Sample">
            <summary>
            Sample from this Beta distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Sample(System.Double,System.Double)">
            <summary>
            Static method to sample from a Beta distribution with the specified true and false counts
            </summary>
            <param name="trueCount">True count</param>
            <param name="falseCount">False count</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.#ctor(System.Double,System.Double)">
            <summary>
            Creates a Beta distribution with the given parameters.
            </summary>
            <param name="trueCount"></param>
            <param name="falseCount"></param>
            <remarks>
            The formula for the distribution is <c>p(x) = (Gamma(trueCount+falseCount)/Gamma(trueCount)/Gamma(falseCount)) x^{trueCount-1} (1-x)^(falseCount-1)</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.#ctor(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a new Beta distribution from a specified mean and variance
            </summary>
            <param name="mean">mean</param>
            <param name="variance">variance</param>
            <returns>The new Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.FromMeanLogs(System.Double,System.Double)">
            <summary>
            Constructs a Beta distribution with the given E[log(p)] and E[log(1-p)].
            </summary>
            <param name="eLogP">Desired expectation E[log(p)].</param>
            <param name="eLogOneMinusP">Desired expectation E[log(1-p)].</param>
            <returns>A new Beta distribution.</returns>
            <remarks>This function is equivalent to maximum-likelihood estimation of a Beta distribution
            from data given by sufficient statistics. So we want to maximize
            (a-1)eLogP + (b-1)eLogOneMinusP + Gamma(a+b) - Gamma(a) - Gamma(b)
            with respect to a, b where a=trueCount, b=falseCount.
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.Uniform">
            <summary>
            Instantiates a uniform Beta distribution
            </summary>
            <returns>A new uniform Beta distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.PointMass(System.Double)">
            <summary>
            Instantiates a point-mass Beta distribution
            </summary>
            <param name="mean">The domain value where the point mass occurs</param>
            <returns>A new point-mass Beta distribution at the specified location</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Beta.ToString">
            <summary>
            Override of the ToString method
            </summary>
            <returns></returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Beta.TotalCount">
            <summary>
            The sum of TrueCount and FalseCount.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Beta.Point">
            <summary>
            Gets/sets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Beta.IsPointMass">
            <summary>
            Whether the instance is a point mass beta distribution
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1">
            <summary>
            A discrete distribution over the values of an enum.
            </summary>
            <typeparam name="TEnum"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.#ctor">
            <summary>
            Creates a uniform distribution over the enum values.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.#ctor(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates a distribution over the enum values using the probabilities from the given discrete distribution.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.#ctor(System.Double[])">
            <summary>
            Creates a discrete distribution over enum values from the given probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a discrete distribution over enum values from the given vector of probabilities.
            </summary>
            <param name="probs"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.GetDomainPrototype">
            <summary>
            Returns the domain prototype for the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.Uniform">
            <summary>
            Creates a uniform distribution over the enum values.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.SetTo(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">That instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.SetToProduct(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Sets the parameters to represent the product of two discrete enum distributions.
            </summary>
            <param name="a">The first discrete enum distribution</param>
            <param name="b">The second discrete enum distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.SetToRatio(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Sets the parameters to represent the ratio of two discrete enum distributions.
            </summary>
            <param name="numerator">The numerator discrete enum distribution</param>
            <param name="denominator">The denominator discrete enum distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.SetToPower(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},System.Double)">
            <summary>
            Sets the parameters to represent the power of a discrete enum distributions.
            </summary>
            <param name="value">The discrete enum distribution</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0},System.Double,MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            Sets the parameters to represent the weighted sum of two discrete enum distributions.
            </summary>
            <param name="value1">The first discrete enum distribution</param>
            <param name="weight1">The first weight</param>
            <param name="value2">The second discrete enum distribution</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            The log of the integral of the product of this discrete enum and that discrete enum
            </summary>
            <param name="that">That discrete enum distribution</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.GetAverageLog(MicrosoftResearch.Infer.Distributions.DiscreteEnum{`0})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEnum`1.ToString">
            <summary>
            Returns a string representation of this discrete enum distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.VectorGaussianOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.VectorGaussian(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogFactorValue(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for Gibbs.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns>Logarithm of the factor's value at the given arguments.</returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Gibbs message to 'sample'.
            </summary>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Gibbs message to 'mean'.
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'mean' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gibbs message to 'precision'.
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <param name="diff">Workspace for storing difference between sample and mean</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Gibbs message to 'precision'.
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'precision' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int f(mean,x) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'mean'.
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int f(mean,x) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            EP message to 'precision'.
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int f(precision,x) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision">Incoming message from 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision">Constant value for 'precision'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.ComputeAverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Helper method for computing average log factor
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="precision_Elogx">Expected log value of the incoming message from 'precision'</param>
            <param name="precision_Ex">Expected value of incoming message from 'precision'</param>
            <returns>Computed average log factor</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="Precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="Precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'mean'.
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int log(f(mean,x)) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'mean'.
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="Precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int log(f(mean,x)) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'mean'.
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="Precision">Constant value for 'precision'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int log(f(mean,x)) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'mean'.
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Precision">Incoming message from 'precision'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'mean'.
            The formula is <c>int log(f(mean,x)) q(x) dx</c> where <c>x = (sample,precision)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Precision"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'precision'.
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int log(f(precision,x)) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'precision'.
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int log(f(precision,x)) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'precision'.
            </summary>
            <param name="Sample">Constant value for 'sample'.</param>
            <param name="Mean">Incoming message from 'mean'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int log(f(precision,x)) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Mean"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.VectorGaussianOp.PrecisionAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Wishart)">
            <summary>
            VMP message to 'precision'.
            </summary>
            <param name="Sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="Mean">Constant value for 'mean'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'precision'.
            The formula is <c>int log(f(precision,x)) q(x) dx</c> where <c>x = (sample,mean)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sample"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PowerPlate">
            <summary>
            Power plate factor method
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlate.Enter``1(``0,System.Double)">
            <summary>
            Copy a value from outside to the inside of a power plate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="exponent"></param>
            <returns>A copy of value.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PowerPlateOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.PowerPlate.Enter``1(``0,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.ValueAverageConditional``1(``0,System.Double,``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="enter">Incoming message from 'enter'.</param>
            <param name="exponent">Constant value for 'exponent'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (enter,exponent)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.EnterAverageConditional``1(``0,``0,System.Double,``0)">
            <summary>
            EP message to 'enter'.
            </summary>
            <param name="enter">Incoming message from 'enter'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="exponent">Constant value for 'exponent'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'enter'.
            The formula is <c>int f(enter,x) q(x) dx</c> where <c>x = (value,exponent)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.LogEvidenceRatio">
            <summary>
            Returns 0.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.AverageLogFactor">
            <summary>
            Returns 0.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.ValueAverageLogarithm``1(``0,System.Double,``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="enter">Incoming message from 'enter'.</param>
            <param name="exponent">Constant value for 'exponent'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PowerPlateOp.EnterAverageLogarithm``1(``0,``0,System.Double,``0)">
            <summary>
            VMP message to 'enter'.
            </summary>
            <param name="enter">Incoming message from 'enter'.</param>
            <param name="value">Incoming message from 'value'.</param>
            <param name="exponent">Constant value for 'exponent'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Damp">
            <summary>
            Damp factor methods
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Damp.Backward``1(``0,System.Double)">
            <summary>
            Copy a value and damp the backward message.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="stepsize">1.0 means no damping, 0.0 is infinite damping.</param>
            <returns></returns>
            <remarks>
            If you use this factor, be sure to increase the number of algorithm iterations appropriately.
            The number of iterations should increase according to the reciprocal of stepsize.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Damp.Forward``1(``0,System.Double)">
            <summary>
            Copy a value and damp the forward message.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="stepsize">1.0 means no damping, 0.0 is infinite damping.</param>
            <returns></returns>
            <remarks>
            If you use this factor, be sure to increase the number of algorithm iterations appropriately.
            The number of iterations should increase according to the reciprocal of stepsize.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DampBackwardOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Damp.Backward``1(``0,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampBackwardOp.ValueAverageConditional``1(``0,System.Double,``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="backward">Incoming message from 'backward'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="stepsize">Constant value for 'stepsize'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (backward,stepsize)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="backward"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampBackwardOp.BackwardAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'backward'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'backward'.
            The formula is <c>int f(backward,x) q(x) dx</c> where <c>x = (value,stepsize)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DampForwardOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Damp.Forward``1(``0,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampForwardOp.ForwardAverageConditional``1(``0,System.Double,``0)">
            <summary>
            EP message to 'forward'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="stepsize">Constant value for 'stepsize'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'forward'.
            The formula is <c>int f(forward,x) q(x) dx</c> where <c>x = (value,stepsize)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DampForwardOp.ValueAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="forward">Incoming message from 'forward'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (forward,stepsize)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="forward"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Buffer">
            <summary>
            Buffer factors
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Buffer.Value``1">
            <summary>
            Value factor
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Buffer.Infer``1(``0)">
            <summary>
            Infer factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BufferOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Buffer.Value``1"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferOp.ValueAverageConditional``1(``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'value' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = ()</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BufferOp.ValueAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'value' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = ()</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.InferOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Buffer.Infer``1(``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InferOp.ValueAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (infer)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InferOp.ValueAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = (infer)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ArrayEstimator`5">
            <summary>
            Estimator for a DistributionArray type.
            </summary>
            <typeparam name="ItemEstimator">Type of estimator for each array element.</typeparam>
            <typeparam name="DistributionArray">Type of DistributionArray to estimate.</typeparam>
            <typeparam name="Distribution">Type of a DistributionArray element.</typeparam>
            <typeparam name="DomainArray">Domain type of the DistributionArray.</typeparam>
            <typeparam name="Domain">Type of a DomainArray element.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.AssertFailedException">
            <summary>
            Thrown when Assert.IsTrue fails.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Assert">
            <summary>
            Assertion methods for debugging.
            </summary>
            <remarks>To catch assertion failures in the debugger:
            Debug -> Exceptions -> Add
            Microsoft.VisualStudio.TestTools.UnitTesting.AssertFailedException
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Assert.IsTrue(System.Boolean,System.String)">
            <summary>
            Checks if a condition is true; if not, an exception is thrown with an error message.
            </summary>
            <param name="condition">Condition that must be true</param>
            <param name="message">Message to be output by the exception</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Assert.IsTrue(System.Boolean)">
            <summary>
            Checks if a condition is true; if not, an exception  without error message is thrown.
            </summary>
            <param name="condition">Condition that must be true</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.AssertWhenDebugging">
            <summary>
            Assertion methods which are stripped out in release mode.
            </summary>
            <remarks>To catch assertion failures in the debugger:
            Debug -> Exceptions -> Add
            Microsoft.VisualStudio.TestTools.UnitTesting.AssertFailedException
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.AssertWhenDebugging.IsTrue(System.Boolean,System.String)">
            <summary>
            Checks if a condition is true; if not, an exception is thrown with an error message.
            </summary>
            <param name="condition">Condition that must be true</param>
            <param name="message">Message to be output by the exception</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.AssertWhenDebugging.IsTrue(System.Boolean)">
            <summary>
            Checks if a condition is true; if not, an exception  without error message is thrown.
            </summary>
            <param name="condition">Condition that must be true</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SparseGPOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.FunctionEvaluate(MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.YAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            EP message to 'y'.
            </summary>
            <param name="y">Incoming message from 'y'.</param>
            <param name="func">Incoming message from 'func'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Constant value for 'x'.</param>
            <returns>The outgoing EP message to the 'y' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'y'.
            The formula is <c>int f(y,x) q(x) dx</c> where <c>x = (func,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="func"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.FuncAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            EP message to 'func'.
            </summary>
            <param name="y">Incoming message from 'y'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="func">Incoming message from 'func'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Constant value for 'x'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'func'.
            The formula is <c>int f(func,x) q(x) dx</c> where <c>x = (y,x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="y"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="func"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SparseGPOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="y">Incoming message from 'y'.</param>
            <param name="func">Incoming message from 'func'.</param>
            <param name="x">Constant value for 'x'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (y,func)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductOp">
            <summary>
            Provides outgoing Gaussian messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/> and <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianProductOp.QuadratureNodeCount">
            <summary>
            The number of quadrature nodes used to compute the messages.
            Reduce this number to save time in exchange for less accuracy.
            Must be an odd number.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.GaussianProductOp.ForceProper">
            <summary>
            Force proper messages
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'product'.
            </summary>
            <param name="Product">Incoming message from 'product'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int f(product,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="Product">Incoming message from 'product'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="Product">Incoming message from 'product'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'product'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int f(product,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'product'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int f(product,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.ProductAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'product'.
            </summary>
            <param name="a">Constant message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int f(product,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.AAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductOp.BAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp">
            <summary>
            Provides Gaussian evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp">
            <summary>
            Provides Gaussian evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (ratio,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (ratio,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (ratio,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (ratio,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'product'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int log(f(product,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'product'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int log(f(product,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'product'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int log(f(product,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianProductVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp">
            <summary>
            Provides VMP Gaussian evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (ratio,a,b)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'ratio'.
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'ratio' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'ratio'.
            The formula is <c>int log(f(ratio,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'ratio'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'ratio' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'ratio'.
            The formula is <c>int log(f(ratio,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (ratio,b)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="ratio">Incoming message from 'ratio'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (ratio,b)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="ratio"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (ratio,b)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianRatioVmpOp.BAverageLogarithm">
            <summary>
            VMP message to 'b'.
            </summary>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (ratio,a)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsPositiveOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.IsPositive(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.IsPositiveOp.ForceProper">
            <summary>
            Force messages to be proper
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isPositive">Constant value for 'isPositive'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isPositive,x)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isPositive">Incoming message from 'isPositive'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isPositive,x)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isPositive">Incoming message from 'isPositive'.</param>
            <param name="x">Incoming message from 'x'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isPositive">Constant value for 'isPositive'.</param>
            <param name="x">Incoming message from 'x'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.IsPositiveAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'isPositive'.
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'isPositive' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'isPositive'.
            The formula is <c>int f(isPositive,x) q(x) dx</c> where <c>x = (x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isPositive">Incoming message from 'isPositive'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isPositive)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isPositive"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isPositive">Incoming message from 'isPositive'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Constant value for x.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isPositive)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isPositive">Constant value for 'isPositive'.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isPositive)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'x'.
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int log(f(x,x)) q(x) dx</c> where <c>x = (isPositive)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsPositiveOp.IsPositiveAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'isPositive'.
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'isPositive' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'isPositive'.
            The formula is <c>int log(f(isPositive,x)) q(x) dx</c> where <c>x = (x)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PositiveOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.Positive(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PositiveOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = ()</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PositiveOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (x)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.PositiveOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'x'.
            </summary>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int log(f(x,x)) q(x) dx</c> where <c>x = ()</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteFromLogProbs">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteFromLogProbs(System.Double[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ArrayHelper.MakeCopy``1(``0)">
            <summary>
            This was called 'CloneWithDeepCloneForArrays' - has been renamed as it is now called in inference code.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DirichletEstimator">
            <summary>
            Estimates a Dirichlet distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DirichletEstimator.N">
            <summary>
            Number of samples
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Sum">
            <summary>
            Sum
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Sum2">
            <summary>
            Sum of squares
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new Dirichlet estimator
            </summary>
            <param name="dimension">Dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">Where to put the estimated distribution</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Add(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Adds a Dirichlet item to the estimator
            </summary>
            <param name="item">A Dirichlet instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Add(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Adds a Vector sample to the estimator
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.SetTo(MicrosoftResearch.Infer.Distributions.DirichletEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DirichletEstimator.Dimension">
            <summary>
            Dimension of the Dirichlet
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatrixVectorProduct">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProduct.LogAverageFactor(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProduct.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProduct.ProductAverageConditional(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'product'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int f(product,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProduct.BAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixVectorProduct.BAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.IsBetween(System.Double,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.ForceProper">
            <summary>
            Static flag to force a proper distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogProbBetween(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            The logarithm of the probability that L &lt;= X &lt; U.
            </summary>
            <param name="X"></param>
            <param name="L">Can be negative infinity.</param>
            <param name="U">Can be positive infinity.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            EP message to 'isBetween'.
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'isBetween' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'isBetween'.
            The formula is <c>int f(isBetween,x) q(x) dx</c> where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isBetween,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isBetween,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogProbBetween(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            The logarithm of the probability that L &lt;= X &lt; U.
            </summary>
            <param name="X"></param>
            <param name="L">Can be uniform.  Can be negative infinity.</param>
            <param name="U">Can be uniform.  Can be positive infinity.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogAverageFactor(System.Boolean,System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (isBetween,x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for  'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for  'lowerBound'.</param>
            <param name="upperBound">Constant value for  'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for  'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for  'lowerBound'.</param>
            <param name="upperBound">Constant value for  'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LogEvidenceRatio(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="isBetween">Constant value for  'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from  'lowerBound'.</param>
            <param name="upperBound">Constant value for  'upperBound'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'isBetween'.
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'isBetween' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'isBetween'.
            The formula is <c>int f(isBetween,x) q(x) dx</c> where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'isBetween'.
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'isBetween' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'isBetween'.
            The formula is <c>int f(isBetween,x) q(x) dx</c> where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="upperBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'isBetween'.
            </summary>
            <param name="X">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'isBetween' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'isBetween'.
            The formula is <c>int f(isBetween,x) q(x) dx</c> where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="X"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'isBetween'.
            </summary>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Incoming message from 'upperBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'isBetween' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'isBetween'.
            The formula is <c>int f(isBetween,x) q(x) dx</c> where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="upperBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'isBetween'.
            </summary>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'isBetween' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'isBetween'.
            The formula is <c>int f(isBetween,x) q(x) dx</c> where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="upperBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'isBetween'.
            </summary>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'isBetween' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'isBetween'.
            The formula is <c>int f(isBetween,x) q(x) dx</c> where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (isBetween,x,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (isBetween,x,lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isBetween,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isBetween,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isBetween,lowerBound,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isBetween,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isBetween,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (isBetween,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (isBetween,x,lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (isBetween,x,lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (isBetween,x,lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (isBetween,x,lowerBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (isBetween,x,lowerBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (isBetween,x,lowerBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageConditional(System.Boolean,System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (isBetween,x,lowerBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (isBetween,x,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (isBetween,x,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (isBetween,x,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="isBetween"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (isBetween,x,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (isBetween,x,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (isBetween,x,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageConditional(System.Boolean,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="isBetween">Constant value for 'isBetween'.</param>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (isBetween,x,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.IsBetweenAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'isBetween'.
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing VMP message to the 'isBetween' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'isBetween'.
            The formula is <c>int log(f(isBetween,x)) q(x) dx</c> where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.XAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'x'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing VMP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int log(f(x,x)) q(x) dx</c> where <c>x = (isBetween,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.LowerBoundAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'lowerBound'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing VMP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int log(f(lowerBound,x)) q(x) dx</c> where <c>x = (isBetween,x,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleIsBetweenOp.UpperBoundAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'upperBound'.
            </summary>
            <param name="isBetween">Incoming message from 'isBetween'.</param>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing VMP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int log(f(upperBound,x)) q(x) dx</c> where <c>x = (isBetween,x,lowerBound)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleBetweenOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.Between(System.Double,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="x">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LogEvidenceRatio(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="x">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="x">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="x">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="x">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (x,lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int f(x,x) q(x) dx</c> where <c>x = (lowerBound,upperBound)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (x,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LowerBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (x,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LowerBoundAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Incoming message from 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (x,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LowerBoundAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'lowerBound'.
            </summary>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="upperBound">Constant value for 'upperBound'.</param>
            <returns>The outgoing EP message to the 'lowerBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int f(lowerBound,x) q(x) dx</c> where <c>x = (x,upperBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="lowerBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (x,lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="upperBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.UpperBoundAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Incoming message from 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (x,lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="upperBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.UpperBoundAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="X">Incoming message from 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (x,lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="upperBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.UpperBoundAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'upperBound'.
            </summary>
            <param name="X">Constant value for 'x'.</param>
            <param name="lowerBound">Constant value for 'lowerBound'.</param>
            <param name="upperBound">Incoming message from 'upperBound'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'upperBound' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int f(upperBound,x) q(x) dx</c> where <c>x = (x,lowerBound)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="upperBound"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.XAverageLogarithm">
            <summary>
            VMP message to 'x'. VMP does not support 
            </summary>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int log(f(x,x)) q(x) dx</c> where <c>x = (lowerBound,upperBound)</c>.
            </para><para>
            Variational Message Passing does not support ConstrainBetween with Gaussian distributions, since the factor is not conjugate to the Gaussian.
            This method will throw an exception.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.LowerBoundAverageLogarithm">
            <summary>
            VMP message to 'lowerBound'.
            </summary>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'lowerBound'.
            The formula is <c>int log(f(lowerBound,x)) q(x) dx</c> where <c>x = (x,upperBound)</c>.
            </para><para>
            Variational Message Passing does not support ConstrainBetween with Gaussian distributions, since the factor is not conjugate to the Gaussian.
            This method will throw an exception.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleBetweenOp.UpperBoundAverageLogarithm">
            <summary>
            VMP message to 'upperBound'.
            </summary>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'upperBound'.
            The formula is <c>int log(f(upperBound,x)) q(x) dx</c> where <c>x = (x,lowerBound)</c>.
            </para><para>
            Variational Message Passing does not support ConstrainBetween with Gaussian distributions, since the factor is not conjugate to the Gaussian.
            This method will throw an exception.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.LogAverageFactor(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.LogEvidenceRatio(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Constant value for 'probs'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (sample,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.SampleConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Gibbs message to 'sample'.
            </summary>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.SampleAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.SampleAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.ProbsConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Gibbs message to 'probs'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'probs' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.ProbsAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'probs'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'probs'.
            The formula is <c>int f(probs,x) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.ProbsAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'probs'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'probs'.
            The formula is <c>int log(f(probs,x)) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="probs">Incoming message from 'probs'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (probs)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probs"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="probs">Incoming message from 'probs'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (probs)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probs"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.ProbsAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            VMP message to 'probs'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'probs'.
            The formula is <c>int log(f(probs,x)) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.ProbsAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            EP message to 'probs'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probs">Incoming message from 'probs'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'probs'.
            The formula is <c>int f(probs,x) q(x) dx</c> where <c>x = (sample)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="probs"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Incoming message from 'probs'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDirichlet.AverageLogFactor(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,probs)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator">
            <summary>
            Estimates a Gaussian distribution from samples.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new VectorGaussian estimator of a given dimension
            </summary>
            <param name="dimension">The dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Adds a VectorGaussian distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Adds a sample item to the estimator
            </summary>
            <param name="sample">The sample value to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Add(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Add a sample item with a given weight to the estimator
            </summary>
            <param name="sample">The sample value to add</param>
            <param name="weight">The weight of the sample</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Computes the maximum-likelihood Gaussian from the samples.
            </summary>
            <param name="result">May be null.</param>
            <returns>If result is not null, modifies and returns result.  
            Otherwise returns a new Gaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.SetTo(MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.VectorGaussianEstimator.Dimension">
            <summary>
            Dimension of the VectorGaussian
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory">
            <summary>
            Kernel Factory - singleton class. It maintains a list
            of Kernel names and their types
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory.RegisterKernelFunction(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction)">
            <summary>
            Registers a kernel function. The factory is primed with stock
            kernel functions. This function allows clients to add in custom
            kernel functions
            </summary>
            <param name="ikf">Type instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory.CreateKernelFunction(System.String)">
            <summary>
            Creates a kernel function by specifying the kernel function name
            </summary>
            <param name="name">Name of the kernel function</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFactory.Instance">
            <summary>
            Kernel function factory singleton instance
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Gamma">
            <summary>
            A Gamma distribution on positive reals.
            </summary>
            <remarks><para>
            The distribution is 
            <c>p(x) = x^(a-1)*exp(-x*b)*b^a/Gamma(a)</c>.
            In this code, the <c>a</c> parameter is called the "Shape" and the <c>b</c> parameter
            is called the "Rate".  The distribution is sometimes also parameterized by (shape,scale)
            where scale = 1/rate.
            The mean of the distribution is <c>shape/rate</c> and the variance is 
            <c>shape/rate^2</c>.
            </para><para>
            Special cases:
            When the shape is 1 and rate is 0, the distribution is uniform.
            When the shape is infinity, the distribution is a point mass and the density is delta(x-Point)
            where the Point property gives the mean.
            When a &lt;= 0 or b &lt;= 0 the <c>b^a/Gamma(a)</c> term is dropped.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gamma.Rate">
            <summary>
            Rate parameter for the distribution
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Gamma.Shape">
            <summary>
            Shape parameter for the distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMean">
            <summary>
            Gets the expected value E(x) - calculated as shape/rate
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetVariance">
            <summary>
            Gets the variance - calculated as shape/rate^2
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean (shape/rate) and variance (shape/rate^2)
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromMeanAndVariance(System.Double,System.Double)">
            <summary>
            Creates a new Gamma distribution from mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
            <returns>A new Gamma instance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetShapeAndRate(System.Double,System.Double)">
            <summary>
            Sets the shape and rate (rate = 1/scale) parameters of the distribution.
            </summary>
            <param name="shape"></param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromShapeAndRate(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and rate parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="rate">rate = 1/scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetShapeAndScale(System.Double@,System.Double@)">
            <summary>
            Gets the shape and scale (1/rate)
            </summary>
            <param name="shape">Where to put the shape</param>
            <param name="scale">Where to put the scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetShapeAndScale(System.Double,System.Double)">
            <summary>
            Sets the shape and scale for this instance
            </summary>
            <param name="shape">Shape</param>
            <param name="scale">Scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromShapeAndScale(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given shape and scale parameters.
            </summary>
            <param name="shape">shape</param>
            <param name="scale">scale</param>
            <returns>A new Gamma distribution.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromMeanAndMeanLog(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution with the given mean and mean logarithm.
            </summary>
            <param name="mean">Desired expected value.</param>
            <param name="meanLog">Desired expected logarithm.</param>
            <returns>A new Gamma distribution.</returns>
            <remarks>This function is equivalent to maximum-likelihood estimation of a Gamma distribution
            from data given by sufficient statistics.
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization. The algorithm is a generalized Newton iteration, 
            described in "Estimating a Gamma distribution" by T. Minka, 2002.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetNatural(System.Double,System.Double)">
            <summary>
            Sets the natural parameters of the distribution.
            </summary>
            <param name="shapeMinus1">The shape parameter - 1.</param>
            <param name="rate">rate = 1/scale</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanLog">
            <summary>
            Computes E[log(x)]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanInverse">
            <summary>
            Computes E[1/x]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetMeanPower(System.Double)">
            <summary>
            Computes E[x^power]
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToPointMass">
            <summary>
            Sets this instance to a point mass. The location of the
            point mass is the existing Rate parameter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetDomainPrototype">
            <summary>
            Gets a domain prototype. The domain for the Gamma distribution is
            the positive reals, so a value of 0.0 is returned.
            </summary>
            <returns>0.0</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToUniform">
            <summary>
            Sets this Gamma instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogProb(System.Double,System.Double,System.Double)">
            <summary>
            Logarithm of the Gamma density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <param name="shape">Shape parameter</param>
            <param name="rate">Rate parameter</param>
            <returns>log(Gamma(x;shape,rate))</returns>
            <remarks>
            The distribution is <c>p(x) = x^(a-1)*exp(-x*b)*b^a/Gamma(a)</c>.
            When a &lt;= 0 or b &lt;= 0 the <c>b^a/Gamma(a)</c> term is dropped.
            Thus if shape = 1 and rate = 0 the density is 1.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogProb(System.Double)">
            <summary>
            Logarithm of this Gamma density function.
            </summary>
            <param name="x">Where to evaluate the density</param>
            <returns>log(Gamma(x;shape,rate))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogNormalizer">
            <summary>
            Gets log normalizer
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetAverageLog(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.IsProper">
            <summary>
            Asks whether this Gamma instance is proper or not. A Gamma distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.IsProper(System.Double,System.Double)">
            <summary>
            Asks whether a Gamma distribution is proper or not. A Gamma distribution
            is proper only if Shape > 0 and Rate > 0.
            </summary>
            <param name="shape">shape parameter for the Gamma</param>
            <param name="rate">rate parameter for the Gamma</param>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            The log of the integral of the product of this Gamma and that Gamma
            </summary>
            <param name="that">That Gamma</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Sample">
            <summary>
            Samples from this Gamma distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Sample(System.Double)">
            <summary>
            Samples from this Gamma distribution
            </summary>
            <param name="result">Ignored</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Sample(System.Double,System.Double)">
            <summary>
            Samples from a Gamma distribution with given shape and scale
            </summary>
            <param name="shape">shape parameter</param>
            <param name="scale">scale parameter</param>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetTo(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Sets this Gamma instance to have the parameter values of that Gamma instance
            </summary>
            <param name="that">That Gamma</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToProduct(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Sets the parameters to represent the product of two Gammas.
            </summary>
            <param name="a">The first Gamma</param>
            <param name="b">The second Gamma</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_Multiply(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Creates a new Gamma which the product of two other Gammas
            </summary>
            <param name="a">First Gamma</param>
            <param name="b">Second Gamma</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Sets the parameters to represent the ratio of two Gammas.
            </summary>
            <param name="numerator">The numerator Gamma</param>
            <param name="denominator">The denominator Gamma</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToRatioProper(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Sets the parameters to represent the ratio of two Gammas, forcing the Shape and Rate to be non-negative.
            </summary>
            <param name="numerator">The numerator Gamma</param>
            <param name="denominator">The denominator Gamma</param>
            <remarks>
            The result is always proper.  Multiplying the result and <paramref name="denominator"/> will always give the same mean
            as <paramref name="numerator"/>, but the variance may be smaller than <paramref name="numerator"/>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_Division(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Creates a new Gamma which the ratio of two other Gammas
            </summary>
            <param name="numerator">numerator Gamma</param>
            <param name="denominator">denominator Gamma</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToPower(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Gamma to some exponent.
            </summary>
            <param name="dist">The source Gamma</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Sets the mean and variance to match a Gaussian mixture.
            </summary>
            <param name="weight1">The first weight</param>
            <param name="dist1">The first Gamma</param>
            <param name="weight2">The second weight</param>
            <param name="dist2">The second Gamma</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Gamma
            and that Gamma
            </summary>
            <param name="thatd">That Gamma</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            Array of distribution requiring the distribution type to be a value type.
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.#ctor(System.Double,System.Double)">
            <summary>
            Creates a Gamma distribution with given shape and scale parameters (scale = 1/rate) 
            </summary>
            <param name="shape"></param>
            <param name="scale">scale = 1/rate</param>
            <remarks>
            The distribution is <c>p(x) = x^(shape-1)*exp(-x/scale)/(scale^shape * Gamma(shape))</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.FromNatural(System.Double,System.Double)">
            <summary>
            Constructs a Gamma distribution from its natural parameters.
            </summary>
            <param name="shapeMinus1">shape - 1</param>
            <param name="rate">rate = 1/scale</param>
            <returns>A new Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.#ctor(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Clone">
            <summary>
            Clones this Gamma. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Gamma type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.Uniform">
            <summary>
            Create a uniform Gamma distribution.
            </summary>
            <returns>A new uniform Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.PointMass(System.Double)">
            <summary>
            Creates a point mass Gamma distribution
            </summary>
            <param name="mean">The location of the point mass</param>
            <returns>A new point mass Gamma distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Gamma.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gamma.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Gamma.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'product'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int log(f(product,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'product'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int log(f(product,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianGammaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.MatrixMultiply(System.Double[0:,0:],System.Double[0:,0:])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (matrixMultiply,A,B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionArray2D{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.DistributionArray2D{MicrosoftResearch.Infer.Distributions.Gaussian},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'matrixMultiply'.
            </summary>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'matrixMultiply'.
            The formula is <c>int log(f(matrixMultiply,x)) q(x) dx</c> where <c>x = (A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithm(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'matrixMultiply'.
            </summary>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'matrixMultiply'.
            The formula is <c>int log(f(matrixMultiply,x)) q(x) dx</c> where <c>x = (A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'matrixMultiply'.
            </summary>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'matrixMultiply'.
            The formula is <c>int log(f(matrixMultiply,x)) q(x) dx</c> where <c>x = (A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'A'.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'A'.
            The formula is <c>int log(f(A,x)) q(x) dx</c> where <c>x = (matrixMultiply,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'A'.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'A'.
            The formula is <c>int log(f(A,x)) q(x) dx</c> where <c>x = (matrixMultiply,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'B'.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'B'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'B'.
            The formula is <c>int log(f(B,x)) q(x) dx</c> where <c>x = (matrixMultiply,A)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            VMP message to 'B'.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'B'.
            The formula is <c>int log(f(B,x)) q(x) dx</c> where <c>x = (matrixMultiply,A)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageLogarithm(System.Double[0:,0:])">
            <summary>
            VMP message to 'A'.
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'A'.
            The formula is <c>int log(f(A,x)) q(x) dx</c> where <c>x = (matrixMultiply,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageLogarithm(System.Double[0:,0:])">
            <summary>
            VMP message to 'B'.
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'B'.
            The formula is <c>int log(f(B,x)) q(x) dx</c> where <c>x = (matrixMultiply,A)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'matrixMultiply'.
            </summary>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'matrixMultiply'.
            The formula is <c>int f(matrixMultiply,x) q(x) dx</c> where <c>x = (A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'A'.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'A'.
            The formula is <c>int f(A,x) q(x) dx</c> where <c>x = (matrixMultiply,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'B'.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'B'.
            The formula is <c>int f(B,x) q(x) dx</c> where <c>x = (matrixMultiply,A)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (matrixMultiply,A,B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (matrixMultiply,A,B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (matrixMultiply,A,B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogAverageFactor(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (matrixMultiply,A,B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (matrixMultiply,A,B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.LogEvidenceRatio(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:])">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="A">Incoming message from 'A'.</param>
            <param name="B">Constant value for 'B'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageConditional(System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'matrixMultiply'.
            </summary>
            <param name="A">Constant value for 'A'.</param>
            <param name="B">Incoming message from 'B'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'matrixMultiply'.
            The formula is <c>int f(matrixMultiply,x) q(x) dx</c> where <c>x = (A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.MatrixMultiplyAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'matrixMultiply'.
            </summary>
            <param name="A">Incoming message from 'A'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'matrixMultiply'.
            The formula is <c>int f(matrixMultiply,x) q(x) dx</c> where <c>x = (A,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'A'.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'A'.
            The formula is <c>int f(A,x) q(x) dx</c> where <c>x = (matrixMultiply,B)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double},System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'B'.
            </summary>
            <param name="matrixMultiply">Incoming message from 'matrixMultiply'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'B'.
            The formula is <c>int f(B,x) q(x) dx</c> where <c>x = (matrixMultiply,A)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="matrixMultiply"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.AAverageConditional(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'A'.
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="B">Constant value for 'B'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'A'.
            The formula is <c>int f(A,x) q(x) dx</c> where <c>x = (matrixMultiply,B)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MatrixMultiplyOp.BAverageConditional(System.Double[0:,0:],System.Double[0:,0:],MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{MicrosoftResearch.Infer.Distributions.Gaussian,System.Double})">
            <summary>
            EP message to 'B'.
            </summary>
            <param name="matrixMultiply">Constant value for 'matrixMultiply'.</param>
            <param name="A">Constant value for 'A'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'B'.
            The formula is <c>int f(B,x) q(x) dx</c> where <c>x = (matrixMultiply,A)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromDiscrete(System.Int32,System.Double[])"/>, given random arguments to the function.
            </summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="index">Incoming message from 'index'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="index">Incoming message from 'index'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (sample,index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.SampleConditional(System.Int32,System.Double[])">
            <summary>
            Gibbs message to 'sample'.
            </summary>
            <param name="index">Constant value for 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing Gibbs message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.SampleAverageConditional(System.Int32,System.Double[])">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="index">Constant value for 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.SampleAverageLogarithm(System.Int32,System.Double[])">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="index">Constant value for 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.IndexConditional(System.Boolean,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Gibbs message to 'index'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'index' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.IndexAverageConditional(System.Boolean,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'index'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'index'.
            The formula is <c>int f(index,x) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.IndexAverageLogarithm(System.Boolean,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'index'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'index'.
            The formula is <c>int log(f(index,x)) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="index">Incoming message from 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="index">Incoming message from 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (index,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.IndexAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'index'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'index'.
            The formula is <c>int f(index,x) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.IndexAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[],MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'index'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'index'.
            The formula is <c>int log(f(index,x)) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.EvaluateLn(System.Boolean,System.Int32,System.Double[])">
            <summary>
            Evaluate the factor when inbox is all constants (for Gibbs sampling)
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="index">Constant value for 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromDiscrete.AverageValueLn(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,System.Double[])">
            <summary>
            
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="index">Incoming message from 'index'.</param>
            <param name="ProbTrue">Constant value for 'probTrue'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GammaEstimator">
            <summary>
            Estimates a Gamma distribution from samples.
            </summary>
            <remarks><code>
            The distribution is estimated via moment matching (not maximum-likelihood).
            In the one-dimensional case,
            E[x] = (a+1)/b
            var(x) = (a+1)/b^2
            b = E[x]/var(x)
            a = E[x]^2/var(x) - 1
            </code></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GammaEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.#ctor">
            <summary>
            Creates a new Gamma estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Retrieves the Gamma estimator
            </summary>
            <param name="result">Where to put the result</param>
            <returns>The resulting distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Add(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Adds a Gamma distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Add(System.Double)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="value">The sample to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.SetTo(MicrosoftResearch.Infer.Distributions.GammaEstimator)">
            <summary>
            Sets the state of this estimator from the supplied estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GammaEstimator.Clone">
            <summary>
            Returns a clone of this Gamma estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1">
            <summary>
            2-D Array of distribution objects that supports common distribution methods.
            </summary>
            <typeparam name="T">The distribution type.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Array2D`1">
            <summary>
            A two-dimensional array with value equality.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:MicrosoftResearch.Infer.Collections.IArray2D`1.Item(System.Int32,System.Int32)">
            <summary>
            Get or set an element of a two-dimensional array.
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array2D`1.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Array2D`1.Clone">
            <summary>
            Clone the array but not the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.SetToUniform">
            <summary>
            Sets all distributions in the array to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.IsUniform">
            <summary>
            Asks whether all distributions in a list are uniform
            </summary>
            <returns>True if all uniform. GFalse otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`1.MaxDiff(System.Object)">
            <summary>
            The maximum difference across all corresponding distributions in
            this distribution array and that distribution array
            </summary>
            <param name="that">That distribution array</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2">
            <summary>
            An extension of DistributionArray2D that implements IDistribution and Sampleable
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="DomainType"></typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.GetDomainPrototype">
            <summary>
            Get a domain prototype for this 2-D distribution array
            </summary>
            <returns>2-D array of prototype values from the distribution array's domain</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.GetLogProb(`1[0:,0:])">
            <summary>
            Gets the log density at a given 2-D array of domain values
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.Sample">
            <summary>
            Sample from the distribution array
            </summary>
            <returns>A 2D array of samples</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.Sample(`1[0:,0:])">
            <summary>
            Sample from the distribution array
            </summary>
            <param name="result">Where to put the results</param>
            <returns>A 2D array of samples</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.Point">
            <summary>
            Sets/gets the 2-D distribution array as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DistributionArray2D`2.IsPointMass">
            <summary>
            Returns true if this is 2-D distribution array is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2">
            <summary>
            2D Array of distributions requiring the distribution type to be a value type.
            </summary>
            <typeparam name="T">Distribution type.  Must be a value type all the way down, i.e. must not hold any references.</typeparam>
            <typeparam name="DomainType"></typeparam>
            <remarks>
            An extension of DistributionArray2D that requires T to be a value type.
            This class only exists for efficiency, to avoid unnecessary cloning.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(System.Int32,System.Int32,MicrosoftResearch.Infer.Utils.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension and initial values.
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="init">Function that maps an index to a value.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension, and a value
            </summary>
            <param name="value"></param>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.Clone">
            <summary>
            Clones the array but not the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.MaxDiff(System.Object)">
            <summary>
            The maximum difference across all corresponding distributions in
            this distribution array and that distribution array
            </summary>
            <param name="that">That distribution array</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            Sets this 2-D distribution array to the given one
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a product of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a ratio of the corrresponding distributions in two given
            distribution arrays
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},System.Double)">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a power of the corresponding element in a source distribution array
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a weighted sum of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For a DistributionArray, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionStructArray2D`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionStructArray2D{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For a DistributionArray, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2">
            <summary>
            2D array of distribution objects requiring the distribution type to be a distribution wrapper type
            </summary>
            <typeparam name="T">Distribution type.</typeparam>
            <typeparam name="DomainType"></typeparam>
            <remarks>
            An extension of DistributionArray that requires T to implement IsDistributionWrapper
            and other wrapper interfaces.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.#ctor(System.Int32,System.Int32,MicrosoftResearch.Infer.Utils.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension and initial values.
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="init">Function that maps an index to a value.</param>
            <returns></returns>
            <remarks>
            The references returned by <paramref name="init"/> are not copied.  They are placed directly into the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension, and a value
            </summary>
            <param name="value"></param>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.InitializeTo(`0[0:,0:])">
            <summary>
            Initialise the values in this 2-D distribution array to clones of the values in a given 2-D array of distributions
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length in each dimension</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetTo(`0[0:,0:])">
            <summary>
            Sets the values in this 2-D distribution array to clones of the given 2-D array of values
            Allocates new items only if they are null
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length in each dimension</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.InitializeTo(`0)">
            <summary>
            Initialises all the values in this 2-D distribution array to clones of the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetTo(`0)">
            <summary>
            Sets the values in this 2-D distribution array to clones of the given value
            Allocates new items only if they are null
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.CopyTo(`0[0:,0:])">
            <summary>
            Copies clones of values in this 2-Ddistribution array to the given array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetItemsOf(`0[0:,0:])">
            <summary>
            Sets items of this 2-D distribution array to clones of the values in the given array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetItemsOf(`0[],System.Int32)">
            <summary>
            Sets items of this 2-D distribution array to clones of the values in the given array,
            staring at a given index in this array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at in this array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.CopyTo(`0[],System.Int32)">
            <summary>
            Copies clones of values in this array to the given array
            staring at a given index in the given array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at in this array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.Clone">
            <summary>
            Clones the array and the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D{`0,`1})">
            <summary>
            Sets this 2-D distribution array to the given 2-D distribution array
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetTo(MicrosoftResearch.Infer.Distributions.IDistribution{`1[0:,0:]})">
            <summary>
            Sets this distribution array to the given distribution array
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetToProduct``2(MicrosoftResearch.Infer.Distributions.DistributionArray2D{``0,`1},MicrosoftResearch.Infer.Distributions.DistributionArray2D{``1,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a product of the corrresponding distributions in two given
            distribution arrays
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetToProduct(MicrosoftResearch.Infer.Distributions.IDistribution{`1[0:,0:]},MicrosoftResearch.Infer.Distributions.IDistribution{`1[0:,0:]})">
            <summary>
            Set this lazy distribution array to a product of two distributions over
            the same domain array type
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a product of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetToRatio``2(MicrosoftResearch.Infer.Distributions.DistributionArray2D{``0,`1},MicrosoftResearch.Infer.Distributions.DistributionArray2D{``1,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a ratio of the corrresponding distributions in two given
            distribution arrays
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetToRatio(MicrosoftResearch.Infer.Distributions.IDistribution{`1[0:,0:]},MicrosoftResearch.Infer.Distributions.IDistribution{`1[0:,0:]})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a ratio of the corrresponding distributions in two given
            distribution arrays
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a ratio of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.MultiplyIntoTarget``2(MicrosoftResearch.Infer.Distributions.DistributionArray2D{``0,`1},MicrosoftResearch.Infer.Distributions.DistributionArray2D{``1,`1})">
            <summary>
            This distribution array multiplies itself with the secondary distribution array and
            puts its results into the target
            </summary>
            <param name="target">The target of the multiplication</param>
            <param name="other">The secondary factor</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.MultiplyIntoTarget(MicrosoftResearch.Infer.Distributions.IDistribution{`1[0:,0:]},MicrosoftResearch.Infer.Distributions.IDistribution{`1[0:,0:]})">
            <summary>
            This distribution array multiplies itself with the secondary distribution array and
            puts its results into the target
            </summary>
            <param name="target">The target of the multiplication</param>
            <param name="other">The secondary factor</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetTarget(MicrosoftResearch.Infer.Distributions.IDistribution{`1[0:,0:]})">
            <summary>
            Sets the target distribution array with this distribution array
            </summary>
            <param name="target">The target array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D{`0,`1},System.Double)">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a power of the corresponding element in a source distribution array
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a weighted sum of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For a DistributionArray, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For a DistributionArray, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.PostUpdate">
            <summary>
            Allow distribution to update itself
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.PostUpdate``1(MicrosoftResearch.Infer.Distributions.DistributionArray2D{``0,`1})">
            <summary>
            Post update distribution from another distribution
            </summary>
            <typeparam name="T1"></typeparam>
            <param name="dist"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionWrapperArray2D`2.PostUpdateWith(MicrosoftResearch.Infer.Distributions.IDistribution{`1[0:,0:]})">
            <summary>
            Post update distribution from another distribution
            </summary>
            <param name="dist"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2">
            <summary>
            2D array of distribution objects requiring the distribution type to be a reference type
            </summary>
            <typeparam name="T">Distribution type.</typeparam>
            <typeparam name="DomainType"></typeparam>
            <remarks>
            An extension of DistributionArray2D that requires T to be a reference type.
            The SetTo and CopyTo methods are overriden to use cloning instead of assignment.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(System.Int32,System.Int32,`0[])">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension,
            and an array of values to reference
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="valuesRef">Array of values to reference</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(System.Int32,System.Int32,MicrosoftResearch.Infer.Utils.Func{System.Int32,System.Int32,`0})">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension and initial values.
            </summary>
            <param name="length0"></param>
            <param name="length1"></param>
            <param name="init">Function that maps an index to a value.</param>
            <returns></returns>
            <remarks>
            The references returned by <paramref name="init"/> are not copied.  They are placed directly into the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Constructs a new 2-D distribution array given the lengths of each dimension, and a value
            </summary>
            <param name="value"></param>
            <param name="length0"></param>
            <param name="length1"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(`0[0:,0:])">
            <summary>
            Constructs a new 2-D distribution array given a 2-D array of distributions
            </summary>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.#ctor(MicrosoftResearch.Infer.Collections.Array2D{`0})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.InitializeTo(`0[0:,0:])">
            <summary>
            Initialise the values in this 2-D distribution array to clones of the values in a given 2-D array of distributions
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length in each dimension</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetTo(`0[0:,0:])">
            <summary>
            Sets the values in this 2-D distribution array to clones of the given 2-D array of values
            Allocates new items only if they are null
            </summary>
            <param name="array"></param>
            <remarks>Given array and this array must be the same length in each dimension</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.InitializeTo(`0)">
            <summary>
            Initialises all the values in this 2-D distribution array to clones of the given value
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetTo(`0)">
            <summary>
            Sets the values in this 2-D distribution array to clones of the given value
            Allocates new items only if they are null
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.CopyTo(`0[0:,0:])">
            <summary>
            Copies clones of values in this 2-Ddistribution array to the given array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetItemsOf(`0[0:,0:])">
            <summary>
            Sets items of this 2-D distribution array to clones of the values in the given array
            </summary>
            <param name="array"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetItemsOf(`0[],System.Int32)">
            <summary>
            Sets items of this 2-D distribution array to clones of the values in the given array,
            staring at a given index in this array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at in this array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.CopyTo(`0[],System.Int32)">
            <summary>
            Copies clones of values in this array to the given array
            staring at a given index in the given array
            </summary>
            <param name="array"></param>
            <param name="arrayIndex">The index to start at in this array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.Clone">
            <summary>
            Clones the array and the items in the array.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetTo(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            Sets this 2-D distribution array to the given 2-D distribution array
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToProduct(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a product of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="a">The first distribution array</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToRatio(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a ratio of the corrresponding distributions in two given
            distribution arrays
            </summary>
            <param name="numerator">The numerator distribution array</param>
            <param name="denominator">The denominator distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToPower(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},System.Double)">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a power of the corresponding element in a source distribution array
            </summary>
            <param name="a">The source distribution array</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1},System.Double,MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            Sets the current instance to an array of distributions each element
            of which is a weighted sum of the corresponding distributions in two given
            distribution arrays
            </summary>
            <param name="weight1">The first weight</param>
            <param name="a">The first distribution array</param>
            <param name="weight2">The second weight</param>
            <param name="b">The second distribution array</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            The log-probability that two distributions would draw the same sample.
            </summary>
            <param name="that"></param>
            <returns><c>Math.Log(sum_x this.Evaluate(x)*that.Evaluate(x))</c></returns>
            <remarks>This can be considered a type of inner product between distributions.
            Another name might be "LogAverage" to go with "GetAverageLog".
            For a DistributionArray, this specializes to:
            <c>sum_i Math.Log(sum_x this[i].Evaluate(x)*that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetLogAverageOf(that[i])</c>
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DistributionRefArray2D`2.GetAverageLog(MicrosoftResearch.Infer.Distributions.DistributionRefArray2D{`0,`1})">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.
            For a DistributionArray, this specializes to:
            <c>sum_i sum_x this[i].Evaluate(x)*Math.Log(that[i].Evaluate(x))</c>
            = <c>sum_i this[i].GetAverageLog(that[i])</c>
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.NonSerializedPropertyAttribute">
            <summary>
            Attribute that can be attached to properties to signal
            that the property should not be serialised
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Quadrature">
            <summary>
            Quadrature nodes and weights
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.GaussianNodesAndWeights(System.Double,System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Quadrature nodes for Gaussian expectations.
            </summary>
            <param name="mean"></param>
            <param name="variance"></param>
            <param name="nodes">A list in which to store the nodes.</param>
            <param name="weights">A list in which to store the weights.</param>
            <remarks>
            The nodes and weights lists are modified to have the property that for any function f with a fast-converging Taylor series,
            <c>sum_i weights[i] f(nodes[i]) =approx int_{-inf..inf} f(x) N(x; m, v) dx</c>.
            If f is a polynomial of order 2*n-1, then the result is exact.
            For example, to compute E[x*x] where x ~ N(2,3):
            <code>
            Vector nodes = new Vector(2);
            Vector weights = new Vector(2);
            Quadrature.GaussianNodesAndWeights(2,3,nodes,weights);
            double result = (weights*nodes*nodes).Sum();
            </code>
            The result is mean^2 + variance = 7. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.GammaNodesAndWeights(System.Double,System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Quadrature nodes for Gamma expectations.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="nodes">A list in which to store the nodes.</param>
            <param name="weights">A list in which to store the weights.</param>
            <remarks>
            The nodes and weights lists are modified to have the property that for any function f with a fast-converging Taylor series,
            <c>sum_i weights[i] f(nodes[i]) =approx int_{0..inf} f(x) Ga(x; a, b) dx</c> where
            <c>Ga(x; a, b) = x^a*exp(-x*b)*b^(a+1)/Gamma(a+1)</c>.
            For example, to approximate E[x*x] where x ~ Ga(2,3):
            <code>
            Vector nodes = new Vector(3);
            Vector weights = new Vector(3);
            Quadrature.GammaNodesAndWeights(2,3,nodes,weights);
            double result = (weights*nodes*nodes).Sum();
            </code>
            The result is mean^2 + variance = ((a+1)^2 + (a+1))/b^2 = 4/3.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Quadrature.UniformNodesAndWeights(System.Double,System.Double,System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double})">
            <summary>
            Quadrature nodes for integrals on [low,high].
            </summary>
            <param name="low">Lower limit of integration.  Must be finite.</param>
            <param name="high">Upper limit of integration.  Must be finite.</param>
            <param name="nodes">A list in which to store the nodes.</param>
            <param name="weights">A list in which to store the weights.</param>
            <remarks>
            The nodes and weights lists are modified to have the property that for any function f with a fast-converging Taylor series,
            <c>sum_i weights[i] f(nodes[i]) =approx int_{low..high} f(x) dx</c>.
            If f is a polynomial of order 2*n-1, then the result is exact.
            For example, to compute <c>int_{0..1} x^3 dx</c>:
            <code>
            Vector nodes = new Vector(2);
            Vector weights = new Vector(2);
            Quadrature.UniformNodesAndWeights(0,1,nodes,weights);
            double result = (weights*nodes*nodes*nodes).Sum();
            </code>
            The result is 1/4.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Quadrature.LegendreNodesAndWeights">
            <summary>
            Legendre nodes and weights
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Quadrature.LaguerreNodesAndWeights">
            <summary>
            Laguerre nodes and weights
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.Quadrature.HermiteNodesAndWeights">
            <summary>
            Hermite nodes and weights
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SubarrayOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Subarray``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})"/>, given random arguments to the function.
            This factor gets a sub-array of different items from an array of items
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.LogEvidenceRatio``1(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ItemsAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'items'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'. Indices must all be different.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'items'.
            The formula is <c>int f(items,x) q(x) dx</c> where <c>x = (array,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'. Indices must all be different.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int f(array,x) q(x) dx</c> where <c>x = (items,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="items">Constant value for 'items'.</param>
            <param name="indices">Constant value for 'indices'. Indices must all be different.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int f(array,x) q(x) dx</c> where <c>x = (items,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (items,array,indices)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ItemsAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'items'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'. Indices must all be different.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'items'.
            The formula is <c>int log(f(items,x)) q(x) dx</c> where <c>x = (array,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'. Indices must all be different.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int log(f(array,x)) q(x) dx</c> where <c>x = (items,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SubarrayOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="items">Constant value for 'items'.</param>
            <param name="indices">Constant value for 'indices'. Indices must all be different.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int log(f(array,x)) q(x) dx</c> where <c>x = (items,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanNotOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Not(System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.NotAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'not'.
            </summary>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'not' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'not'.
            The formula is <c>int f(not,x) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="not">Incoming message from 'not'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (not)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="not"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageConditional(System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (not)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (not,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="not">Incoming message from 'not'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="not">Incoming message from 'not'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.NotAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'not'.
            </summary>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'not' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'not'.
            The formula is <c>int log(f(not,x)) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="not">Incoming message from 'not'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (not)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="not"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.BAverageLogarithm(System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="not">Constant value for 'not'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (not)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanNotOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (not,b)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MaxGaussianOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Max(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.MaxGaussianOp.ForceProper">
            <summary>
            Static flag to force a proper distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (max,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.MaxAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'max'.
            </summary>
            <param name="max">Incoming message from 'max'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'max' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'max'.
            The formula is <c>int f(max,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.MaxAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'max'.
            </summary>
            <param name="max">Incoming message from 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'max' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'max'.
            The formula is <c>int f(max,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.MaxAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'max'.
            </summary>
            <param name="max">Incoming message from 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'max' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'max'.
            The formula is <c>int f(max,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (max,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (max,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (max,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (max,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (max,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (max,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="max">Incoming message from 'max'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (max,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="max"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.MaxGaussianOp.BAverageConditional(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="max">Constant value for 'max'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (max,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel">
            <summary>
            Summation kernel. This provides the management layer for adding
            together different kernels
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction">
            <summary>
            Base class for all kernel functions
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction">
            <summary>
            Interface for all Kernel functions
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to each vector, and with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a single vector
            </summary>
            <param name="x">Vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the vector and with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.NameToIndex(System.String)">
            <summary>
            Gets the index of a specified hyperparameter name
            </summary>
            <param name="thetaName">The hyper-parameter name</param>
            <returns>The index</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.IndexToName(System.Int32)">
            <summary>
            Gets the name of a specified hyperparameter index
            </summary>
            <param name="thetaIndex">The hyper-parameter index</param>
            <returns>The name</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.Write(System.IO.StreamWriter)">
            <summary>
            Writes the function parameters out to a stream
            </summary>
            <param name="sw">String Writer</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.Read(System.IO.StreamReader)">
            <summary>
            Reads the function parameters in from a stream
            </summary>
            <param name="sr">String Reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index">Index of the log hyper-parameter</param>
            <returns>The log hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.Item(System.String)">
            <summary>
            Sets or gets a log hyper-parameter by name
            </summary>
            <param name="name">Name of the hyper-parameter</param>
            <returns>The log hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.ThetaCount">
            <summary>
            Hyper-parameter count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction.TypeVersion">
            <summary>
            The version for the derived class
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.thetaNames">
            <summary>
            Hyper-parameter names
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.thetaValues">
            <summary>
            Hyper-parameter values
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.thetaName2Index">
            <summary>
            Dictionary that allows look-up of index from hype-parameter name
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.#ctor(System.Collections.Generic.IList{System.String})">
            <summary>
            Protected constructor - derived classes pass down their list
            of hyper-parameter names
            </summary>
            <param name="hyperNames"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors and, optionally, returns derivatives
            with respect to each vector, and with respect to the parameters
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel for a single vector
            </summary>
            <param name="x">Vector</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector, and optionally, returns the derivatives
            with respect to the vector and with respect to the parameters
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.NameToIndex(System.String)">
            <summary>
            Gets the index of a specified hyperparameter name
            </summary>
            <param name="thetaName">The hyper-parameter name</param>
            <returns>The index</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.IndexToName(System.Int32)">
            <summary>
            Gets the index of a specified hyperparameter name
            </summary>
            <param name="thetaIndex">The hyper-parameter index</param>
            <returns>The index</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Write(System.IO.StreamWriter)">
            <summary>
            Writes the parameters out to a stream
            </summary>
            <param name="sw">Stream writer</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Read(System.IO.StreamReader)">
            <summary>
            Read the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Cholesky(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction,System.Collections.Generic.Dictionary{System.Int32,MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Cholesky of Kernel matrix
            </summary>
            <param name="kf">Kernel function</param>
            <param name="xData">Data with which to build the matrix</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.HyperNames">
            <summary>
            Sets the names of the hyper-parameters. Note that this destroys any values
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index">Index of the log hyper-parameter</param>
            <returns>The log hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.Item(System.String)">
            <summary>
            Sets or gets hyper-parameter by name. This indexer is not over-rideable
            </summary>
            <param name="name">Mame of the hyper-parameter</param>
            <returns>The hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.ThetaCount">
            <summary>
            Hyper-parameter count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.KernelFunction.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.kernels">
            <summary>
            List of kernels in the summation
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.indexInKernel">
            <summary>
            Index of a hyper-parameter within a participating kernel
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.indexOfKernel">
            <summary>
            Index of the kernel to which the hyper-parameter belongs
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.thetaCount">
            <summary>
            Parameter counts of the individual kernels
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.clearMaps">
            <summary>
            Clear maps between container and containees
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.initialise">
            <summary>
            (Re-)initialise a summation kernel. This clears
            all participating kernels
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.buildMaps">
            <summary>
            Helper method for building maps between container and containees
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.#ctor(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction)">
            <summary>
            Constructs summation kernel from an initial kernel function
            </summary>
            <param name="kernel"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.op_Addition(MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel,MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction)">
            <summary>
            Adds two kernel functions
            </summary>
            <param name="kernelA"></param>
            <param name="kernelB"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Write(System.IO.StreamWriter)">
            <summary>
            Writes the function parameters out to a stream
            </summary>
            <param name="sw">Stream writer</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Read(System.IO.StreamReader)">
            <summary>
            Reads the function parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Kernels">
            <summary>
            The participating kernels
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.ThetaCount">
            <summary>
            Number of theta parameters
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index">parameter index</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.Item(System.String)">
            <summary>
            Set or get hyper-parameter by name. This indexer is not over-rideable
            </summary>
            <param name="name">Mame of the hyper-parameter</param>
            <returns>The hyper-parameter value</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SummationKernel.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix">
            <summary>
            Upper triangular matrix class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.Matrix">
            <summary>
            Two-dimensional container of doubles.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.RowVector(System.Int32)">
            <summary>
            A row of the matrix.
            </summary>
            <param name="row">An integer in [0,Rows-1].</param>
            <returns>If colStride == 1, then a Vector object pointing at one row of this matrix.  Otherwise a copy of the row.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CreateSourceArray(System.Int32)">
            <summary>
            Creates a source array with a given number of records
            </summary>
            <param name="nRecords"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ReferenceClone">
            <summary>
            Creates a clone of this instance which references the source array
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.GetEnumerator">
            <summary>
            Gets a typed enumerator for this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator for this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Contains(System.Double)">
            <summary>
            Returns true if this matrix contains the given value
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CopyTo(System.Double[],System.Int32)">
            <summary>
            Copies the values in this matrix to an array starting at a given index in the destination array
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.IndexOf(System.Double)">
            <summary>
            Returns the first index of the given item if it exists in the matrix,
            otherwise returns -1
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct a zero matrix of the given dimensions.
            </summary>
            <param name="rows">Number of rows >= 0.</param>
            <param name="cols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(System.Double[0:,0:])">
            <summary>
            Construct a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.#ctor(System.Int32,System.Int32,System.Double[],System.Int32)">
            <summary>
            Construct a matrix by referencing an array.
            </summary>
            <param name="data">Storage for the matrix elements.</param>
            <param name="nRows">Number of rows.</param>
            <param name="nCols">Number of columns.</param>
            <param name="start">Index of first matrix element in the array.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Clone">
            <summary>
            Fully clones this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ToArray">
            <summary>
            Creates a 2-D arrays from this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CopyTo(System.Double[0:,0:])">
            <summary>
            Copies matrix values to a two-dimensional array.
            </summary>
            <param name="values">An array whose <c>GetLength(0) >= Rows</c> and <c>GetLength(1) >= Cols</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Copies values from another matrix.
            </summary>
            <param name="that">The second matrix, which must have the same size as this.</param>
            <returns>The mutated this matrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(System.Double)">
            <summary>
            Sets all elements to a given value.
            </summary>
            <param name="value">The new value.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.EqualsAll(System.Double)">
            <summary>
            Tests if all elements are equal to a given value.
            </summary>
            <param name="value">The value to test against.</param>
            <returns>True if all elements are equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(System.Double[])">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(System.Double[],System.Int32)">
            <summary>
            Copies values from an array.
            </summary>
            <param name="values">An array whose length is at least <c>this.Count + startIndex</c>.</param>
            <param name="startIndex">The index of the first value in <paramref name="values"/>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetTo(System.Double[0:,0:])">
            <summary>
            Copies values from a two-dimensional array.
            </summary>
            <param name="values">An array whose <c>GetLength(0) >= Rows</c> and <c>GetLength(1) >= Cols</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SymmetryError">
            <summary>
            max | this[i,j] - this[j,i] |
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToIdentity">
            <summary>
            Sets the matrix to the identity.
            </summary>
            <remarks>The matrix must be square.</remarks>
            <returns>The mutated matrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToIdentityScaledBy(System.Double)">
            <summary>
            Sets the matrix to the identity times a number.
            </summary>
            <param name="scale"></param>
            <returns>The mutated matrix.</returns>
            <remarks>The matrix must be square.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Identity(System.Int32)">
            <summary>
            Creates an identity matrix of the specified size
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.IdentityScaledBy(System.Int32,System.Double)">
            <summary>
            Creates an identity matrix of the specified size, scaled by the specified value
            </summary>
            <param name="dimension"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Transpose">
            <summary>
            Transposes the matrix.
            </summary>
            <returns>The transposed matrix.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToTranspose(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets the matrix to the transpose of another.
            </summary>
            <param name="that">The matrix to transpose.  Can be the same object as <c>this</c>.  <c>that.Count</c> must equal <c>this.Count</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the transposed matrix, and must already
            be the correct size.
            If <c>this</c> and <paramref name="that"/> are different objects but occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSubmatrix(MicrosoftResearch.Infer.Maths.Matrix,System.Int32,System.Int32)">
            <summary>
            Sets the matrix to a submatrix of another.
            </summary>
            <param name="that">Size must be at least <c>this.Rows+firstRow</c> by <c>this.Cols+firstColumn</c>.</param>
            <param name="thatRow">Index of the first row in <paramref name="that"/> to copy.</param>
            <param name="thatColumn">Index of the first column in <paramref name="that"/> to copy.</param>
            <returns><c>this</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetSubmatrix(System.Int32,System.Int32,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Set a submatrix of this matrix to match another matrix.
            </summary>
            <param name="thisRow">Index of the first row in <c>this</c> to copy to.</param>
            <param name="thisColumn">Index of the first column in <c>this</c> to copy to.</param>
            <param name="that">Size is at most <c>this.Rows-thisRow</c> by <c>this.Cols-thisColumn</c>.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetSubmatrix(System.Int32,System.Int32,MicrosoftResearch.Infer.Maths.Matrix,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Sets a submatrix of this matrix to match another matrix.
            </summary>
            <param name="thisRow">Index of the first row in <c>this</c> to copy to.</param>
            <param name="thisColumn">Index of the first column in <c>this</c> to copy to.</param>
            <param name="that">Size is at most <c>this.Rows-firstRow</c> by <c>this.Cols-firstColumn</c>.</param>
            <param name="thatRow">Index of the first row in <paramref name="that"/> to copy.</param>
            <param name="thatColumn">Index of the first column in <paramref name="that"/> to copy.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToDiagonal(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets this matrix to a diagonal matrix with diagonal values specified in the given vector
            </summary>
            <param name="diag"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Diagonal">
            <summary>
            Creates a vector from the diagonal values in the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.EnumerateDiagonal">
            <summary>
            Enumerator which yields the diagonal elements of the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.TraceOfProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The sum of diagonal elements of a matrix product.
            </summary>
            <param name="a">A matrix of size n by m.</param>
            <param name="b">A matrix of size m by n.</param>
            <returns><c>sum_i sum_k a[i,k]*b[k,i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.DiagonalOfProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The diagonal elements of a matrix product.
            </summary>
            <param name="a">A matrix of size n by m.</param>
            <param name="b">A matrix of size m by n.</param>
            <returns><c>v[i] = sum_k a[i,k]*b[k,i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Scale(System.Double)">
            <summary>
            Multiplies this matrix by a scalar.
            </summary>
            <param name="scale">The scalar.</param>
            <returns>this</returns>
            <remarks>this receives the product.
            This method is a synonym for SetToProduct(this, scale)
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ScaleRows(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiplies each row of this matrix by a different scalar.
            </summary>
            <param name="rowScale">The ith element scales row i.</param>
            <returns>this</returns>
            <remarks>this receives the product.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ScaleCols(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Multiplies each column of this matrix by a different scalar.
            </summary>
            <param name="colScale">The ith element scales column i.</param>
            <returns>this</returns>
            <remarks>this receives the product.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Median">
            <summary>
            Returns the median of the values in the matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToElementwiseProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The element-wise product of two matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = a[i,j] * b[i,j]</c>.  <c>this</c> receives the product, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToElementwiseRatio(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The element-wise ratio of two matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = a[i,j] / b[i,j]</c>.  <c>this</c> receives the ratio, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Gets a matrix times a scalar.
            </summary>
            <param name="m">A matrix, which must have the same size as <c>this</c>.  Can be the same object as <c>this</c>.</param>
            <param name="s">A scalar.</param>
            <remarks><c>this</c> receives the product, and must already be the correct size.  
            If <c>this</c> and <paramref name="m"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Multiplies every element of a matrix by a scalar.
            </summary>
            <param name="m">A matrix.</param>
            <param name="s">A scalar.</param>
            <returns>A new matrix with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToProduct(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Modify <c>this</c> to be the product of two matrices.
            </summary>
            <param name="A">First matrix.  Cannot be <c>this</c>.</param>
            <param name="B">Second matrix.  Cannot be <c>this</c>.</param>
            <remarks><paramref name="A"/> and <paramref name="B"/> must have compatible dimensions.
            <c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="A"/>/<paramref name="B"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToOuter(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Modify <c>this</c> to be the product of a matrix and its transpose (A*A').
            </summary>
            <param name="A">Matrix.  Cannot be <c>this</c>.</param>
            <remarks>
            <c>this</c> receives A*A' and must already be the correct size.
            If <c>this</c> and <paramref name="A"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
            <returns><c>this</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToOuterTranspose(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Modify <c>this</c> to be the product of the transpose of a matrix and the matrix (A'*A).
            </summary>
            <param name="A">Matrix.  Cannot be <c>this</c>.</param>
            <remarks>
            <c>this</c> receives A'*A and must already be the correct size.
            If <c>this</c> and <paramref name="A"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
            <returns><c>this</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Matrix product.
            </summary>
            <param name="A">First matrix.</param>
            <param name="B">Second matrix.</param>
            <returns>A new matrix with their product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Premultiplies a vector by a matrix (i.e. A*x).
            </summary>
            <param name="A">A matrix.</param>
            <param name="x">A vector.</param>
            <returns>A new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Multiply(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Postmultiplies a vector by a matrix (i.e. x*A).
            </summary>
            <param name="x">A vector.</param>
            <param name="A">A matrix.</param>
            <returns>The new vector with the product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToOuter(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the outer product of two vectors.
            </summary>
            <param name="a">First vector, of length <c>this.Rows</c>.</param>
            <param name="b">Second vector, of length <c>this.Cols</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> receives the product, and must already be the correct size.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSumWithOuter(MicrosoftResearch.Infer.Maths.Matrix,System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns a matrix plus the scaled outer product of two vectors.
            </summary>
            <param name="m">A matrix with the same size as <c>this</c>.  Can be <c>this</c>.</param>
            <param name="scale"></param>
            <param name="a">A vector with <c>a.Count == this.Rows</c></param>
            <param name="b">A vector with <c>b.Count == this.Cols</c></param>
            <returns>this[i,j] = m[i,j] + scale*a[i]*b[j]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.QuadraticForm(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the product x'Ax (where ' is transposition).
            </summary>
            <param name="x">A vector whose length equals Rows.</param>
            <remarks><c>this</c> must be a square matrix with Rows == x.Count.</remarks>
            <returns>The above product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.QuadraticForm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the product x'Ay (where ' is transposition).
            </summary>
            <param name="x">A vector whose length equals Rows.</param>
            <param name="y">A vector whose length equals Cows.</param>
            <returns>The above product.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSum(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this matrix to sum of two other matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = a[i,j] + b[i,j]</c>.  <c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToSum(System.Double,MicrosoftResearch.Infer.Maths.Matrix,System.Double,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            The sum of two matrices with scale factors.
            </summary>
            <param name="aScale">A scale factor.</param>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="bScale">A scale factor.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this[i,j] = aScale*a[i,j] + bScale*b[i,j]</c>.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Addition(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the sum of two matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>Their sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToDifference(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this matrix to the difference of two matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the difference, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.SetToDifference(MicrosoftResearch.Infer.Maths.Matrix,System.Double,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sets this matrix to a - bScale*b
            </summary>
            <param name="a"></param>
            <param name="bScale"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Subtraction(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the difference of two matrices. Assumes compatible matrices.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>Their difference.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_UnaryNegation(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the negation of a matrix.
            </summary>
            <param name="a">The matrix to negate.</param>
            <returns>The negation -a.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Equality(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Equality operator.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second Matrix.</param>
            <returns>True if the matrices have the same size and element values.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.op_Inequality(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Inequality operator.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>True if matrices are not equal.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Equals(System.Object)">
            <summary>
            Object comparator.
            </summary>
            <param name="obj">An object - must be an IntMatrix.</param>
            <returns>True if objects are equal.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.GetHashCode">
            <summary>
            Hash code generator.
            </summary>
            <returns>The hash code for the instance.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CheckCompatible(MicrosoftResearch.Infer.Maths.Matrix,System.String)">
            <summary>
            Checks that a given matrix is the same size as this matrix.
            Throws an exception if not with the given string
            </summary>
            <param name="that">The matrix to check</param>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.CheckSymmetry(System.String)">
            <summary>
            Checks this matrix for symmetry
            </summary>
            <param name="paramName"></param>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.MaxDiff(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Returns the maximum absolute difference between matrix elements.
            </summary>
            <param name="that">The second matrix.</param>
            <returns>max(abs(this[i,j] - that[i,j])).  
            Matching infinities or NaNs do not count.  
            If this and that are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of Equals, since Equals is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.MaxDiff(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Returns the maximum relative difference between matrix elements.
            </summary>
            <param name="that">The second matrix.</param>
            <param name="rel">An offset to avoid division by zero.</param>
            <returns>max(abs(this[i,j] - that[i,j])/(abs(this[i,j]) + rel)).  
            Matching infinities or NaNs do not count.  
            If this and that are not the same size, returns infinity.</returns>
            <remarks>This routine is typically used instead of Equals, since Equals is susceptible to roundoff errors.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.ToString">
            <summary>
            ToString override
            </summary>
            <returns></returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.IsPositiveDefinite">
            <summary>
            Tests for positive-definiteness.
            </summary>
            <returns>True if the matrix is positive-definite, i.e. all eigenvalues > 0.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Trace">
            <summary>
            The trace of a square matrix.
            </summary>
            <returns>The trace.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Determinant">
            <summary>
            Return the determinant of this matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Inverse">
            <summary>
            Return the inverse of this matrix - not implemented yet
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.Inner(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Inner product of matrices.
            </summary>
            <param name="A">A matrix with the same size as this.</param>
            <returns>sum_ij A[i,j]*this[i,j].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.PredivideBy(MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Gets the solution to AX=B, where A is an upper triangular matrix and
            B is a matrix of right-hand sides.	It is equivalent to the left-division X = A\B.
            </summary>
            <param name="A">An upper triangular matrix with A.Rows == this.Rows.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side matrix B, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.PredivideByTranspose(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to A'X=B, where A is a lower triangular matrix.
            Equivalent to the left-division X = A'\B.
            </summary>
            <param name="A">A lower triangular matrix with A.Cols == this.Rows.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side matrix B, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.Matrix.PredivideBy(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Gets the solution to AX=B, where A is a lower triangular matrix.
            Equivalent to the left-division X = A\B.
            </summary>
            <param name="A">A lower triangular matrix with A.Rows == this.Rows.</param>
            <returns><c>this</c></returns>
            <remarks>
            <c>this</c> is used as the right-hand side matrix B, and it also
            receives the solution.
            Throws an exception if <paramref name="A"/> is singular.</remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Item(System.Int32,System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Item(System.Int32)">
            <summary>Gets and sets an element.</summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Rows">
            <summary>
            The number of rows of the matrix.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Cols">
            <summary>
            The number of columns of the matrix.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.SourceArray">
            <summary>
            Gets/sets the matrix's source array
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Count">
            <summary>
            Number of elements in the matrix
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.Matrix.Start">
            <summary>
            Gets/sets the start index in the source array
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a zero matrix of the given dimensions.
            </summary>
            <param name="nRows">Number of rows >= 0.</param>
            <param name="nCols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.#ctor(System.Int32,System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a matrix by referencing an array.
            </summary>
            <param name="data">Storage for the matrix elements.</param>
            <param name="nRows">Number of rows.</param>
            <param name="nCols">Number of columns.</param>
            <param name="start">Index of first matrix element in the array.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Constructs a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.ReferenceClone">
            <summary>
            Creates a clone of this upper triangular matrix, copying the data by reference
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.Clone">
            <summary>
            Creates a full clone of this upper triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.CheckUpperTriangular">
            <summary>
            Check that this matrix is upper triangular
            </summary>
            Sets this positive-definite matrix to inverse of a given positive-definite matrix.
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.TransposeInPlace(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Transposes a given lower triangular matrix in place.
            </summary>
            <param name="L">Matrix to transpose.  Contents are corrupted on exit.</param>
            <returns>An upper triangular wrapper of L's source array.</returns>
            <remarks>L is no longer a valid lower triangular matrix.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.Transpose">
            <summary>
            Return the transpose of this upper triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.ProdDiag">
            <summary>
            Returns the product of diagonal elements.
            </summary>
            <returns><c>prod(diag(this))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.Determinant">
            <summary>
            Returns the determinant of this upper-triangular matrix.
            </summary>
            <returns>The determinant of this.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.TraceLn">
            <summary>
            Returns the sum of the logarithm of diagonal elements.
            </summary>
            <returns><c>sum(log(diag(this)))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.UpperTriangularMatrix.LogDeterminant">
            <summary>
            Returns the natural logarithm of the determinant of this upper-triangular matrix.
            </summary>
            <returns>The log-determinant of this.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Action">
            <summary>
            Action delegate - void with no arguments
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Action`2">
            <summary>
            Action delegate - void with two arguments
            </summary>
            <typeparam name="Type1">Type of argument 1</typeparam>
            <typeparam name="Type2">Type of argument 2</typeparam>
            <param name="arg1">Argument 1</param>
            <param name="arg2">Argument 2</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Action`3">
            <summary>
            Action delegate - void with three arguments
            </summary>
            <typeparam name="Type1">Type of argument 1</typeparam>
            <typeparam name="Type2">Type of argument 2</typeparam>
            <typeparam name="Type3">Type of argument 3</typeparam>
            <param name="arg1">Argument 1</param>
            <param name="arg2">Argument 2</param>
            <param name="arg3"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LogisticOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Maths.MMath.Logistic(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.LogisticOp.QuadratureNodeCount">
            <summary>
            The number of quadrature nodes used to compute the messages.
            Reduce this number to save time in exchange for less accuracy.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.ProposalDistribution(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Find the Laplace approximation for Beta(Logistic(x)) * Gaussian(x))
            </summary>
            <param name="beta">Beta distribution</param>
            <param name="gauss">Gaussian distribution</param>
            <returns>A proposal distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.LogisticAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'y'.
            </summary>
            <param name="logistic">Incoming message from 'logistic'.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'logistic' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'logistic'.
            The formula is <c>int I(y=f(x)) q(x) dx</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.XAverageConditional(System.Double)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="logistic">Constant value for 'logistic'.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int I(y=f(x) q(y) dy</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.LogisticOp.XAverageConditional(MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'x'.
            </summary>
            <param name="logistic">Incoming message from 'logistic'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="x">Incoming message from 'x'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'x' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'x'.
            The formula is <c>int I(y=f(x) q(y) dy</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logistic"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="x"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Gate">
            <summary>
            Factors for handling gates.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.Enter``1(System.Boolean[],``0)">
            <summary>
            Enter factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartial``1(System.Boolean[],``0,System.Int32[])">
            <summary>
            Enter partial factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="value"></param>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.EnterPartialTwo``1(System.Boolean,System.Boolean,``0,System.Int32[])">
            <summary>
            Enter partial factor with two cases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="case0"></param>
            <param name="case1"></param>
            <param name="value"></param>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.EnterOne``1(System.Boolean[],``0,System.Int32)">
            <summary>
            Enter one factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="value"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.Exit``1(System.Boolean[],``0[])">
            <summary>
            Exit factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitTwo``1(System.Boolean,System.Boolean,``0[])">
            <summary>
            Exit factor with two cases
            </summary>
            <typeparam name="T"></typeparam>
            <param name="case0"></param>
            <param name="case1"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitRandom``1(System.Boolean[],``0[])">
            <summary>
            Exit random factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitRandomTwo``1(System.Boolean,System.Boolean,``0[])">
            <summary>
            Exit random factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="cases"></param>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.ExitingVariable``1(``0,``0)">
            <summary>
            Exiting variable factor
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Def"></param>
            <param name="Marginal"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.Cases(System.Boolean)">
            <summary>
            Boolean cases factor
            </summary>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.CasesBool(System.Boolean,System.Boolean@,System.Boolean@)">
            <summary>
            Boolean cases factor expanded into elements
            </summary>
            <param name="b"></param>
            <param name="case0">case 0 (true)</param>
            <param name="case1">case 1 (false)</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Gate.CasesInt(System.Int32,System.Int32)">
            <summary>
            Integer cases factor
            </summary>
            <param name="i">index</param>
            <param name="count">number of cases</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.CasesOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.Cases(System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.CasesAverageConditional``1(MicrosoftResearch.Infer.Distributions.Bernoulli,``0)">
            <summary>
            EP message to 'cases'.
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int f(cases,x) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.BAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="cases">Incoming message from 'cases'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="cases">Incoming message from 'cases'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.CasesAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Bernoulli,``0)">
            <summary>
            VMP message to 'cases'.
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.BAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli})">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="cases">Incoming message from 'cases'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesOp.AverageLogFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="cases">Incoming message from 'cases'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (cases,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case0AverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'case0' (true).
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int f(cases,x) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case1AverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'case1' (false).
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int f(cases,x) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="case0">Incoming message from 'case0'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="case1">Incoming message from 'case1'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="case0">Incoming message from 'case0'.</param>
            <param name="case1">Incoming message from 'case1'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case0AverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'case0'.
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.Case1AverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'case1'.
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'cases'.
            The formula is <c>int log(f(cases,x)) q(x) dx</c> where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="cases">Incoming message from 'cases'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (cases)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.CasesBoolOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="cases">Incoming message from 'cases'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (cases,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IntCasesOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Gate.CasesInt(System.Int32,System.Int32)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.CasesAverageConditional``1(MicrosoftResearch.Infer.Distributions.Discrete,``0)">
            <summary>
            EP message to 'casesInt'.
            </summary>
            <param name="i">Incoming message from 'i'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'casesInt'.
            The formula is <c>int f(casesInt,x) q(x) dx</c> where <c>x = (i)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.IAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'i'.
            </summary>
            <param name="cases">Incoming message from 'casesInt'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'i'.
            The formula is <c>int f(i,x) q(x) dx</c> where <c>x = (casesInt)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.LogEvidenceRatio(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="cases">Incoming message from 'casesInt'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.CasesAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Discrete,``0)">
            <summary>
            VMP message to 'casesInt'.
            </summary>
            <param name="i">Incoming message from 'i'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'casesInt'.
            The formula is <c>int log(f(casesInt,x)) q(x) dx</c> where <c>x = (i)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.IAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'i'.
            </summary>
            <param name="cases">Incoming message from 'casesInt'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'i'.
            The formula is <c>int log(f(i,x)) q(x) dx</c> where <c>x = (casesInt)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IntCasesOp.AverageLogFactor(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Bernoulli},MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="cases">Incoming message from 'casesInt'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="i">Incoming message from 'i'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (casesInt,i)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="cases"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteFromDiscrete">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(System.Int32,MicrosoftResearch.Infer.Maths.Matrix)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscrete.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="selector">Incoming message from 'selector'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,selector,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscrete.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="selector">Incoming message from 'selector'.</param>
            <param name="probs">Constant value for 'probs'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscrete.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="selector">Incoming message from 'selector'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (selector,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteFromDiscrete.SelectorAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'selector'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probs">Constant value for 'probs'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'selector'.
            The formula is <c>int f(selector,x) q(x) dx</c> where <c>x = (sample,probs)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.MethodFullNameToString(System.Reflection.MethodInfo)">
            <summary>
            Get string of the form "typeName.methodName".
            </summary>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.StringUtil.MethodSignatureToString(System.Reflection.MethodInfo)">
            <summary>
            Get a short string describing the signature of a method.
            </summary>
            <param name="method"></param>
            <returns>A string of the form "methodName&lt;types>(parameters)"</returns>
            <remarks>From the C# 3.0 specification sec 1.6.6: 
            The signature of a method consists of the name of the method, 
            the number of type parameters and the number, modifiers, and types of its parameters. 
            The signature of a method does not include the return type.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.PointMass`1">
            <summary>
            A point mass, which is the 'distribution' you get for an observed variable.
            All the probability mass is at the point given by observed value.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.#ctor(`0)">
            <summary>
            Creates a point mass at the specified location.
            </summary>
            <param name="point">The location of the point mass.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.GetDomainPrototype">
            <summary>
            Returns the domain prototype, which is just the point location.
            </summary>
            <returns>The point location</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.Clone">
            <summary>
            Creates a copy of the point mass.
            </summary>
            <returns>The new PointMass object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.MaxDiff(System.Object)">
            <summary>
            Always throws an exception, since MaxDiff is not defined for a PointMass.
            </summary>
            <param name="that"></param>
            <returns>Never returns</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.SetToUniform">
            <summary>
            Always throws an exception, since a PointMass cannot be set to uniform.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.IsUniform">
            <summary>
            Always returns false
            </summary>
            <returns>false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.PointMass`1.GetLogProb(`0)">
            <summary>
            Returns 0 if the value is at the point mass and negative infinity elsewhere.
            </summary>
            <param name="value">The value at which to compute the log probability.</param>
            <returns>0 or negative infinity</returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.PointMass`1.Point">
            <summary>
            The location of the point mass.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.PointMass`1.IsPointMass">
            <summary>
            Always returns true.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator">
            <summary>
            Class for accumulating weighted noisy matrix observations,
            and computing sample count, mean matrix, and covariance matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Mean">
            <summary>
            Mean matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Variance">
            <summary>
            Covariance matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Count">
            <summary>
            Count
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.diff">
            <summary>
            Temporary workspace
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Adds an observation
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Matrix,System.Double)">
            <summary>
            Adds a weighted observation
            </summary>
            <param name="x"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="weight"></param>
            <remarks>The contents of noiseVariance are modified.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an accumulator for matrix observations
            </summary>
            <param name="rows"></param>
            <param name="cols"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.SetTo(MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Rows">
            <summary>
            The number of rows in the matrix
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MatrixMeanVarianceAccumulator.Cols">
            <summary>
            The number of columns in the matrix
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GaussianEstimator">
            <summary>
            Estimates a Gaussian distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.GaussianEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.#ctor">
            <summary>
            Creates a new Gaussian estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Adds a Gaussian distribution item to the estimator
            </summary>
            <param name="distribution">The distribution instance to add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(System.Double)">
            <summary>
            Adds an sample to the estimator
            </summary>
            <param name="sample">The sample add</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Add(System.Double,System.Double)">
            <summary>
            Adds a sample with a given weight to the estimator
            </summary>
            <param name="sample">The sample to add</param>
            <param name="weight">The weight of the sample</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Computes the maximum-likelihood Gaussian from the samples.
            </summary>
            <param name="result">May be null.</param>
            <returns>If result is not null, modifies and returns result.  
            Otherwise returns a new Gaussian object.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.SetTo(MicrosoftResearch.Infer.Distributions.GaussianEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GaussianEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Bernoulli">
            <summary>
            Represents a distribution on a binary variable.
            </summary>
            <remarks>
            The most common way to use the distribution is to get and set its ProbTrue property.
            
            The distribution is represented by a single number, the log odds: log p(x=true)/p(x=false).
            If this is 0, then the distribution is uniform.
            If this is infinity, then the distribution is a point mass on x=true.
            If this is -infinity, then the distribution is a point mass on x=false.
            In terms of the log odds, p(x=true) = 1/(1+exp(-logOdds)).
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Bernoulli.LogOdds">
            <summary>
            Log odds parameter
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetProbTrue">
            <summary>
            Gets the probability of the binary variable being true
            </summary>
            <returns>p(x=true)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetProbTrue(System.Double)">
            <summary>
            Sets the probability of the binary variable being true
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetProbFalse">
            <summary>
            Gets the probability of the binary variable being false
            </summary>
            <returns>p(x=false)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetProbFalse(System.Double)">
            <summary>
            Sets the probability of the binary variable being false
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogProbTrue">
            <summary>
            Gets the log probability of the binary variable being true
            </summary>
            <returns>log(p(x=true))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetLogProbTrue(System.Double)">
            <summary>
            Sets the log probability of the binary variable being true
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogProbFalse">
            <summary>
            Gets the log probability of the binary variable being false
            </summary>
            <returns>log(p(x=false))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetLogProbFalse(System.Double)">
            <summary>
            Sets the log probability of the binary variable being false
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToUniform">
            <summary>
            Sets the distribution to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.IsUniform">
            <summary>
            Whether the distribution is uniform
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogProb(System.Boolean)">
            <summary>
            Evaluates the logarithm of the density function
            </summary>
            <param name="x">true or false</param>
            <returns>Log of the probability density for the given event</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogNormalizer">
            <summary>
            Gets the log normalizer of the distribution
            </summary>
            <returns>This equals -log(1-p)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Log of the probability that a draw from this distribution
            is equal to a draw from that distribution.
            </summary>
            <param name="that">That distribution</param>
            <returns>The resulting log probability</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetAverageLog(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Sample">
            <summary>
            Samples from a Bernoulli distribution
            </summary>
            <returns>The sample value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Sample(System.Double)">
            <summary>
            Samples from a Bernoulli distribution with a specified p(true)
            </summary>
            <param name="probTrue">p(true)</param>
            <returns>The sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetMean">
            <summary>
            Gets the mean of this Bernoulli distribution
            </summary>
            <returns>The mean</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetMean(System.Double)">
            <summary>
            Sets the mean of this Bernoulli distribution
            </summary>
            <param name="mean">The mean</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetVariance">
            <summary>
            Gets the variance of this Bernoulli distribution
            </summary>
            <returns>The variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.#ctor(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.#ctor(System.Double)">
            <summary>
            Creates a Bernoulli distribution with given probability of being true.
            </summary>
            <param name="probTrue">p(true)</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Uniform">
            <summary>
            Instantiates a uniform Bernoulli distribution
            </summary>
            <returns>A new uniform Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.PointMass(System.Boolean)">
            <summary>
            Instantiates a point-mass Bernoulli distribution
            </summary>
            <param name="value">true of false</param>
            <returns>A new point-mass Bernoulli distribution at the specified value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.FromLogOdds(System.Double)">
            <summary>
            Instantiates a Bernoulli distribution from a log-odds value
            </summary>
            <param name="logOdds">The log-odds</param>
            <returns>A new Bernoulli distribution at the specified log-odds</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToProduct(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Sets this instance to a product of two Bernoulli distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_Multiply(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates a Bernoulli distribution which is the product of two Bernoulli distribution
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Sets this instance to a ratio of two Bernoulli distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_Division(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates a Bernoulli distribution which is the ratio of two Bernoulli distribution
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToPower(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Sets this instance to the power of a Bernoulli distributions
            </summary>
            <param name="dist">The distribution to raise to a power</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double)">
            <summary>
            Raises this distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.op_LogicalNot(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates the complementary distribution
            </summary>
            <param name="dist">The original distribution</param>
            <returns>The complementary distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Creates a Bernoulli distribution which is a weighted sum of two Bernoulli distribution
            </summary>
            <param name="weight1">The weight for the first distribution</param>
            <param name="dist1">The first distribution</param>
            <param name="weight2">The weight for the second distribution</param>
            <param name="dist2">The second distribution</param>
            <returns>The resulting Bernoulli distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.SetTo(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Sets this instance to have the parameters of another instance
            </summary>
            <param name="that">The source Bernoulli distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Clone">
            <summary>
            Clones this Bernoulli. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Bernoulli type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetDomainPrototype">
            <summary>
            The domain of Bernoulli is bool. This returns a 'false' as a prototype value for the domain
            </summary>
            <returns>false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.MaxDiff(System.Object)">
            <summary>
            The maximum 'difference' between this instance and that instance.
            This returns the absolute difference between the Log-odds
            </summary>
            <param name="thatd">That distribution</param>
            <returns>The resulting maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>true if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.ToString">
            <summary>
            Override of ToString method
            </summary>
            <returns>String representation of instance - shows distribution type and p(true)</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.LogitProbEqual(System.Double,System.Double)">
            <summary>
            Computes the logical AreEqual function in the log-odds domain.
            </summary>
            <param name="x">The log-odds of variable A, which can be any real number from -Inf to Inf.</param>
            <param name="y">The log-odds of variable B, which can be any real number from -Inf to Inf.</param>
            <returns>The log-odds that A == B.</returns>
            <remarks>The logical LogitProbEqual function is defined as p1 EQ p2 = p1*p2 + (1-p1)*(1-p2).
            It is the same as the complement of XOR: !(p1 XOR p2).
            In the log-odds domain, this is:
            LogOdds(Logistic(x) EQ Logistic(y)) = log (1+exp(-x-y))/(exp(-x)+exp(-y)).
            To compute this reliably when x>0 and y>0, factor out min(x,y).
            For other cases, use the identity AE(-x,-y) = AE(x,y) and AE(-x,y) = AE(x,-y) = -AE(x,y).
            Note the result is 0 if x=0 or y=0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.LogProbEqual(System.Double,System.Double)">
            <summary>
            Computes the log-probability that A==B where p(A)=Logistic(x), p(B)=Logistic(y).
            </summary>
            <param name="x">The log-odds of variable A, which can be any real number from -Inf to Inf.</param>
            <param name="y">The log-odds of variable B, which can be any real number from -Inf to Inf.</param>
            <returns>The log-probability that A==B.</returns>
            <remarks>
            The result is Math.Log(0.5) if x=0 or y=0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Or(System.Double,System.Double)">
            <summary>
            Computes the logical OR function in the log-odds domain.
            </summary>
            <param name="x">Any real number, including infinity.</param>
            <param name="y">Any real number, including infinity.</param>
            <returns>The log odds of (p1 OR p2), where p1 = Logistic(x) and p2 = Logistic(y)</returns>
            <remarks>The logical OR function is defined as p1 OR p2 = 1 - (1-p1)*(1-p2) = p1 + p2 - p1*p2.
            In the log-odds domain, this is:
            LogOdds(Logistic(x) OR Logistic(y)) = log(exp(x) + exp(y) + exp(x+y)).  
            To compute this reliably, factor out max(x,y,x+y).
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Bernoulli.Gate(System.Double,System.Double)">
            <summary>
            Computes the Bernoulli gating function in the log-odds domain.
            </summary>
            <param name="x"></param>
            <param name="gate"></param>
            <returns></returns>
            <remarks>
            The Bernoulli gating function is x if gate = -infinity and 0 if gate = infinity.
            It is one of the messages sent by a logical OR factor.
            In the log-odds domain, this is:
            log (1 + exp(-gate))/(1 + exp(-gate-x))
            </remarks>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Bernoulli.IsPointMass">
            <summary>
            Whether the distribution is a point mass (true with probability 1 or false
            with probability 1)
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Bernoulli.Point">
            <summary>
            Gets/sets the distribution as a point
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.SetToProduct``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Set result to the product of all items in list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="result"></param>
            <param name="list">Must have Count > 1.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.CreateArray``1(System.Int32[])">
            <summary>
            Like <see cref="M:System.Array.CreateInstance(System.Type,System.Int32[])"/> but 5x faster.
            </summary>
            <typeparam name="T">Array element type.</typeparam>
            <param name="lengths"></param>
            <returns>A new array.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.ChangeElementType(System.Type,System.Type)">
            <summary>
            Change the element type of an array type to another type.
            </summary>
            <param name="arrayType">A scalar, array, multidimensional array, or nested array type.</param>
            <param name="newElementType">Any type.</param>
            <returns>A type with the same structure as <paramref name="arrayType"/> but whose element type is <paramref name="newElementType"/></returns>
            <remarks>
            For example, <c>ChangeElementType(typeof(int[,][]), typeof(double))</c> returns
            <c>typeof(double[,][])</c>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Util.GetArrayDepth(System.Type,System.Type)">
            <summary>
            The number of indexing brackets needed to turn arrayType into innermostElementType.
            </summary>
            <param name="arrayType"></param>
            <param name="innermostElementType"></param>
            <returns>An integer between 0 and the full depth of arrayType.</returns>
            <remarks>
            For example, if <paramref name="arrayType"/> is <c>int[][]</c> and <paramref name="innermostElementType"/> is <c>int</c>, the
            result is 2. If <paramref name="arrayType"/> is <c>int[][]</c> and <paramref name="innermostElementType"/> is <c>int[]</c>, the
            result is 1. If <paramref name="arrayType"/> is <c>int[][]</c> and <paramref name="innermostElementType"/> is <c>int[][]</c>, the
            result is 0. 
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.MakeValidVariableName(System.String)">
            <summary>
            Converts a variable name to a valid variable name by changing all invalid characters with an underscore.
            </summary>
            <param name="name">Variable name</param>
            <returns>A valid MATLAB variable name.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Matlab5DataElement(System.String,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Generates a Matlab V5 compatible data element.
            </summary>
            <param name="name">Name of the matrix.</param>
            <param name="matrix">A matrix.</param>
            <returns>The byte array that can be used as a Matlab V5 data element (in a stream).</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabWriter.Matlab5Header(System.String)">
            <summary>
            Generates a Matlab V5 compatible header byte array.
            </summary>
            <param name="comments">The comments that will go into the header of the Matlab file.</param>
            <returns>The header as a byte array.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.MatlabReader">
            <summary>
            Reads the contents of a MAT file.
            </summary>
            <remarks>
            The MAT file format is defined in <a href="http://www.mathworks.com/access/helpdesk/help/pdf_doc/matlab/matfile_format.pdf">The MAT file format</a>.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.MatlabReader.RemoveRfc1950Header(System.Byte[])">
            <summary>
            Removes the header defined by <a href="http://www.ietf.org/rfc/rfc1950.txt">RFC 1950</a>
            </summary>
            <param name="bytes"></param>
            <returns>A smaller array of bytes</returns>
            <remarks>
            The header to remove is 2 or 6 bytes at the start, and 4 bytes at the end.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MatrixSingularException">
            <summary>
            Exception thrown when a singular matrix is encountered.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MatrixSingularException.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Construct the exception.
            </summary>
            <param name="m">The offending matrix.</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.MatrixSingularException.Offender">
            <summary>Gets the singular matrix that caused the exception.</summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaProductOp">
            <summary>
            Provides outgoing Gamma messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/> and <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.ProductAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            EP message to 'product'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int f(product,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.ProductAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            EP message to 'product'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int f(product,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.ProductAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'product'.
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int f(product,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductOp.AAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp">
            <summary>
            Provides Gamma evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (product,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Incoming message from 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="product">Constant value for 'product'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaProductVmpOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'product'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int log(f(product,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'product'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int log(f(product,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'product'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int log(f(product,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaProductVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp">
            <summary>
            Provides Gamma evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (ratio,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (ratio,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (ratio,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogAverageFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (ratio,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Incoming message from 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioEvidenceOp.LogEvidenceRatio(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp">
            <summary>
            Provides VMP Gamma evidence messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'ratio'.
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'ratio' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'ratio'.
            The formula is <c>int log(f(ratio,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.RatioAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'ratio'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'ratio' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'ratio'.
            The formula is <c>int log(f(ratio,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (ratio,b)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="ratio">Incoming message from 'ratio'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (ratio,b)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="ratio"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="ratio">Constant value for 'ratio'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (ratio,b)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaRatioVmpOp.BAverageLogarithm">
            <summary>
            VMP message to 'b'.
            </summary>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (ratio,a)</c>.
            </para><para>
            Variational Message Passing does not support a Ratio factor with fixed output or random denominator
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IntegerPlusOp">
            <summary>
            Provides outgoing messages for f(sum,a,b) = 1(sum == a+b)
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanOrOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Or(System.Boolean,System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'or'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'or' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'or'.
            The formula is <c>int f(or,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'or'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'or' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'or'.
            The formula is <c>int f(or,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'or'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'or' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'or'.
            The formula is <c>int f(or,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (or,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (or,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (or,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (or,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (or,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (or,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (or,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (or,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Incoming message from 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (or,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Incoming message from 'or'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (or,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Incoming message from 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (or,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (or,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (or,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Incoming message from 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Incoming message from 'or'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Incoming message from 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (or,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.LogEvidenceRatio(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (or,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'or'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'or' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'or'.
            The formula is <c>int log(f(or,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'or'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'or' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'or'.
            The formula is <c>int log(f(or,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.OrAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'or'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'or' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'or'.
            The formula is <c>int log(f(or,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (or,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (or,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (or,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.AAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (or,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (or,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="or">Incoming message from 'or'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (or,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="or"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (or,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanOrOp.BAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="or">Constant value for 'or'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (or,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DirichletOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.DirichletFromMeanAndTotalCount(MicrosoftResearch.Infer.Maths.Vector,System.Double)"/>, given random arguments to the function.
            Note: stochastic totalCount with deterministic mean is not yet implemented
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Constant value for 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (prob,mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="prob">Incoming messge from 'prob'.</param>
            <param name="mean">Incoming messge from 'mean'.</param>
            <param name="totalCount">Incoming messge from 'totalCount'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (prob,mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="prob">Incoming messge from 'prob'.</param>
            <param name="mean">Incoming messge from 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (prob,mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Incoming messge from 'mean'.</param>
            <param name="totalCount">Incoming messge from 'totalCount'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (prob,mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.AverageLogFactor(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="mean">Incoming messge from 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (prob,mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'Prob'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'Prob' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.ProbAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            VMP message to 'Prob'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <returns>The outgoing VMP message to the 'Prob' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (mean,totalCount)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Nonconjugate VMP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'Mean' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Nonconjugate VMP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="prob">Constant value for  'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Nonconjugate VMP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Constant value for 'totalCount'.</param>
            <param name="prob">Incoming message from 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'mean' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Nonconjugate VMP message to 'mean'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <param name="prob">Incoming message from 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'Mean' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Nonconjugate VMP message to 'totalCount'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <param name="prob">Constant value for 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'totalCount' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountAverageLogarithm(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Nonconjugate VMP message to 'totalCount'.
            </summary>
            <param name="mean">Incoming message from 'mean'.</param>
            <param name="totalCount">Incoming message from 'totalCount'.</param>
            <param name="prob">Incoming message from 'prob'.</param>
            <param name="result">Previous message sent to 'mean'.</param>
            <returns>The outgoing VMP message to the 'totalCount' argument.</returns>
            <remarks><para>
            The outgoing message here would not be Dirichlet distributed, so we use Nonconjugate VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.MeanMessageExpectations(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>
            Perform the quadrature required for the Nonconjugate VMP message to 'mean'
            </summary>
            <param name="meanQ">Incoming message from 'mean'.</param>
            <param name="totalCountQ">Incoming message from 'totalCount'.</param>
            <param name="EELogGamma">Array to be filled with E[LogGamma(s*m_k)].</param>
            <param name="EELogMLogGamma">Array to be filled with E[Log(m_k)*LogGamma(s*m_k)].</param>
            <param name="EELogOneMinusMLogGamma">Array to be filled with E[Log(1-m_k)*LogGamma(s*m_k)].</param>
            <remarks><para>
            All three arrays are calculated simultaneously for efficiency. The quadrature over 
            'totalCount' (which is Gamma-distributed) is peformed by a change of variable x=log(s)
            followed by Gauss-Hermite quadrature. The quadrature over m is performed using 
            Gauss-Legendre. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.TotalCountMessageExpectations(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.Gamma,System.Double[]@,System.Double[]@,System.Double[]@)">
            <summary>
            Perform the quadrature required for the Nonconjugate VMP message to 'totalCount'
            </summary>
            <param name="meanQPseudoCount">Incoming message from 'mean'.</param>
            <param name="totalCountQ">Incoming message from 'totalCount'.</param>
            <param name="EELogGamma">Array to be filled with E[LogGamma(s*m_k)].</param>
            <param name="EELogSLogGamma">Array to be filled with E[Log(s)*LogGamma(s*m_k)].</param>
            <param name="EEMSDigamma">Array to be filled with E[s*m_k*Digamma(s*m_k)].</param>
            <remarks><para>
            All three arrays are calculated simultaneously for efficiency. The quadrature over 
            'totalCount' (which is Gamma-distributed) is peformed by a change of variable x=log(s)
            followed by Gauss-Hermite quadrature. The quadrature over m is performed using 
            Gauss-Legendre. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DirichletOp.EvidenceMessageExpectations(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Perform the quadrature required for the VMP evidence message
            </summary>
            <param name="meanQ">Incoming message from m='mean'.</param>
            <param name="totalCountQ">Incoming message from s='totalCount'.</param>
            <returns>Vector of E[ LogGamma(s*m_k)].</returns>
            <remarks><para>
            The quadrature over 'totalCount' (which is Gamma-distributed) is 
            peformed by a change of variable x=log(s) followed by Gauss-Hermite 
            quadrature. The quadrature over m is performed using Gauss-Legendre. 
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean.SampleConditional(System.Boolean,System.Double,System.Double)">
            <summary>
            Gibbs message to 'sample'.
            </summary>
            <param name="choice">Constant value for 'choice'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing Gibbs message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'sample' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean.SampleAverageConditional(System.Boolean,System.Double,System.Double)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="choice">Constant value for 'choice'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (choice,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean.SampleAverageLogarithm(System.Boolean,System.Double,System.Double)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="choice">Constant value for 'choice'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (choice,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean.ChoiceConditional(System.Boolean,System.Double,System.Double)">
            <summary>
            Gibbs message to 'choice'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing Gibbs message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the factor viewed as a function of 'choice' conditioned on the given values.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean.ChoiceAverageConditional(System.Boolean,System.Double,System.Double)">
            <summary>
            EP message to 'choice'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing EP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int f(choice,x) q(x) dx</c> where <c>x = (sample,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean.ChoiceAverageLogarithm(System.Boolean,System.Double,System.Double)">
            <summary>
            VMP message to 'choice'.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing VMP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int log(f(choice,x)) q(x) dx</c> where <c>x = (sample,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="choice">Incoming message from 'choice'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (choice,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean.ChoiceAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>
            EP message to 'choice'.
            </summary>
            <param name="sample">Incoming message from 'sample'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing EP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int f(choice,x) q(x) dx</c> where <c>x = (sample,probTrue0,probTrue1)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sample"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="choice">Incoming message from 'choice'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (choice,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBoolean.ChoiceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double,System.Double)">
            <summary>
            VMP message to 'choice'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue0">Constant value for 'probTrue0'.</param>
            <param name="probTrue1">Constant value for 'probTrue1'.</param>
            <returns>The outgoing VMP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int log(f(choice,x)) q(x) dx</c> where <c>x = (sample,probTrue0,probTrue1)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double[])"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.SampleAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="choice">Incoming message from 'choice'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (choice,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.SampleAverageConditional(System.Boolean,System.Double[])">
            <summary>
            EP message to 'sample'.
            </summary>
            <param name="choice">Constant value for 'choice'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int f(sample,x) q(x) dx</c> where <c>x = (choice,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.ChoiceAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>
            EP message to 'choice'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing EP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int f(choice,x) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.SampleAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>
            VMP message to 'sample'.
            </summary>
            <param name="choice">Incoming message from 'choice'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing VMP message to the 'sample' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sample'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (choice,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromBooleanArray.ChoiceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Double[])">
            <summary>
            VMP message to 'choice'.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="probTrue">Constant value for 'probTrue'.</param>
            <returns>The outgoing VMP message to the 'choice' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'choice'.
            The formula is <c>int log(f(choice,x)) q(x) dx</c> where <c>x = (sample,probTrue)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise">
            <summary>
            White noise kernel function. This can be added to other kernels using the
            SummationKernel class to provide measurement noise
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.#ctor">
            <summary>
            Default constructor for white noise kernel function
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.#ctor(System.Double)">
            <summary>
            Construct white noise kernel function from log noise standard deviation
            </summary>
            <param name="logNoiseSD">Log noise standard deviation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.WhiteNoise.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Rank1Pot">
            <summary>
            Rank 1 potential for a sparse GP. This low rank parameterisation
            is used for messages flowing from a SparseGP evaluation factor to
            a function variable.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.Xi">
            <summary>
            Xi
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.Yi">
            <summary>
            Yi
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.LambdaInv">
            <summary>
            Lambda inverse
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.kBx">
            <summary>
            Field for K_B_x property
            </summary>
            
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.K_B_x(MicrosoftResearch.Infer.Distributions.SparseGPBase)">
            <summary>
            K(B,x). This is a calculated Vector maintained
            by the class
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.pvec">
            <summary>
            Field for P property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.P(MicrosoftResearch.Infer.Distributions.SparseGPBase)">
            <summary>
            p = Inv(K(B,B)) * K(B,x). This is a calculated Vector maintained
            by the class
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Rank1Pot.kxx">
            <summary>
            Field for K_x_x property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.K_x_x(MicrosoftResearch.Infer.Distributions.SparseGPBase)">
            <summary>
            k(x)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Rank1Pot.FlagRecalculate">
            <summary>
            Flag recalculation of the calculated properties
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGP">
            <summary>
            SparseGP class. Supports both full rank (alpha/beta) GP, and
            can include any number of low rank (y,lambda) potentials.
            When used for message passing, the full rank parameterisation
            is needed for passing messages to the GP function evaluation factor,
            whereas the low rank parameterisation is used for the return message
            to the function variable
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGPBase">
            <summary>
            Base class for sparseGP messages. This references the fixed
            parameters, and wraps some common kernel evaluation tasks
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IGaussianProcess">
            <summary>
            Basic GP interface
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Mean0">
            <summary>
            Mean function for the GP
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.IGaussianProcess.Kernel">
            <summary>
            Kernel function for the GP
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPBase.fixedParams">
            <summary>
            Field for FixedParameters property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPBase.FlagRecalculate">
            <summary>
            This function may be implemented by derived classes.
            It's purpose is to signal that the fixed parameters
            of the sparse GP have changed. This function is called
            by this class if the kernel or fixed parameters are replaced.
            External functions should explicitly call this if changes
            to kernel or fixed parameters are done in place.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPBase.KernelOf_X_B(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the kernel of a point against the basis
            </summary>
            <param name="x">Input</param>
            <returns>Kernel values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPBase.KernelOf_X_B(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Evaluates the kernel of a list of points against the basis
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Kernel values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPBase.KernelOf_X_X(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Evaluates the kernel of a list of points against itself
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Kernel values</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPBase.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPBase.#ctor(MicrosoftResearch.Infer.Distributions.SparseGPFixed)">
            <summary>
            Constructs a sparse GP, given basis etc
            </summary>
            <param name="spgf"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPBase.GetDomainPrototype">
            <summary>
            Domain prototype returns a function instance
            which evaluates any input to 0
            </summary>
            <returns>Zero constant function</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPBase.Clone">
            <summary>
            Clone. Note that the fixed parameters are just referenced
            </summary>
            <returns>The cloned object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPBase.SetTo(MicrosoftResearch.Infer.Distributions.SparseGPBase)">
            <summary>
            References the fixed parameters
            </summary>
            <param name="that">The sparse GP to copy</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPBase.FixedParameters">
            <summary>
            Sets and gets the fixed sparse parameters - parameters
            which are not changed by inference
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPBase.Mean0">
            <summary>
            Prior mean
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPBase.Kernel">
            <summary>
            Kernel function
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IGPPrediction">
            <summary>
            Interface for doing prediction with a GP
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGPPrediction.Mean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive Mean at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive mean</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGPPrediction.Mean(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive Mean at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive mean vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGPPrediction.Variance(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive Variance at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGPPrediction.Covariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive Variance at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive covariance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGPPrediction.Prediction(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive distribution at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IGPPrediction.Prediction(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive distribution at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.alpha">
            <summary>
            Field for Alpha property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.beta">
            <summary>
            Field for Beta property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.rank1Pots">
            <summary>
            
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.meanB">
            <summary>
            Field for Mean_B property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.varBB">
            <summary>
            Field for Var_B_B property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGP.pointFunc">
            <summary>
            Use for setting point distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.FlagRecalculate">
            <summary>
            Function to signal recalculation of calculated parameters.
            This is called automatically if the fixed parameter
            class is swapped out, or if the kernel is changed, or
            if parameters are changed. It should also be called
            by any external program modifies the kernel or other
            fixed parameters in place
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Mean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive Mean
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Mean(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive Mean at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive mean vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Variance(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive Variance at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Covariance(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive Variance at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive covariance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Prediction(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Predictive distribution at a given point
            </summary>
            <param name="X">Input</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Prediction(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Predictive distribution at a given list of points
            </summary>
            <param name="XList">List of inputs</param>
            <returns>Predictive distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor">
            <summary>
            Default constructor - gives uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGPFixed)">
            <summary>
            Constructs sparse GP, given basis etc
            </summary>
            <param name="spgf">The fixed parameters</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGPFixed,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Constructs a sparse GP, given basis, alpha, and beta
            </summary>
            <param name="sgpf">The fixed parameters</param>
            <param name="alpha">Alpha</param>
            <param name="beta">Beta</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.#ctor(MicrosoftResearch.Infer.Distributions.SparseGPFixed,MicrosoftResearch.Infer.Distributions.Rank1Pot)">
            <summary>
            Constructs sparse GP, given basis etc, and a rank 1 potential
            </summary>
            <param name="sgpf">The fixed parameters</param>
            <param name="r1p">Rank potential</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Clone">
            <summary>
            Clone. Note that the fixed parameters and the rank1 list
            are just referenced
            </summary>
            <returns>The cloned object</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetTo(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Sets one sparse GP to another. Everything is copied
            except the FixedParameters and the lsit of rank 1 potentials
            which are referenced.
            </summary>
            <param name="that">The sparse GP to copy</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToRank1(MicrosoftResearch.Infer.Distributions.Rank1Pot)">
            <summary>
            Sets the Sparse GP to a rank 1 potential
            Full rank parameters are set to uniform
            </summary>
            <param name="r1p"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToRank1List(System.Collections.Generic.List{MicrosoftResearch.Infer.Distributions.Rank1Pot})">
            <summary>
            Sets to a list of low ranks
            </summary>
            <param name="r1pList">The list</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.ClearRank1List">
            <summary>
            Clears the list of rank 1 potentials
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.AppendRank1(MicrosoftResearch.Infer.Distributions.Rank1Pot)">
            <summary>
            Appends a reference to a rank1 potential to the Sparse GP
            </summary>
            <param name="r1p"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.AppendRank1List(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Rank1Pot})">
            <summary>
            Append a list of rank1 potentials to the Sparse GP
            </summary>
            <param name="r1pList"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToAndClearRank1s(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Set a sparse GP from another, and clear the list of rank 1 potentials
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.setToProductOrRatio(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.Rank1Pot,System.Boolean)">
            <summary>
            Local static method to mutiply in a rank1 potential to a sparseGP
            </summary>
            <param name="sgp">The Sparse GP - this is changed on return</param>
            <param name="r1p">The rank 1 potential</param>
            <param name="divide">Ratio rather than product</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToProductOrRatio(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP,System.Boolean)">
            <summary>
            Helper function to multiply to sparse GPs
            </summary>
            <param name="a">First Sparse GP</param>
            <param name="b">Second Sparse GP</param>
            <param name="divide">Ratio rather than product</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToProduct(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Sets this instance to the product of two sparse GPs. Currently
            only supports the case where a is a sparseGP, and b is a low
            rank sparse GP
            </summary>
            <param name="a">Sparse GP</param>
            <param name="b">Low Rank Sparse GP</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.op_Multiply(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Creates a new SparseGP which the product of two other SparseGPs
            </summary>
            <param name="a">First SparseGP</param>
            <param name="b">Second SparseGP</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToRatio(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Sets this instance to the ratio of two sparse GPs. Currently
            only supports the case where a is a sparseGP, and b is a low
            rank sparse GP
            </summary>
            <param name="numerator">Sparse GP</param>
            <param name="denominator">Low Rank Sparse GP</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.op_Division(MicrosoftResearch.Infer.Distributions.SparseGP,MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Creates a new SparseGP which the ratio of two other SparseGPs
            </summary>
            <param name="numerator">numerator SparseGP</param>
            <param name="denominator">denominator SparseGP</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetLogProb(MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            Gets the log density for a given value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.EvaluateMean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the mean function of the GP
            </summary>
            <param name="X">Input variable</param>
            <returns>Evaulated function value</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToUniform">
            <summary>
            Sets to uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.IsUniform">
            <summary>
            Asks the distribution whether it is uniform
            </summary>
            <returns>True or false</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.MaxDiff(System.Object)">
            <summary>
            Max difference between two sparse GPs - used for
            convergence testing
            </summary>
            <param name="thatd">That sparse GP which will be compared to this sparse GP</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetMean">
            <summary>
            Gets the mean function for the Sparse GP
            </summary>
            <returns>The mean function</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Sample">
            <summary>
            Samples from the Sparse Gaussian distribution
            This is only implemented for a 1-dimensional input space,
            and returns a simple linear spline function 
            </summary>
            <returns>Sample function</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.Sample(MicrosoftResearch.Infer.Distributions.IFunction)">
            <summary>
            Samples from the Sparse Gaussian distribution
            This is only implemented for a 1-dimensional input space,
            and returns a simple linear spline function. result is ignored
            <param name="result">This argument is ignored</param>
            </summary>
            <returns>Sample function</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.SetToPower(MicrosoftResearch.Infer.Distributions.SparseGP,System.Double)">
            <summary>
            Not implemented
            </summary>
            <param name="value"></param>
            <param name="exponent"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGP.GetAverageLog(MicrosoftResearch.Infer.Distributions.SparseGP)">
            <summary>
            Not implemented
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Alpha">
            <summary>
            Alpha - along with beta, this encodes the posterior means
            and covariances of the Sparse GP
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Beta">
            <summary>
            Beta - along with alpha, this encodes the posterior means
            and covariances of the Sparse GP
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Rank1Potentials">
            <summary>
            The list of rank 1 potentials
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Mean_B">
            <summary>
            m(B). This is a calculated Vector maintained
            by the class
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Var_B_B">
            <summary>
            var(B, B). This is a calculated matrix maintained
            by the class
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.Point">
            <summary>
            Sets or Gets a point. If not a point function,
            the get returns the mean function of the sparse GP
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGP.IsPointMass">
            <summary>
            Asks the distribution whether it is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.LinearSpline">
            <summary>
            Very simple 1-D linear spline class which implements IFunction.
            Assumes knots at regular positions - given by a start and increment.
            The vector of knot values defines how many knots.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.IFunction">
            <summary>
            Function interface - used for distributions over a function domain
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.IFunction.Evaluate(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluate a function
            </summary>
            <param name="X">Input</param>
            <returns>Output</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.LinearSpline.Evaluate(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluate the linear spline at a given point. Only
            1-D input spaces are supported - so only the first element
            of X is considered
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.LinearSpline.KnotStart">
            <summary>
            Knot start position
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.LinearSpline.KnotIncrem">
            <summary>
            Knot position increment
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.LinearSpline.YPoints">
            <summary>
            Y points
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ConstantFunction">
            <summary>
            Class implementing the constant function. Used as a domain prototype
            for distributions over functions
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.Evaluate(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluate the function
            </summary>
            <param name="X"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.#ctor">
            <summary>
            Constructor for constant function - default value is 0.0
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConstantFunction.#ctor(System.Double)">
            <summary>
            Constructor for constant function
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConstantFunction.ConstantValue">
            <summary>
            The constant value of the function
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.IIterativeProcess">
            <summary>
            Interface for running a compiled inference algorithm
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.IIterativeProcess.Reset">
            <summary>
            Reset the algorithm - this includes any allocation of memory
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.IIterativeProcess.Initialise">
            <summary>
            Initialise the inference
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.IIterativeProcess.Update">
            <summary>
            Perform a single pass of the schedule
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel">
            <summary>
            Linear kernel
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.SetupParams(System.Double[])">
            <summary>
            Sets up names and values of parameters
            </summary>
            <param name="logVariances">Log of the weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.#ctor(System.Double[])">
            <summary>
            Constructs a linear kernel from vector of log variances
            </summary>
            <param name="logVariances">Log of the weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.InitialiseFromData(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Initialises the parameters from data. The variance is
            set as the square of the inverse of the 'length' of the
            input feature. Note that the variance we are trying to set
            up here corresponds to the variance of the weight parameters
            in a linear model, not to the variance of the input feature.
            </summary>
            <param name="X">X data - initialises variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.Read(System.IO.StreamReader)">
            <summary>
            Reads the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.LinearKernel.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.ARD">
            <summary>
            Automatic Relevance Determination Kernel
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.SetupParams(System.Double[],System.Double)">
            <summary>
            Sets up names and values of parameters
            </summary>
            <param name="logLengths">Log of the lengths</param>
            <param name="logSigVar">Log of the signal variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.#ctor(System.Double[],System.Double)">
            <summary>
            Constructs an ARD kernel from a vector of log lengths, and a log signal variance
            </summary>
            <param name="logLengths"></param>
            <param name="logSigVar"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.InitialiseFromData(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector},MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Initialises the parameters from data
            </summary>
            <param name="X">X data - initialises lengths</param>
            <param name="y">y data - initialises signal standard deviation</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.ARD.Read(System.IO.StreamReader)">
            <summary>
            Reads the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.ARD.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.ARD.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.BetaEstimator">
            <summary>
            Estimates a Beta distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BetaEstimator.mva">
            <summary>
            Where to accumulate means and variances
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.#ctor">
            <summary>
            Creates a new Beta estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">Where to put the estimated distribution</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Add(MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Adds a Beta item to the estimator
            </summary>
            <param name="distribution">A Beta instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Add(System.Double)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.SetTo(MicrosoftResearch.Infer.Distributions.BetaEstimator)">
            <summary>
            Sets the state of this estimator from the supplied estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BetaEstimator.Clone">
            <summary>
            Returns a copy of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Undirected">
            <summary>
            Provides useful factors for undirected models.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.Potts(System.Int32,System.Int32,System.Double)">
            <summary>
            Implements an integer Potts potential which has the value of 0 if a=b and -exp(logCost) otherwise.
            </summary>
            <remarks>
            See http://en.wikipedia.org/wiki/Potts_model
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <param name="cost"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.Potts(System.Boolean,System.Boolean,System.Double)">
            <summary>
            Implements an boolean Potts potential which has the value of 0 if a=b and -exp(logCost) otherwise.
            </summary>
            <remarks>
            See http://en.wikipedia.org/wiki/Potts_model
            </remarks>
            <param name="a"></param>
            <param name="b"></param>
            <param name="cost"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.Linear(System.Int32,System.Int32,System.Double)">
            <summary>
            Implements a linear difference potential which has the value of exp( -|a-b|* logUnitCost ).
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="cost"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Undirected.TruncLinear(System.Int32,System.Int32,System.Double,System.Double)">
            <summary>
            Implements a truncated linear difference potential which has the value of  exp( - min( |a-b|* logUnitCost, maxCost) ).
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="cost"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PottsIntOp">
            <summary>
            Implementation of integer Potts factor
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.PottsBoolOp">
            <summary>
            Implementation of boolean Potts factor
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.LinearOp">
            <summary>
            Implementation of the linear difference factor
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.TruncLinearOp">
            <summary>
            Implementation of the linear difference factor
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoublePlusOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sum,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value from 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sum,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value from 'a'.</param>
            <param name="b">Constant value from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sum,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="Sum">Constant value from 'sum'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sum,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="Sum">Constant value from 'sum'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sum,a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'sum'.
            </summary>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sum' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sum'.
            The formula is <c>int f(sum,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'sum'.
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sum' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sum'.
            The formula is <c>int f(sum,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'sum'.
            </summary>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'sum' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sum'.
            The formula is <c>int f(sum,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.SumAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'sum'.
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'sum' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sum'.
            The formula is <c>int f(sum,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (sum,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="Sum">Constant value for 'sum'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (sum,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (sum,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.AAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="Sum">Constant value for 'sum'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (sum,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (sum,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="Sum">Constant value for 'sum'.</param>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (sum,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (sum,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusOp.BAverageConditional(System.Double,System.Double)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="Sum">Constant value for 'sum'.</param>
            <param name="a">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (sum,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoublePlusEvidence">
            <summary>
            Evidence methods for Factor.Plus only
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleMinusEvidence">
            <summary>
            Evidence methods for Factor.Difference only
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp">
            <summary>
            These operator methods are only valid for plus, not minus.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sum,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'sum'.
            </summary>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sum' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sum'.
            The formula is <c>int log(f(sum,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'sum'.
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sum' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sum'.
            The formula is <c>int log(f(sum,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'sum'.
            </summary>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'sum' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sum'.
            The formula is <c>int log(f(sum,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.SumAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'sum'.
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'sum' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sum'.
            The formula is <c>int log(f(sum,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (sum,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Sum">Constant value for 'sum'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (sum,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (sum,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Sum">Constant value for 'sum'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (sum,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (sum,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Sum">Constant value for 'sum'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (sum,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (sum,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoublePlusVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Sum">Constant value for 'sum'.</param>
            <param name="a">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (sum,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp">
            <summary>
            Provides outgoing VMP messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (difference,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'difference'.
            </summary>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'difference' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'difference'.
            The formula is <c>int log(f(difference,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'difference'.
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'difference' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'difference'.
            The formula is <c>int log(f(difference,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="b"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'difference'.
            </summary>
            <param name="a">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'difference' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'difference'.
            The formula is <c>int log(f(difference,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="a"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.DifferenceAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'difference'.
            </summary>
            <param name="a">Constant value for 'a'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'difference' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'difference'.
            The formula is <c>int log(f(difference,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Difference">Incoming message from 'difference'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (difference,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Difference"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Difference">Incoming message from 'difference'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (difference,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Difference"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Difference">Constant value for 'difference'.</param>
            <param name="b">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (difference,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.AAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Difference">Constant value for 'difference'.</param>
            <param name="b">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (difference,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Difference">Incoming message from 'difference'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (difference,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Difference"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,System.Double)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Difference">Incoming message from 'difference'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="a">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (difference,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Difference"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Difference">Constant value for 'difference'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (difference,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DoubleMinusVmpOp.BAverageLogarithm(System.Double,System.Double)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Difference">Constant value for 'difference'.</param>
            <param name="a">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (difference,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix">
            <summary>
            A subclass of Matrix with extra methods appropriate to positive-definite matrices.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a zero matrix of the given dimensions.
            </summary>
            <param name="rows">Number of rows >= 0.</param>
            <param name="cols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Constructs a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(System.Int32,System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a matrix by referencing an array.
            </summary>
            <param name="data">Storage for the matrix elements.</param>
            <param name="rows">Number of rows.</param>
            <param name="cols">Number of columns.</param>
            <param name="start">Index of first matrix element in the array.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Constructs a positive-definite matrix type which references an existing matrix.
            </summary>
            <param name="A">A positive-definite matrix.</param>
            <remarks>This method is similar to a typecast, except it creates a new wrapper around the matrix.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Identity(System.Int32)">
            <summary>
            Creates a positive-definite identity matrix of a given dimension
            </summary>
            <param name="dimension"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.IdentityScaledBy(System.Int32,System.Double)">
            <summary>
            Creates a positive-definite identity matrix of a given dimension, scaled by a given value
            </summary>
            <param name="dimension"></param>
            <param name="scale"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.ReferenceClone">
            <summary>
            Creates a clone of this positive-definite matrix where the data is referenced
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Clone">
            <summary>
            Creates a full clone of this positive-definite matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.SetToSum(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets this positive-definite matrix to the sum of two positive-definite matrices.
            Assumes compatible matrices
            </summary>
            <param name="a">First matrix, which must have the same size as <c>this</c>.</param>
            <param name="b">Second matrix, which must have the same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks><c>this</c> receives the sum, and must already be the correct size.
            <paramref name="a"/> and/or <paramref name="b"/> may be the same object as <c>this</c>.
            If <c>this</c> and <paramref name="a"/>/<paramref name="b"/> occupy distinct yet overlapping portions of the same source array, the results are undefined.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.op_Addition(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Returns the sum of two positive-definite matrices.
            </summary>
            <param name="a">First matrix.</param>
            <param name="b">Second matrix.</param>
            <returns>Their sum.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Determinant">
            <summary>
            Returns the determinant of this positive-definite matrix.
            </summary>
            <returns>The determinant of <c>this</c>.</returns>
            <remarks>Throws a MatrixSingularException
            if the matrix is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.LogDeterminant">
            <summary>
            Returns the natural logarithm of the determinant of this positive-definite matrix.
            </summary>
            <returns>The log-determinant of <c>this</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.LogDeterminant(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Returns the natural logarithm of the determinant of this positive-definite matrix
            where a lower triangular workspace is passed in.
            </summary>
            <param name="L">A temporary workspace, same size as <c>this</c>.</param>
            <returns>The log-determinant.</returns>
            <remarks>Throws a MatrixSingularException
            if the matrix is singular.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.Inverse">
            <summary>
            Returns the inverse of a positive-definite matrix.
            </summary>
            <returns>A new matrix which is the inverse of <c>this</c></returns>
            <remarks>
            Because <paramref name="A"/> is positive definite, it must be 
            invertible, so this routine never throws MatrixSingularException.
            </remarks>
            <exception cref="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">If <paramref name="A"/> is not positive definite.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.SetToInverse(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sets this positive-definite matrix to inverse of a given positive-definite matrix.
            </summary>
            <param name="A">A symmetric positive-definite matrix, same size as <c>this</c>.</param>
            <returns><c>this</c></returns>
            <remarks>
            Because <paramref name="A"/> is positive definite, it must be 
            invertible, so this routine never throws MatrixSingularException.
            <c>this</c> must already be the correct size to receive the inverse.
            </remarks>
            <exception cref="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">If <paramref name="A"/> is not positive definite.</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix.SetToInverse(MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Sets this positive-definite matrix to inverse of a given positive-definite matrix
            where a lower triangular workspace is passed.
            </summary>
            <param name="A">A symmetric positive-definite matrix, same size as <c>this</c>.</param>
            <param name="L">A workspace, same size as <paramref name="A"/>.</param>
            <returns><c>this</c></returns>
            <remarks>
            Because <paramref name="A"/> is positive definite, it must be 
            invertible, so this routine never throws MatrixSingularException.
            <c>this</c> must already be the correct size to receive the inverse.
            </remarks>
            <exception cref="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">If <paramref name="A"/> is not positive definite.</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException">
            <summary>
            Exception thrown when a matrix is not positive definite.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrixException.#ctor">
            <summary>
            Creates a new positive definite matrix exception
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ExpOp">
            <summary>
            Provides outgoing messages for <see cref="M:System.Math.Exp(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.QuadratureNodeCount">
            <summary>
            The number of quadrature nodes used to compute the messages.
            Reduce this number to save time in exchange for less accuracy.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.QuadratureIterations">
            <summary>
            Number of quadrature iterations
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.QuadratureShift">
            <summary>
            Quadrature shift
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ExpOp.ForceProper">
            <summary>
             Forces proper messages when set to true. 
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="exp">Incoming message from 'exp'.</param>
            <param name="d">Constant value for 'd'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (exp,d)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="exp">Constant value for 'exp'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (exp,d)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="exp">Incoming message from 'exp'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (exp,d)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="exp">Incoming message from 'exp'.</param>
            <param name="d">Incoming message from 'd'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (exp,d)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="exp">Constant value for 'exp'.</param>
            <param name="d">Incoming message from 'd'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'exp'.
            </summary>
            <param name="exp">Incoming message from 'exp'.</param>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'exp' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'exp'.
            The formula is <c>int f(exp,x) q(x) dx</c> where <c>x = (d)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageConditional(System.Double)">
            <summary>
            EP message to 'd'.
            </summary>
            <param name="exp">Constant value for 'exp'.</param>
            <returns>The outgoing EP message to the 'd' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'd'.
            The formula is <c>int f(d,x) q(x) dx</c> where <c>x = (exp)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageConditional(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'd'.
            </summary>
            <param name="exp">Incoming message from 'exp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'd' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'd'.
            The formula is <c>int f(d,x) q(x) dx</c> where <c>x = (exp)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exp"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Returns 0.0.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.ExpAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'exp'.
            </summary>
            <param name="d">Incoming message from 'd'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'exp' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'exp'.
            The formula is <c>int log(f(exp,x)) q(x) dx</c> where <c>x = (d)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="d"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ExpOp.DAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'd'.
            </summary>
            <param name="exp">Incoming message from 'exp'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="d"></param>
            <param name="result"></param>
            <returns>The outgoing VMP message to the 'd' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'd'.
            The formula is <c>int log(f(d,x)) q(x) dx</c> where <c>x = (exp)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="exp"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOldOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromLogOdds(System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromLogOdds(System.Double)"/>, given random arguments to the function.
            Performs KL minimisation using gradient matching, a distributed gradient descent algorithm. 
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.UseJJ96Bound">
            <summary>
            If true, use Jaakkola and Jordan's (1996) bound to the logistic function.
            Otherwise use KL minimization.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            EP message to 'logOdds'.
            </summary>
            <param name="sample">Constant value for sample.</param>
            <param name="logOdds">Incoming message from 'logOdds'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'logOdds' argument.</returns>
            <remarks><para>
            The outgoing message is the moment matched Gaussian approximation to the factor.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogAverageFactor(System.Boolean,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Constant value for 'logOdds'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogAverageFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Incoming message from 'logOdds'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sample,logOdds)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.AverageLogFactor(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Incoming message from 'logOdds'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="logOdds">Incoming message from 'logOdds'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.sigma(System.Double,System.Double)">
            <summary>
            Calculate sigma(m,v) = \int N(x;m,v) logistic(x) dx
            </summary>
            <param name="m">Mean.</param>
            <param name="v">Variance.</param>
            <returns>The value of this special function.</returns>
            <remarks><para>
            For large v we can use the big v approximation <c>\sigma(m,v)=normcdf(m/sqrt(v+pi^2/3))</c>
            For small and moderate v we use Gauss-Hermite quadrature
            For moderate v we first find the mode of the log concave integrand since this 
            may be quite far from m
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.sigmaPrime(System.Double,System.Double)">
            <summary>
            Calculate <c>\sigma'(m,v)=\int N(x;m,v)logistic'(x) dx</c>
            </summary>
            <param name="m">Mean.</param>
            <param name="v">Variance.</param>
            <returns>The value of this special function.</returns>
            <remarks><para>
            For large v we can use the big v approximation <c>\sigma'(m,v)=N(m,0,v+pi^2/3)</c>
            For small and moderate v we use Gauss-Hermite quadrature
            For moderate v we first find the mode of the log concave integrand since this 
            may be quite far from m
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.sigmaPrimePrime(System.Double,System.Double)">
            <summary>
            Calculate <c>\sigma''(m,v)=\int N(x;m,v)logistic''(x) dx</c>
            </summary>
            <param name="m">Mean.</param>
            <param name="v">Variance.</param>
            <returns>The value of this special function.</returns>
            <remarks><para>
            For large v we can use the big v approximation <c>\sigma'(m,v)=-m/(v+pi^2/3)*N(m,0,v+pi^2/3</c>
            For small and moderate v we use Gauss-Hermite quadrature
            The integrand is multimodal so mode finding is difficult and might not help
            much anyway. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.gaussianExpectationOfXLogistic(System.Double,System.Double)">
            <summary>
            Calculate <c>\int (x-m)/sqrt(v) N(x;m,v)logistic(x) dx</c>
            </summary>
            <param name="m">Mean.</param>
            <param name="v">Variance.</param>
            <returns>The value of this special function.</returns>
            <remarks><para>
            Easily calculated as sqrt(v)*sigma'(m,v)
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gradient matching VMP message from factor to logOdds variable
            </summary>
            <param name="sample">Constant value for 'sample'.</param>
            <param name="logOdds">Incoming message. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Previous message sent, used for damping</param>
            <returns>The outgoing VMP message.</returns>
            <remarks><para>
            The outgoing message is the Gaussian approximation to the factor which results in the 
            same derivatives of the KL(q||p) divergence with respect to the parameters of the posterior
            as if the true factor had been used.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logOdds"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BernoulliFromLogOddsOp.LogOddsAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Gradient matching VMP message from factor to logOdds variable
            </summary>
            <param name="sample">Incoming message from 'sample'.</param>
            <param name="logOdds">Incoming message. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Previous message sent, used for damping</param>
            <returns>The outgoing VMP message.</returns>
            <remarks><para>
            The outgoing message is the Gaussian approximation to the factor which results in the 
            same derivatives of the KL(q||p) divergence with respect to the parameters of the posterior
            as if the true factor had been used.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="logOdds"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.DiscreteEstimator">
            <summary>
            Estimates a discrete distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.N">
            <summary>
            Number of samples
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.NProb">
            <summary>
            Vector of counts for each domain value
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">Where to put the estimated distribution</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Add(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Adds a discrete distribution item to the estimator
            </summary>
            <param name="distribution">A Discrete instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Add(MicrosoftResearch.Infer.Distributions.Discrete,System.Double)">
            <summary>
            Adds a weighted discrete distribution item to the estimator
            </summary>
            <param name="distribution">A Discrete instance</param>
            <param name="weight">Weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Add(System.Int32)">
            <summary>
            Adds an discrete sample to the estimator
            </summary>
            <param name="sample">The sample value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.#ctor(System.Int32)">
            <summary>
            Creates a new discrete distribution estimator
            </summary>
            <param name="dimension">Dimension</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.SetTo(MicrosoftResearch.Infer.Distributions.DiscreteEstimator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.DiscreteEstimator.Dimension">
            <summary>
            Dimension of the discrete distribution
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix">
            <summary>
            Class for lower triangular matrices
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a zero matrix of the given dimensions.
            </summary>
            <param name="nRows">Number of rows >= 0.</param>
            <param name="nCols">Number of columns >= 0.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.#ctor(System.Int32,System.Int32,System.Double[],System.Int32)">
            <summary>
            Constructs a matrix by referencing an array.
            </summary>
            <param name="data">Storage for the matrix elements.</param>
            <param name="nRows">Number of rows.</param>
            <param name="nCols">Number of columns.</param>
            <param name="start">Index of first matrix element in the array.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.#ctor(System.Double[0:,0:])">
            <summary>
            Constructs a matrix from data in a 2D array.
            </summary>
            <param name="data">2D array of elements.</param>
            <remarks>The 2D array is copied into new storage.
            The size of the matrix is taken from the array.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.ReferenceClone">
            <summary>
            Creates a clone of this instance which references the source array
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Clone">
            <summary>
            Creates a full clone of this instance (including the data)
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.CheckLowerTriangular">
            <summary>
            Checks that this instance is lower triangular
            </summary>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.SetToInverse(MicrosoftResearch.Infer.Maths.LowerTriangularMatrix)">
            <summary>
            Modify <c>this</c> to be the inverse of A.
            </summary>
            <param name="A">Can be the same object as <c>this</c></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.SetToTranspose(MicrosoftResearch.Infer.Maths.UpperTriangularMatrix)">
            <summary>
            Returns the transpose of the upper triangular matrix U
            </summary>
            <param name="U"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Transpose">
            <summary>
            Returns the transpose of this lower triangular matrix
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.ProdDiag">
            <summary>
            Returns the product of diagonal elements of this lower triangular matrix
            </summary>
            <returns><c>prod(diag(this))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.Determinant">
            <summary>
            Returns the determinant of this lower-triangular matrix.
            </summary>
            <returns>The determinant of this.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.TraceLn">
            <summary>
            Returns the sum of the logarithm of diagonal elements.
            </summary>
            <returns><c>sum(log(diag(this)))</c>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.LogDeterminant">
            <summary>
            Returns the natural logarithm of the determinant of a lower-triangular matrix.
            </summary>
            <returns>The log-determinant of this.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LowerTriangularMatrix.SetToCholesky(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Gets the Cholesky decomposition of another matrix.
            </summary>
            <param name="A">A symmetric matrix to decompose.</param>
            <returns>True if <paramref name="A"/> is positive definite, otherwise false.</returns>
            <remarks>
            The decomposition is a lower triangular matrix L, returned in <c>this</c>.
            <paramref name="A"/> must be symmetric, but need not be positive definite.
            If <paramref name="A"/> is positive semidefinite, 
            then L will satisfy L*L' = A.
            Otherwise, L will only approximately satisfy L*L' = A.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.ProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'product'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int log(f(product,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.ProductAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'product'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'product' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'product'.
            The formula is <c>int log(f(product,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="Product">Constant value for 'product'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (product,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ProductGaussianBetaVmpOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="Product">Incoming message from 'product'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (product,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="Product"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GaussianBetaProductOp">
            <summary>
            Provides outgoing Gaussian messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)"/>,
            given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GaussianBetaProductOp.ProposalDistribution(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.Beta)">
            <summary>
            Find a proposal distribution - we will use this to set the limits of
            integration
            </summary>
            <param name="y">Gaussian distribution for y</param>
            <param name="a">Gaussian distribution for a</param>
            <param name="b">Beta distribution for b</param>
            <returns>A proposal distribution</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GetItemsOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GetItems``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})"/>, given random arguments to the function.
            This factor gets a sub-array of (possibly duplicated) items from an array of items
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogAverageFactor``2(System.Collections.Generic.IList{``0},``1,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="DistributionType">Message type</typeparam>
            <typeparam name="ArrayType">List type</typeparam>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns><c>log(int f(x) qnotf(x) dx))</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (items,array,indices)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogAverageFactor``2(System.Collections.Generic.IList{`0},``1,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="DistributionType">Message type</typeparam>
            <typeparam name="ArrayType">List type</typeparam>
            <param name="items">Constant value for 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <returns><c>log(int f(x) qnotf(x) dx))</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (items,array,indices)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogEvidenceRatio``2(``1,System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="DistributionType">Message type</typeparam>
            <typeparam name="ArrayType">List type</typeparam>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.LogEvidenceRatio``2(System.Collections.Generic.IList{`0},``1,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="DistributionType">Message type</typeparam>
            <typeparam name="ArrayType">List type</typeparam>
            <param name="items">Constant value for 'items'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="indices">Constant value for 'indices'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ItemsAverageConditional``3(System.Collections.Generic.IList{``0},``1,System.Collections.Generic.IList{System.Int32},``2)">
            <summary>
            EP message to 'items'.
            </summary>
            <param name="items">Incoming message from 'items'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'items'.
            The formula is <c>int f(items,x) q(x) dx</c> where <c>x = (array,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int f(array,x) q(x) dx</c> where <c>x = (items,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageConditional``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="items">Constant value for 'items'.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int f(array,x) q(x) dx</c> where <c>x = (items,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (items,array,indices)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ItemsAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'items'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'items'.
            The formula is <c>int log(f(items,x)) q(x) dx</c> where <c>x = (array,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="items">Incoming message from 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int log(f(array,x)) q(x) dx</c> where <c>x = (items,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GetItemsOp`1.ArrayAverageLogarithm``2(System.Collections.Generic.IList{`0},System.Collections.Generic.IList{System.Int32},``1)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="items">Constant value for 'items'. Must be a proper distribution.  If all elements are uniform, the result will be uniform.</param>
            <param name="indices">Constant value for 'indices'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int log(f(array,x)) q(x) dx</c> where <c>x = (items,indices)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="items"/> is not a proper distribution</exception>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.HasMessageFunctionsAttribute">
            <summary>
            When applied to an assembly, indicates that the assembly should be searched for message functions.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethodAttribute">
            <summary>
            When applied to a class, indicates that the class provides message functions for a given factor.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.Type">
            <summary>
            Type which contains the factor definition
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.MethodName">
            <summary>
            Method name for the factor
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.ParameterTypes">
            <summary>
            Parameter types for the factor
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.NewParameterNames">
            <summary>
            New names for factor parameters overriding the default choice of parameter names
            - these are used to name message passing methods
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.#ctor(System.Type,System.String,System.Type[])">
            <summary>
            Creates a new FactorMethod attribute
            </summary>
            <param name="type">Type which contains the factor definition</param>
            <param name="methodName">Method name for the factor</param>
            <param name="parameterTypes">Parameter types for the factor</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FactorMethodAttribute.#ctor(System.String[],System.Type,System.String,System.Type[])">
            <summary>
            Creates a new FactorMethod attribute
            </summary>
            <param name="type">Type which contains the factor definition</param>
            <param name="methodName">Method name for the factor</param>
            <param name="parameterTypes">Parameter types for the factor</param>
            <param name="newParameterNames">New names for factor parameters overriding the default choice of
            parameter names - these are used to name message passing methods</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ParameterNamesAttribute">
            <summary>
            When applied to a method, overrides the default choice of parameter names.
            </summary>
            <remarks>
            The first parameter is the result.  Thus the method <c>int f(int x)</c> has two parameters, the
            result and x.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.ParameterNamesAttribute.Names">
            <summary>
            The new parameter names
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ParameterNamesAttribute.#ctor(System.String[])">
            <summary>
            Creates a new ParameterNames attribute
            </summary>
            <param name="names"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.AllExceptIndexAttribute">
            <summary>
            When applied to a message function parameter, indicates that the function depends on all items
            in the message collection except the resultIndex.  The default is all items.
            </summary>
            <remarks>
            This attribute cannot be combined with MatchingIndexAttribute, since they would cancel.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatchingIndexAttribute">
            <summary>
            When applied to a message function parameter, indicates that the function depends on the one
            item in the message collection at resultIndex.  The default is all items.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Proper">
            <summary>
            The distribution must be proper.
            </summary>
            <remarks>
            Applies to message function parameters.  Indicates that the parameter should be a proper distribution,
            or else the behavior is undefined.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipAttribute">
            <summary>
            The result is always uniform.
            </summary>
            <remarks>
            Applies to message functions.  This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce uniform results.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) whenever this parameter is uniform, hence the function call can be skipped.
            </summary>
            <remarks><para>
            Applies to message function parameters.  This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce a uniform result or throw
            an exception.  For LogAverageFactor and AverageLogFactor, SkipIfUniform means the result would be 0.
            </para><para>
            When applied to an array parameter, this attribute means the result is uniform (or an exception would be thrown)
            whenever any dependent element in the array is uniform.
            For example:
            <list type="bullet">
            <item><term><c>f([AllExceptIndex,SkipIfUniform] Message[] array, int resultIndex)</c></term>
            <description><c>f</c> depends on all elements other than resultIndex, and can be skipped if any of these are uniform.
            <c>f</c> does not depend on <c>array[resultIndex]</c> and the uniformity of this element is ignored.
            </description>
            </item>
            </list>
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if all elements are uniform, hence the function call can be skipped.
            </summary>
            <remarks><para>
            Applies to message functions and message function array parameters.
            This annotation is optional and allows the inference
            engine to skip unnecessary function calls, i.e. ones which would produce a uniform result or throw
            an exception.
            When applied to a message function, it means that the result is uniform (or an exception would be thrown) whenever all parameters to the function are uniform.
            When applied to an array parameter, it means that the result is uniform (or an exception would be thrown) whenever all dependent elements in the array are uniform.
            Array elements that the function does not depend on are ignored.
            </para><para>
            It only makes sense to apply this attribute to a method when the method parameters have no SkipIfUniform attributes set.
            Otherwise SkipIfAllUniform is automatically implied by SkipIfUniform for the parameter.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute.ParameterNames">
            <summary>
            List of parameter names for which to check for uniformity
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute.#ctor">
            <summary>
            Creates a new SkipIfAllUniform attribute
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.SkipIfAllUniformAttribute.#ctor(System.String[])">
            <summary>
            Creates a new SkipIfAllUniform attribute applied to the specified parameter names
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAnyExceptIndexIsUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if any element except <paramref name="resultIndex"/> is uniform, hence the function call can be skipped.
            </summary>
            <remarks>
            Examples:
            <list type="bullet">
            <item><term><c>f([SkipIfAnyExceptIndexIsUniform] Message[] array, int resultIndex)</c></term>
            <description>Since no dependency attribute was given, the default is that <c>f</c> depends on all elements of the array.
            Since <c>SkipIfAnyExceptIndexIsUniform</c> was given, <c>f</c> returns uniform (or throws an exception) if any elements except the one at resultIndex is uniform.
            Thus <c>array[resultIndex]</c> is a dependency but its uniformity is ignored.</description>
            </item>
            <item><term><c>f([AllExceptIndex,SkipIfAnyExceptIndexIsUniform] Message[] array, int resultIndex)</c></term>
            <description>In this case, <c>f</c> depends on all elements other than resultIndex, and returns uniform (or throws an exception) if any of them are uniform.
            Thus it is equivalent to <c>[AllExceptIndex,SkipIfUniform]</c></description>
            </item>
            <item><term><c>f([MatchingIndex,SkipIfAnyExceptIndexIsUniform] Message[] array, int resultIndex)</c></term>
            <description>Here <c>SkipIfAnyExceptIndexIsUniform</c> is ignored since <c>f</c> only depends on <c>array[resultIndex]</c>.
            </description>
            </item>
            </list>
            This attribute can be stacked with the other SkipIfUniform attributes, to build up a set of skip cases.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfAllExceptIndexAreUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if all elements except <paramref name="resultIndex"/> are uniform, hence the function call can be skipped.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.SkipIfMatchingIndexIsUniformAttribute">
            <summary>
            The result is uniform (or an exception would be thrown) if the element at <paramref name="resultIndex"/> is uniform, hence the function call can be skipped.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.RequiredArgumentAttribute">
            <summary>
            When applied to a method argument, indicates that argument is required to have a
            been set before calling the method
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsReturnedAttribute">
            <summary>
            When applied to a method argument, indicates that the argument will be returned unmodified
            as the result of the method.
            </summary>
            <remarks>
            This attribute allows significant optimisations to be undertaken in the compiler.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DependsOnIterationAttribute">
            <summary>
            When applied to a method invoke expression, indicates that the execution of this
            expression depends on the iteration counter
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.TriggerAttribute">
            <summary>
            When applied to a method argument, indicates that the method's result is invalidated when
            a dependent item in that argument changes.
            </summary>
            <remarks>
            The formal definition of trigger is:
            If C uses A, and A is triggered by B, then when B changes, A must be updated before C.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.MatchingIndexTriggerAttribute">
            <summary>
            When applied to a method argument, indicates that the method's result is invalidated when
            the array element at resultIndex changes.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ImproperMessageException">
            <summary>
            Improper message exception
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ImproperMessageException.#ctor(System.Object)">
            <summary>
            Creates an improper message exception with the specified distribution
            </summary>
            <param name="distribution">Distribution instance</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.NotSupportedAttribute">
            <summary>
            When applied to a method, indicates that the method will always throw a NotSupportedException.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Factors.NotSupportedAttribute.Message">
            <summary>
            Message for the exception that will be thrown by the method
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.NotSupportedAttribute.#ctor(System.String)">
            <summary>
            Creates a NotSupported attribute with the given exception message
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Boolean,System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageConditional(System.Boolean,System.Boolean)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.LogEvidenceRatio(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (areEqual,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int log(f(areEqual,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int log(f(areEqual,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int log(f(areEqual,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AreEqualAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int log(f(areEqual,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.AAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'a' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.BooleanAreEqualOp.BAverageLogarithm(System.Boolean,System.Boolean)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Int32,System.Int32)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageConditional(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            EP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int f(areEqual,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageConditional(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageConditional(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (areEqual,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (areEqual,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (areEqual,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int log(f(areEqual,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageLogarithm(System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int log(f(areEqual,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AreEqualAverageLogarithm(MicrosoftResearch.Infer.Distributions.Discrete,System.Int32)">
            <summary>
            VMP message to 'areEqual'.
            </summary>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'areEqual' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'areEqual'.
            The formula is <c>int log(f(areEqual,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.AAverageLogarithm(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (areEqual,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Bernoulli,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Incoming message from 'areEqual'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="areEqual"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(System.Boolean,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.DiscreteAreEqualOp.BAverageLogarithm(System.Boolean,System.Int32,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="areEqual">Constant value for 'areEqual'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (areEqual,a)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.AllTrueOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.AllTrue(System.Collections.Generic.IList{System.Boolean})"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.LogEvidenceRatio``1(MicrosoftResearch.Infer.Distributions.Bernoulli,``0)">
            <summary>
            Returns 0
            </summary>
            <typeparam name="BernoulliList"></typeparam>
            <param name="allTrue"></param>
            <param name="array"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.AllTrueOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sum,array)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential">
            <summary>
            Squared Exponential kernel function
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.#ctor">
            <summary>
            Default constructor for squared exponential kernel function
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.#ctor(System.Double,System.Double)">
            <summary>
            Constructs squared exponential kernel function from log length and log signal variance
            </summary>
            <param name="logLength">Log length</param>
            <param name="logSigVar">Log signal variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.SquaredExponential.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.CanBeMessage">
            <summary>
            CanBeMessage attribute. Marks property as something that
            can be used in a message. NOTE: This is a temporary
            attribute to help with the transition from DistWithSample
            to separate dist/sample messages
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.BernoulliEstimator">
            <summary>
            Estimates a Bernoulli distribution from samples.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.N">
            <summary>
            Number of samples
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.NProbTrue">
            <summary>
            Number of samples with value true
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.GetDistribution(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Gets the estimated distribution
            </summary>
            <param name="result">A place to put the resulting distribution. This is ignored because Bernoulli is a struct</param>
            <returns>The estimated distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Add(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Adds a distribution item to the estimator
            </summary>
            <param name="distribution">A Bernoulli distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Add(System.Boolean)">
            <summary>
            Adds a sample to the estimator
            </summary>
            <param name="sample">The sample - true or false</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Clear">
            <summary>
            Clears the estimator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.Clone">
            <summary>
            Returns a copy of the estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.BernoulliEstimator.SetTo(MicrosoftResearch.Infer.Distributions.BernoulliEstimator)">
            <summary>
            Sets this estimator's state from the supplied estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ArrayAsList`1">
            <summary>
            Wraps a multidimensional array to look like a linear list.
            </summary>
            <remarks>
            In the MSDN documentation, the Array class claims to implement IList.  In fact, this interface is only supported
            for one-dimensional arrays.  ArrayAsList provides this missing functionality for multidimensional arrays.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.InnerProductOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.InnerProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (innerProduct,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'innerProduct'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'innerProduct' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'innerProduct'.
            The formula is <c>int log(f(innerProduct,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageLogarithm(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'innerProduct'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'innerProduct' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'innerProduct'.
            The formula is <c>int log(f(innerProduct,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageLogarithm(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            VMP message to 'innerProduct'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing VMP message to the 'innerProduct' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'innerProduct'.
            The formula is <c>int log(f(innerProduct,x)) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (innerProduct,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (innerProduct,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (innerProduct,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageLogarithm(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'a'.
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int log(f(a,x)) q(x) dx</c> where <c>x = (innerProduct,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (innerProduct,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (innerProduct,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (innerProduct,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageLogarithm(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            VMP message to 'b'.
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = (innerProduct,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'innerProduct'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'innerProduct' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'innerProduct'.
            The formula is <c>int f(innerProduct,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (innerProduct,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (innerProduct,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageConditional(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'innerProduct'.
            </summary>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'innerProduct' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'innerProduct'.
            The formula is <c>int f(innerProduct,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="B"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.InnerProductAverageConditional(MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            EP message to 'innerProduct'.
            </summary>
            <param name="A">Incoming message from 'a'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns>The outgoing EP message to the 'innerProduct' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'innerProduct'.
            The formula is <c>int f(innerProduct,x) q(x) dx</c> where <c>x = (a,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="A"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (innerProduct,b)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.AAverageConditional(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'a'.
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="B">Constant value for 'b'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'a'.
            The formula is <c>int f(a,x) q(x) dx</c> where <c>x = (innerProduct,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (innerProduct,a)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="innerProduct"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.BAverageConditional(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            EP message to 'b'.
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = (innerProduct,a)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="b">Incoming message from 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogEvidenceRatio(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="a">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (innerProduct,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (innerProduct,a,b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Distributions.VectorGaussian)">
            <summary>
            
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Constant value for 'a'.</param>
            <param name="B">Incoming message from 'b'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            
            </summary>
            <param name="innerProduct">Incoming message from 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.InnerProductOp.LogAverageFactor(System.Double,MicrosoftResearch.Infer.Distributions.VectorGaussian,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            
            </summary>
            <param name="innerProduct">Constant value for 'innerProduct'.</param>
            <param name="A">Incoming message from 'a'.</param>
            <param name="B">Constant value for 'b'.</param>
            <returns></returns>
            <remarks><para>
            
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.GammaFromShapeAndRate(System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.AverageLogFactor(System.Double,System.Double,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="y">Constant value for 'y'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="y">Incoming message from 'y'.</param>
            <param name="shape">Incoming message from 'shape'.</param>
            <param name="rate">Incoming message from 'rate'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="y">Incoming message from 'y'.</param>
            <param name="shape">Incoming message from 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.AverageLogFactor(MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="y">Incoming message from 'y'.</param>
            <param name="shape">Constant value from 'shape'.</param>
            <param name="rate">Incoming message for 'rate'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="y">Incoming message from 'y'.</param>
            <param name="shape">Incoming message from 'shape'.</param>
            <param name="rate">Incoming message from 'rate'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.AverageLogFactor(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="y">Incoming message from 'y'.</param>
            <param name="shape">Incoming message from 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.AverageLogFactor(System.Double,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="y">Incoming message from 'y'.</param>
            <param name="shape">Constant value from 'shape'.</param>
            <param name="rate">Incoming message for 'rate'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sample,mean,precision)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.YAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'Y'.
            </summary>
            <param name="shape">Incoming message from 'shape'.</param>
            <param name="rate">Incoming message from 'rate'.</param>
            <returns>The outgoing VMP message to the 'Y' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (shape,rate)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.YAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'Y'.
            </summary>
            <param name="shape">Incoming message from 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <returns>The outgoing VMP message to the 'Y' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (shape,rate)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.YAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'Y'.
            </summary>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Incoming message from 'rate'.</param>
            <returns>The outgoing VMP message to the 'Y' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (shape,rate)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.RateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'rate'.
            </summary>
            <param name="Y">Incoming message from 'Y'.</param>
            <param name="shape">Incoming message from 'shape'.</param>
            <returns>The outgoing VMP message to the 'Y' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (shape,rate)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.RateAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            VMP message to 'rate'.
            </summary>
            <param name="Y">Constant value for 'Y'.</param>
            <param name="shape">Incoming message from 'shape'.</param>
            <returns>The outgoing VMP message to the 'Y' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (shape,rate)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.RateAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,System.Double)">
            <summary>
            VMP message to 'rate'.
            </summary>
            <param name="Y">Incoming message from 'Y'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <returns>The outgoing VMP message to the 'Y' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'Y'.
            The formula is <c>int log(f(sample,x)) q(x) dx</c> where <c>x = (shape,rate)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.ShapeAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Projection VMP message to 'shape'.
            </summary>
            <param name="Y">Incoming message from 'Y'.</param>
            <param name="shape">Constant value for 'shape'.</param>
            <param name="rate">Incoming message from 'rate'.</param>
            <param name="result">Previous message sent to shape.</param>
            <returns>The outgoing VMP message to the 'Y' argument.</returns>
            <remarks><para>
             The outgoing message here would not be Gamma distributed, so we use projection VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.ShapeAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Projection VMP message to 'shape'.
            </summary>
            <param name="Y">Constant value for 'Y'.</param>
            <param name="shape">Incoming message from 'shape'.</param>
            <param name="rate">Incoming message from 'rate'.</param>
            <param name="result">Previous message sent to shape.</param>
            <returns>The outgoing VMP message to the 'Y' argument.</returns>
            <remarks><para>
             The outgoing message here would not be Gamma distributed, so we use projection VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.ShapeAverageLogarithm(System.Double,MicrosoftResearch.Infer.Distributions.Gamma,System.Double,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Projection VMP message to 'shape'.
            </summary>
            <param name="Y">Constant value for 'Y'.</param>
            <param name="shape">Incoming message from 'shape'.</param>
            <param name="rate">Constant value for 'rate'.</param>
            <param name="result">Previous message sent to shape.</param>
            <returns>The outgoing VMP message to the 'Y' argument.</returns>
            <remarks><para>
             The outgoing message here would not be Gamma distributed, so we use projection VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.ShapeAverageLogarithm(MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma,MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Projection VMP message to 'shape'.
            </summary>
            <param name="Y">Incoming message from 'Y'.</param>
            <param name="shape">Incoming message from 'shape'.</param>
            <param name="rate">Incoming message from 'rate'.</param>
            <param name="result">Previous message sent to shape.</param>
            <returns>The outgoing VMP message to the 'Y' argument.</returns>
            <remarks><para>
             The outgoing message here would not be Gamma distributed, so we use projection VMP, which
             sends the approximate factor ensuring the gradient of the KL wrt to the variational parameters match. 
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.GammaFromShapeAndRate.CalculateDerivatives(MicrosoftResearch.Infer.Distributions.Gamma)">
            <summary>
            Calculate derivatives of \int G(x;a,b) LogGamma(x) dx wrt (a,b)
            </summary>
            <param name="q">The Gamma distribution G(x;a,b).</param>
            <returns>A 2-vector containing derivatives of \int G(x;a,b) LogGamma(x) dx wrt (a,b).</returns>
            <remarks><para>
             Calculates expectations in x=log(s) space using Gauss-Hermite quadrature. 
             For each integral the behaviour as x->0 is subtracted from the integrand 
             before performing quadrature to remove the singularity there. 
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`1">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`2">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`3">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`4">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FactorMethod`5">
            <exclude/>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Factor">
            <summary>
            A repository of commonly used factor methods.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Random``1(MicrosoftResearch.Infer.Distributions.Sampleable{``0})">
            <summary>
            Random factor - samples from a given distribution
            </summary>
            <typeparam name="DomainType">Domain type</typeparam>
            <param name="dist">Distribution to sample from</param>
            <returns>Sample</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Bernoulli(System.Double)">
            <summary>
            Sample from a Bernoulli distribution.
            </summary>
            <param name="probTrue">The probability that the result is true.</param>
            <returns>A random boolean value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromLogOdds(System.Double)">
            <summary>
            Sample from a Bernoulli distribution with specified log odds
            </summary>
            <param name="logOdds"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GammaFromShapeAndRate(System.Double,System.Double)">
            <summary>
            Sample from a Gamma with specified shape and scale
            </summary>
            <param name="shape"></param>
            <param name="rate"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromDiscrete(System.Int32,System.Double[])">
            <summary>
            Sample from one of many Bernoulli distributions. This factor is DEPRECATED.
            Use Gates instead.
            </summary>
            <param name="index">The index of the distribution to sample from.</param>
            <param name="probTrue">The probability that the result is true, for each index.</param>
            <returns>A random boolean value.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double[])">
            <summary>
            Sample from one of two Bernoulli distributions. This factor is DEPRECATED.
            Use Gates instead.
            </summary>
            <param name="choice">Indicates which distribution to sample from.</param>
            <param name="probTrue">The probability that the result is true, for each choice.</param>
            <returns>A random boolean value.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BernoulliFromBoolean(System.Boolean,System.Double,System.Double)">
            <summary>
            Sample from one of two Bernoulli distributions. This factor is DEPRECATED.
            Use Gates instead.
            </summary>
            <param name="choice">Indicates which distribution to sample from.</param>
            <param name="probTrueElseChoice">The probability that the result is true, if <paramref name="choice"/> is false.</param>
            <param name="probTrueIfChoice">The probability that the result is true, if <paramref name="choice"/> is true.</param>
            <returns>A random boolean value.</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.BetaFromMeanAndTotalCount(System.Double,System.Double)">
            <summary>
            Sample from a Beta distribution
            </summary>
            <param name="mean">Mean of the distribution.</param>
            <param name="totalCount">Total count (precision) of the distribution.</param>
            <returns>A sample from the distribution, i.e. a value in [0,1]. </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DirichletFromMeanAndTotalCount(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Sample from a Dirichlet distribution
            </summary>
            <param name="mean">Mean of the distribution.</param>
            <param name="totalCount">Total count (precision) of the distribution.</param>
            <returns>A sample from the distribution, a probability vector. </returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(System.Int32,MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Sample from one of several discrete distributions.
            </summary>
            <param name="probs">Matrix holding discrete distributions as rows.</param>
            <param name="selector">Integer selecting which row of probs to sample from.</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Discrete(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a discrete distribution.
            </summary>
            <param name="probs">The probability of each outcome.</param>
            <returns>A random integer from 0 to <c>probs.Length-1</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteFromLogProbs(System.Double[])">
            <summary>
            Sample from a discrete distribution, specified by unnormalized log probabilities.
            </summary>
            <param name="logProbs">The log-probability of each outcome, plus an arbitrary constant.</param>
            <returns>A random integer from 0 to <c>logProbs.Length-1</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.DiscreteFromStickBreaking(System.Double[])">
            <summary>
            Sample from a DP stick breaking prior
            </summary>
            <param name="v">Stick lengths</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Gaussian(System.Double,System.Double)">
            <summary>
            Sample from a Gaussian distribution.
            </summary>
            <param name="mean">The mean of the distribution.</param>
            <param name="precision">The precision of the distribution.  The variance will be 1/precision.</param>
            <returns>A random real number.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.VectorGaussian(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix)">
            <summary>
            Sample from a VectorGaussian distribution.
            </summary>
            <param name="mean">The mean vector of the distribution.</param>
            <param name="precision">The precision matrix of the distribution.  The variance matrix will be inv(precision).</param>
            <returns>A random real vector.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Poisson(System.Double)">
            <summary>
            Sample from a Poisson distribution with a specified mean
            </summary>
            <param name="mean"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Binomial(System.Int32,System.Double)">
            <summary>
            Sample from a Binomial distribution with specified probability of success per trial and number of trials.
            </summary>
            <param name="trialCount"></param>
            <param name="probSuccess"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Multinomial(System.Int32,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sample from a Multinomial distribution with specified probabilities and number of trials.
            </summary>
            <param name="trialCount">Number of trials, >= 0</param>
            <param name="probs">Must sum to 1</param>
            <returns>An array of length <c>probs.Count</c> of integers between 0 and trialCount, whose sum is trialCount.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Not(System.Boolean)">
            <summary>
            Negate a boolean
            </summary>
            <param name="b">The bool</param>
            <returns>The negation of a boolean argument</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Or(System.Boolean,System.Boolean)">
            <summary>
            Logical or of two booleans
            </summary>
            <param name="a">First bool</param>
            <param name="b">Second bool</param>
            <returns>a|b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.And(System.Boolean,System.Boolean)">
            <summary>
            Logical and of two booleans
            </summary>
            <param name="a">First bool</param>
            <param name="b">Second bool</param>
            <returns>a&amp;b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Boolean,System.Boolean)">
            <summary>
            Test if two booleans are equal.
            </summary>
            <param name="a">First bool</param>
            <param name="b">Second bool</param>
            <returns>True if a==b.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.AreEqual(System.Int32,System.Int32)">
            <summary>
            Test if two integers are equal.
            </summary>
            <param name="a">First integer</param>
            <param name="b">Second integer</param>
            <returns>True if a==b.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.IsPositive(System.Double)">
            <summary>
            Test if a real number is positive.
            </summary>
            <param name="x">Any number besides NaN.</param>
            <returns>True if x>0.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.IsBetween(System.Double,System.Double,System.Double)">
            <summary>
            Test if a number is between two bounds.
            </summary>
            <param name="x">Any number besides NaN.</param>
            <param name="lowerBound">Any number besides NaN.</param>
            <param name="upperBound">Any number besides NaN.</param>
            <returns>True if (lowerBound &lt;= x) and (x &lt; upperBound)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Max(System.Double,System.Double)">
            <summary>
            Returns the maximum of the two arguments: max(a,b)
            </summary>
            <returns>a*b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.IsGreaterThan(System.Int32,System.Int32)">
            <summary>
            Test if A is greater than B.
            </summary>
            <param name="a">First integer</param>
            <param name="b">Second integer</param>
            <returns>True if a &gt; b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Int32,System.Int32)">
            <summary>
            Returns the sum of the two arguments: (a + b).
            </summary>
            <returns>a+b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Plus(System.Double,System.Double)">
            <summary>
            Returns the sum of the two arguments: (a + b).
            </summary>
            <returns>a+b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Difference(System.Double,System.Double)">
            <summary>
            Returns the difference of the two arguments: (a - b).
            </summary>
            <returns>a-b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product(System.Double,System.Double)">
            <summary>
            Returns the product of the two arguments a * b.
            </summary>
            <returns>a*b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Ratio(System.Double,System.Double)">
            <summary>
            Returns the ratio of the two arguments a / b.
            </summary>
            <returns>a-b</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.InnerProduct(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the inner product between two vectors.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>sum_i a[i]*b[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Product(MicrosoftResearch.Infer.Maths.Matrix,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Returns the product between a matrix and a vector.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns><c>sum_j a[i,j]*b[j]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.MatrixMultiply(System.Double[0:,0:],System.Double[0:,0:])">
            <summary>
            Returns the product of two matrices.
            </summary>
            <param name="A">A two-dimensional array indexed by [row,col].</param>
            <param name="B">A two-dimensional array indexed by [row,col].</param>
            <returns>A two-dimensional array indexed by [row,col].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{System.Double})">
            <summary>
            Sum the numbers in an array.
            </summary>
            <param name="array"></param>
            <returns><c>sum_i array[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.AllTrue(System.Collections.Generic.IList{System.Boolean})">
            <summary>
            True if all array elements are true.
            </summary>
            <param name="array"></param>
            <returns><c>AND_i array[i]</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GetItem``1(System.Collections.Generic.IList{``0},System.Int32)">
            <summary>
            Get an element of an array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="index">The index to get</param>
            <returns>The item</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GetItems``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Get multiple elements of an array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="indices">Array of indices for items we want to get</param>
            <returns>The items</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Subarray``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32})">
            <summary>
            Get multiple different elements of an array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="indices">Array of indices for items we want to get.  Must all be different.</param>
            <returns>The items</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.GetItem2D``1(``0[0:,0:],System.Int32,System.Int32)">
            <summary>
            Get an element of a 2D array.
            </summary>
            <typeparam name="T">Type of element in the array</typeparam>
            <param name="array">The array</param>
            <param name="index1">The first index</param>
            <param name="index2">The second index</param>
            <returns>The item</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.UsesEqualDef``1(``0,``0)">
            <summary>
            Create an array filled with a single value.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="Def">The value to fill with.</param>
            <param name="Marginal">Dummy argument for inferring marginals.</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Replicate``1(``0,System.Int32)">
            <summary>
            Create an array filled with a single value. For reference types,
            the replicates all reference the same instance
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="value">The value to fill with.</param>
            <param name="count">Number of replicates</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateNd``1(``0)">
            <summary>
            Create a multidimensional array filled with a single value.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="value">The value to fill with.</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.ReplicateWithMarginal``1(``0,``0)">
            <summary>
            Create an array filled with a single value.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="Def">The value to fill with.</param>
            <param name="Marginal">Dummy argument for inferring marginals.</param>
            <returns>A new array with all entries set to value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.Copy``1(``0)">
            <summary>
            Passes the input through to the output.  Used to support literal indexing.
            </summary>
            <typeparam name="T">The type of array element</typeparam>
            <param name="value">The value to return.</param>
            <returns>The supplied value.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Factor.FunctionEvaluate(MicrosoftResearch.Infer.Distributions.IFunction,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Function evaluate factor
            </summary>
            <param name="func">Function</param>
            <param name="x">Function input</param>
            <returns>Function output</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstraintViolatedException">
            <summary>
            Exception which is thrown when a constraint is violated.  This
            occurs when an observation does not hold true or a weight is 0.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstraintViolatedException.#ctor(System.String)">
            <summary>
            Constructs a constraint violation expception with a specified error message 
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.Constrain">
            <summary>
            A repository of commonly used constraint methods.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.EqualRandom``2(``0,``1)">
            <summary>
            Constrains a value to be equal to a sample from dist.
            </summary>
            <typeparam name="DomainType">Domain type</typeparam>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="value">Value</param>
            <param name="dist">Distribution instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.Equal``1(``0,``0)">
            <summary>
            Constrains a value to be equal to another value.
            </summary>
            <typeparam name="T">Value type</typeparam>
            <param name="A">First value</param>
            <param name="B">Second value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.True(System.Boolean)">
            <summary>
            Constrains a boolean value to be true.
            </summary>
            <param name="b">Boolean value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.False(System.Boolean)">
            <summary>
            Constrains a boolean value to be false.
            </summary>
            <param name="b">Boolean value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.Positive(System.Double)">
            <summary>
            Constrains a double value to be positive (greater than zero).
            </summary>
            <param name="x">Double value</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.Constrain.Between(System.Double,System.Double,System.Double)">
            <summary>
            Constrains lowerBound &lt;= x &lt; upperBound.
            </summary>
            <param name="x">Value to bound</param>
            <param name="lowerBound">Lower bound</param>
            <param name="upperBound">Upper bound</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.EqualRandom``2(``0,``1)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.ValueAverageConditional``1(``0)">
            <summary>
            EP message to 'value'.
            </summary>
            <param name="dist">Constant value for 'dist'.</param>
            <returns>The outgoing EP message to the 'value' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int f(value,x) q(x) dx</c> where <c>x = (dist)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogAverageFactor``1(``0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="value">Incoming message from 'value'.</param>
            <param name="dist">Constant value for 'dist'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (value,dist)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogAverageFactor``1(`0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="value">Constant value for 'value'.</param>
            <param name="dist">Constant value for 'dist'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (value,dist)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogEvidenceRatio``1(``0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.AverageLogFactor``1(``0,``0)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="value">Incoming message from 'value'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="dist">Constant value for 'dist'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (value,dist)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="value"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.AverageLogFactor``1(`0,``0)">
            <summary>
            Evidence message for VMP.
            </summary>
            <param name="value">Constant value for 'value'.</param>
            <param name="dist">Constant value for 'dist'.</param>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (value,dist)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualRandomOp`1.ValueAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'value'.
            </summary>
            <param name="dist">Constant value for 'dist'.</param>
            <returns>The outgoing VMP message to the 'value' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'value'.
            The formula is <c>int log(f(value,x)) q(x) dx</c> where <c>x = (dist)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.Equal``1(``0,``0)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor``1(``0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="a">Incoming message from 'a'</param>
            <param name="b">Incoming message from 'b'</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor``1(`0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="a">Constant value for 'a'</param>
            <param name="b">Incoming message from 'b'</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogAverageFactor``1(``0,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="a">Incoming message from 'a'</param>
            <param name="b">Constant value for 'b'</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio``1(``0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="a">Incoming message from 'a'</param>
            <param name="b">Incoming message from 'b'</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>
            Evidence message for EP
            </summary>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="a">Constant value for 'a'</param>
            <param name="b">Incoming message from 'b'</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.LogEvidenceRatio``1(``0,`0)">
            <summary>
            Evidence message for EP
            </summary>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="a">Incoming message from 'a'</param>
            <param name="b">Constant value for'b'</param>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'A'.
            </summary>
            <param name="B">Incoming message from 'B'</param>
            <param name="result">Where to put the result</param>
            <returns>The outgoing EP message to the 'A' argument.</returns>
            <remarks><para>
            The outgoing message is just 'B'
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageConditional``1(`0,``0)">
            <summary>
            EP message to 'A'.
            </summary>
            <param name="B">Constant value for 'B'</param>
            <param name="result">Where to put the result</param>
            <returns>The outgoing EP message to the 'A' argument.</returns>
            <remarks><para>
            The outgoing message is just a point distribution at 'B'
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'B'.
            </summary>
            <param name="A">Incoming message from 'A'</param>
            <param name="result">Where to put the result</param>
            <returns>The outgoing EP message to the 'B' argument.</returns>
            <remarks><para>
            The outgoing message is just 'A'
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageConditional``1(`0,``0)">
            <summary>
            EP message to 'B'.
            </summary>
            <param name="A">Constant value for 'A'</param>
            <param name="result">Where to put the result</param>
            <returns>The outgoing EP message to the 'B' argument.</returns>
            <remarks><para>
            The outgoing message is just 'A'
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP. VMP does not support Constrain.Equal between random variables.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'A'. VMP does not support Constrain.Equal between random variables.
            </summary>
            <typeparam name="DistributionType"></typeparam>
            <param name="B"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageLogarithm``1(``0,``0)">
            <summary>
            VMP message to 'B'. VMP does not support Constrain.Equal between random variables.
            </summary>
            <typeparam name="DistributionType"></typeparam>
            <param name="A"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.AAverageLogarithm``1(`0,``0)">
            <summary>
            VMP message to 'A'. VMP does not support Constrain.Equal between random variables.
            </summary>
            <typeparam name="DistributionType"></typeparam>
            <param name="B"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainEqualOp`1.BAverageLogarithm``1(`0,``0)">
            <summary>
            VMP message to 'B'. VMP does not support Constrain.Equal between random variables.
            </summary>
            <typeparam name="DistributionType"></typeparam>
            <param name="A"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainTrueOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.True(System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainTrueOp.BAverageConditional">
            <summary>
            EP message to 'b'.
            </summary>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = ()</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainTrueOp.BAverageLogarithm">
            <summary>
            VMP message to 'b'.
            </summary>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = ()</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainTrueOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainTrueOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainTrueOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstrainFalseOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Constrain.False(System.Boolean)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainFalseOp.BAverageConditional">
            <summary>
            EP message to 'b'.
            </summary>
            <returns>The outgoing EP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int f(b,x) q(x) dx</c> where <c>x = ()</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainFalseOp.BAverageLogarithm">
            <summary>
            VMP message to 'b'.
            </summary>
            <returns>The outgoing VMP message to the 'b' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'b'.
            The formula is <c>int log(f(b,x)) q(x) dx</c> where <c>x = ()</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainFalseOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="b">Incoming message from 'b'.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainFalseOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Bernoulli)">
            <summary>
            Evidence message for EP.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstrainFalseOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (b)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete">
            <summary>
            Represents a discrete distribution which may not be normalized.
            e.g. for holding max marginals which cannot be normalized.
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.logProb">
            <summary>
            Log probability of each value (when not a point mass).
            </summary>
            <remarks>
            logprob.Length == D.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetDomainPrototype">
            <summary>
            The domain of this distribution is the integer interval [0,D-1]. This
            returns 0 as a representative domain value
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Clone">
            <summary>
            Clones this unnormalised discrete distribution. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a UnnormalizedDiscrete type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.FromLogProbs(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates an unnormalized discrete distribution from a vector of log probabilities.
            </summary>
            <param name="logProb"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.FromDiscrete(MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Creates an unnormalized discrete distribution from a normal discrete distribution.
            </summary>
            <param name="d">The discrete distribution</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Uniform(System.Int32)">
            <summary>
            Creates a uniform unnormalized discrete distribution over the values from 0 to numValues-1
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this discrete and that discrete
            </summary>
            <param name="that">That discrete</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetToUniform">
            <summary>
            Sets this instance to a uniform distribution (i.e. probabilities all equal)
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.IsUniform">
            <summary>
            Returns whether the distribution is uniform or not
            </summary>
            <returns>True if uniform</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetLogProb(System.Int32)">
            <summary>
            Evaluates the log of the unnormalized density at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The log unnormalized density</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Evaluate(System.Int32)">
            <summary>
            Evaluates the unnormalized probability at the specified domain value
            </summary>
            <param name="value">The point at which to evaluate</param>
            <returns>The unnormalized probability</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetWorkspace">
            <summary>
            Gets a Vector of size this.Dimension.
            </summary>
            <returns>A pointer to the internal log prob Vector of the object.</returns>
            <remarks>
            This function is intended to be used with SetLogProbs, to avoid allocating a new Vector.
            The return value should not be interpreted as a probs vector, but only a workspace filled
            with unknown data that can be overwritten.  Until SetLogProbs is called, the distribution object 
            is invalid once this workspace is modified.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetLogProbs(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the log probability vector for this distribution.
            </summary>
            <param name="probs">A vector of non-negative, finite numbers.  Need not sum to 1.</param>
            <remarks>
            Instead of allocating your own Vector to pass to SetProbs, you can call <see cref="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetWorkspace"/>,
            fill in the resulting Vector, and then pass it to SetProbs.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetTo(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Sets the parameters of this instance to the parameters of that instance
            </summary>
            <param name="value">That instance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetToProduct(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Sets the parameters to represent the product of two unnormalized discrete distributions.
            </summary>
            <param name="a">The first unnormalized discrete distribution</param>
            <param name="b">The second unnormalized discrete distribution</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.op_Multiply(MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete,MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete)">
            <summary>
            Creates an unnormalized discrete distribution which is the product of two unnormalized discrete distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting unnormalized discrete distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.ToString">
            <summary>
            Override of ToString method
            </summary>
            <returns>String representation of this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.ToString(System.String)">
            <summary>
            Override of ToString method which allows custom number formatting
            </summary>
            <returns>String representation of this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.GetProbs">
            <summary>
            Gets the unnormalized probability vector for this distribution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.SetMaxToZero">
            <summary>
            Rescales the unnormalised distribution, so that the max log prob is zero i.e. the max unnormalised prob is 1.
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Dimension">
            <summary>
            Dimension of the unnormalised discrete distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.Point">
            <summary>
            Sets/gets this distribution as a point distribution
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.UnnormalizedDiscrete.IsPointMass">
            <summary>
            Whether or not this instance is a point mass.
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Poisson">
            <summary>
            A Poisson distribution over the integers [0,infinity).
            </summary>
            <remarks><para>
            The Poisson is often used as a distribution on counts.
            The formula for the distribution is <c>p(x) = rate^x exp(-rate) / x!</c>
            where rate is the rate parameter.
            In this implementation, we use a generalization called the Conway-Maxwell Poisson or "Com-Poisson", which
            has an extra precision parameter nu.  
            The formula for the distribution is <c>p(x) =propto rate^x / x!^nu</c>.
            With this extension, we can represent a uniform distribution via (rate=1,nu=0) and 
            a point mass via rate=0 or nu=infinity.  
            This family is closed under multiplication, while the standard Poisson is not.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Poisson.Rate">
            <summary>
            Rate parameter, always >= 0.
            </summary>
            <remarks>
            The natural parameter of the distribution is log(rate).  
            However, since rate remains >= 0 under multiplication, there
            is no harm in using rate as the parameter.
            </remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Poisson.Precision">
            <summary>
            Precision
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetMean">
            <summary>
            Gets the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetVariance">
            <summary>
            Gets the variance
            </summary>
            <returns>Variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetMeanAndVariance(System.Double@,System.Double@)">
            <summary>
            Gets the mean and variance
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetMeanAndVariance(System.Double,System.Double)">
            <summary>
            Sets the mean and variance
            </summary>
            <param name="mean">Mean</param>
            <param name="variance">Variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetDomainPrototype">
            <summary>
            Gets a domain prototype. The domain for Poisson distribution is
            the integers [0,infinity), so a value of 0 is returned.
            </summary>
            <returns>0</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Clone">
            <summary>
            Clones this Poisson. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Poisson type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Poisson
            and that Poisson
            </summary>
            <param name="that">That Poisson</param>
            <returns>The maximum difference</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToUniform">
            <summary>
            Sets this Poisson instance to be a uniform distribution
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.IsUniform">
            <summary>
            Asks whether this instance is uniform
            </summary>
            <returns>True if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.IsProper">
            <summary>
            Asks whether this instance is proper or not. A Poisson distribution
            is proper if Rate >= 0 and (Precision > 0 or (Precision == 0 and Rate &lt; 1)).
            </summary>
            <returns>True if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogProb(System.Int32)">
            <summary>
            Evaluates the log of a Poisson density function at the given value
            </summary>
            <param name="value">The value at which to calculate the density</param>
            <returns>log p(x=value)</returns>
            <remarks>
            The formula for the distribution is <c>p(x) = rate^x exp(-rate) / x!</c>
            when nu=1.  In the general case, it is <c>p(x) =propto rate^x / x!^nu</c>.
            If the distribution is improper, the normalizer is omitted.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetTo(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Sets this Poisson instance to have the parameter values of that Poisson instance
            </summary>
            <param name="value">That Poisson</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToProduct(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Sets the parameters to represent the product of two Poissons.
            </summary>
            <param name="a">The first Poisson</param>
            <param name="b">The second Poisson</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_Multiply(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Creates a new Poisson which is the product of two other Poisson
            </summary>
            <param name="a">First Poisson</param>
            <param name="b">Second Poisson</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToRatio(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Sets the parameters to represent the ratio of two distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <remarks>
            The result may not be proper. No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_Division(MicrosoftResearch.Infer.Distributions.Poisson,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Creates a new Gaussian which is the ratio of two other distributions
            </summary>
            <param name="numerator">numerator distribution</param>
            <param name="denominator">denominator distribution</param>
            <returns>Result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToPower(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>
            Sets the parameters to represent the power of a source Poisson to some exponent.
            </summary>
            <param name="dist">The source Poisson</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Poisson,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Poisson,System.Double,MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            A weighted mixture of two Poissons - not yet implemented
            </summary>
            <param name="weight1"></param>
            <param name="value1"></param>
            <param name="weight2"></param>
            <param name="value2"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Gets the integral of the product of two Poissons - not yet implemented.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetAverageLog(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Gets the expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetSumLogFactorial(System.Double,System.Double)">
            <summary>
            Computes sum_{x=0..infinity} log(x!) lambda^x / x!^nu
            </summary>
            <param name="lambda"></param>
            <param name="nu"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogNormalizer(System.Double,System.Double)">
            <summary>
            Computes log(sum_{x=0..infinity} lambda^x / x!^nu)
            </summary>
            <param name="lambda"></param>
            <param name="nu"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.GetLogPowerSum(System.Double,System.Double,System.Double)">
            <summary>
            Computes log(sum_{x=0..infinity} x^p lambda^x / x!^nu)
            </summary>
            <param name="lambda"></param>
            <param name="nu"></param>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample">
            <summary>
            Samples from a Poisson - not yet implemented.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample(System.Int32)">
            <summary>
            Samples from a Poisson - use <see cref="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample"/> instead
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Sample(System.Double)">
            <summary>
            Samples from a Poisson distribution with given mean - not yet implemented
            </summary>
            <param name="mean">Mean</param>
            <returns>An integer in [0,infinity)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.#ctor(System.Double)">
            <summary>
            Creates a Poisson distribution with the given mean.
            </summary>
            <param name="mean"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.#ctor(System.Double,System.Double)">
            <summary>
            Create a Com-Poisson distribution with the given rate and precision.
            </summary>
            <param name="rate"></param>
            <param name="precision"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.#ctor(MicrosoftResearch.Infer.Distributions.Poisson)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.Uniform">
            <summary>
            Instantiates a uniform Com-Poisson distribution
            </summary>
            <returns>A new uniform Com-Poisson distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.PointMass(System.Int32)">
            <summary>
            Creates a Com-Poisson distribution which only allows one value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Poisson.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Poisson.Point">
            <summary>
            Sets/gets the instance as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Poisson.IsPointMass">
            <summary>
            Asks whether the instance is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel">
            <summary>
            Neural Net kernel
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.SetupParams(System.Double[],System.Double)">
            <summary>
            Sets up names and values of parameters
            </summary>
            <param name="logWeightVariances">Log weight variances</param>
            <param name="logBiasWeightVariance">Log bias weight variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.GetLogWeightVariances">
            <summary>
            Gets the log weight variances from this Neural Net kernal instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.GetLogBiasWeightVariance">
            <summary>
            Gets the log bias variances from this Neural Net kernal instance
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.#ctor(System.Double[],System.Double)">
            <summary>
            Constructs an neural net kernel from vector of log lweight variances
            </summary>
            <param name="logWeightVariances">Log weight variances</param>
            <param name="logBiasWeightVariance">Log bias weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.InitialiseFromData(System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Initialises the parameters from data
            </summary>
            <param name="X">X data - initialises weight variances</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.EvaluateX1X2(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a pair of vectors
            </summary>
            <param name="x1">First vector</param>
            <param name="x2">Second vector</param>
            <param name="x1Deriv">Derivative of the kernel value with respect to x1 input vector</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.EvaluateX(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector@,MicrosoftResearch.Infer.Maths.Vector@)">
            <summary>
            Evaluates the kernel for a single vector (which is used for both slots)
            </summary>
            <param name="x">Vector</param>
            <param name="xDeriv">Derivative of the kernel value with respect to x</param>
            <param name="logThetaDeriv">Derivative of the kernel value with respect to the log hyper-parameters</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.Read(System.IO.StreamReader)">
            <summary>
            Reads the parameters in from a stream
            </summary>
            <param name="sr">Stream reader</param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.Item(System.Int32)">
            <summary>
            Sets or gets a log hyper-parameter by index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Kernels.NNKernel.TypeVersion">
            <summary>
            The static version for the derived class
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SampleList`1">
            <summary>
            Sample List
            </summary>
            <typeparam name="T">Domain type for sample list</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SampleList`1.Add(`0)">
            <summary>
            Add a sample to the sample list
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SampleList`1.Clear">
            <summary>
            Clears out all the samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SampleList`1.Samples">
            <summary>
            Samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SampleList`1.Count">
            <summary>
            Sample count - thinned samples after burn-in is consumed
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.ConditionalList`1">
            <summary>
            Conditional List
            </summary>
            <typeparam name="TDist">Distribution type for conditional list</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConditionalList`1.Add(`0)">
            <summary>
            Add a sample to the sample list
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.ConditionalList`1.Clear">
            <summary>
            Clears out all the samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConditionalList`1.Conditionals">
            <summary>
            Samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.ConditionalList`1.Count">
            <summary>
            Sample count - thinned samples after burn-in is consumed
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2">
            <summary>
            Gibbs marginal - wraps underlying estimator, provides burn-in and thinning,
            and maintains thinned samples and conditionals
            </summary>
            <typeparam name="TDist">The distribution type</typeparam>
            <typeparam name="T">The domain type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.#ctor(`0,System.Int32,System.Int32)">
            <summary>
            Constructor from a distribution prototype, and burn in and thin parameters
            </summary>
            <param name="distPrototype">Prototype distribution</param>
            <param name="burnIn">Burn in - number of sample discarded initially</param>
            <param name="thin">Thinning parameter - only every 'thin' samples returned</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.#ctor(MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1})">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
            <remarks>This does a soft copy of the estimator and sample and conditional lists</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Clear">
            <summary>
            Clears out all the samples and clears the accumulators
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.GetDistribution(`0)">
            <summary>
            Get the estimated distribution from the samples
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Add(`1)">
            <summary>
            Add a sample to the accumulator
            </summary>
            <param name="sample"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.AddConditional(`0)">
            <summary>
            Add a conditional to the accumulator
            </summary>
            <param name="conditional"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.GetDomainPrototype">
            <summary>
            Get domain prototype
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Clone">
            <summary>
            Clone
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.MaxDiff(System.Object)">
            <summary>
            Max difference between this Gibbs Marginal and that
            </summary>
            <param name="that"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetToUniform">
            <summary>
            Set to uniform. This just clears everything
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.IsUniform">
            <summary>
            This returns true only if the LastConditional is uniform.
            The estimated distrubution may still be Uniform.
            This distinction is important because this property is
            used to generate and/or call operators, and the operators
            make use of LastSample, and LastConditional
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.GetLogProb(`1)">
            <summary>
            Get log probability at the specified value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.DrawSample">
            <summary>
            Returns a sample from the last conditional
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.DrawSample(`1)">
            <summary>
            Returns a sample from the last conditional
            </summary>
            <param name="result">Where to put the result if T is a reference type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Sample">
            <summary>
            Returns the last sample
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Sample(`1)">
            <summary>
            Returns the last sample
            </summary>
            <param name="result">Where to put the result if T is a reference type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.PostUpdate">
            <summary>
            Perform an update by adding a sample from the last conditional
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetTo(MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1})">
            <summary>
            Set this distribution to that
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetTo(`0)">
            <summary>
            Set this distribution to that
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetTo(MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Set this distribution to that
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetToProduct(`0,`0)">
            <summary>
            Set to a product of two distributions
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetToProduct(MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1},`0)">
            <summary>
            Set to a product of two distributions
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetToProduct(MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1},MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1})">
            <summary>
            Set to a product of two distributions
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetToProduct(MicrosoftResearch.Infer.Distributions.IDistribution{`1},MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Set to a product of two distributions
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetToRatio(`0,`0)">
            <summary>
            Set to a ratio of two distributions
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetToRatio(MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1},`0)">
            <summary>
            Set to a ratio of two distributions
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetToRatio(MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1},MicrosoftResearch.Infer.Distributions.GibbsMarginal{`0,`1})">
            <summary>
            Set to a ratio of two distributions
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetToRatio(MicrosoftResearch.Infer.Distributions.IDistribution{`1},MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Set to a ratio of two distributions
            </summary>
            <param name="a"></param>
            <param name="b"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.MultiplyIntoTarget(`0,`0)">
            <summary>
            Multiply this instance with another instance and set the target
            </summary>
            <param name="target"></param>
            <param name="other"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.MultiplyIntoTarget(MicrosoftResearch.Infer.Distributions.IDistribution{`1},MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Multiply this instance with another instance and set the target
            </summary>
            <param name="target"></param>
            <param name="other"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetTarget(`0)">
            <summary>
            Set the target distribution. As this may be a struct, the
            target is returned
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SetTarget(MicrosoftResearch.Infer.Distributions.IDistribution{`1})">
            <summary>
            Set the target distribution. As this may be a struct, the
            target is returned
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.ToString">
            <summary>
            Shows the GibbsMarginal in string form
            </summary>
            <returns></returns>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.LeafDistributionType">
            <summary>
            Leaf distribution type
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.LeafDomainType">
            <summary>
            Leaf domain type
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SampleWorkspace">
            <summary>
            Sample workspace
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Estimator">
            <summary>
            The embedded estimator
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.DistributionPrototype">
            <summary>
            Distribution prototype used to create this instance
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.BurnIn">
            <summary>
            The number of samples to discard at the beginning
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Thin">
            <summary>
            Reduction factor when constructing sample lists
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Samples">
            <summary>
            Thinned samples
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.LastSample">
            <summary>
            Last sample added. If no samples, returns domain prototype
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Conditionals">
            <summary>
            Thinned conditionals
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.LastConditional">
            <summary>
            Last conditional distribution added. If no conditionals, returns uniform
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.SampleCount">
            <summary>
            Sample count - thinned samples after burn-in is consumed
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.ConditionalCount">
            <summary>
            Sample count - thinned samples after burn-in is consumed
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Distribution">
            <summary>
            The marginal
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.Point">
            <summary>
            Gets/sets the GibbsMarginal instance as a point mass. If set, all
            samples are cleared, and the value is added as a single sample
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.GibbsMarginal`2.IsPointMass">
            <summary>
            Returns true if a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.SparseGPFixed">
            <summary>
            This class maintains all the fixed parameters for a sparse GP
            - i.e. parameters which the inference does not change.
            All SparseGP messages can refer to a single SparseGPFixed
            class, and cloning of SparseGP instances will just copy the
            reference
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.mean0">
            <summary>
            Field for Mean0 property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.kernel">
            <summary>
            Field for Kernel property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.basis">
            <summary>
            Field for basis property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.kBB">
            <summary>
            Field for calculated KernelOf_B_B property
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.SparseGPFixed.invKBB">
            <summary>
            Field for calculated InvKernelOf_B_B property
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.FlagRecalculate">
            <summary>
            Function to signal recalculation of KBB and InvKBB.
            This is be called by the basis and kernel
            function property set functions, and should
            also be called by any external program
            which directly modifies the kernel
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.Recalculate">
            <summary>
            Function to recalulate KBB and InvKBB
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.SparseGPFixed.#ctor(MicrosoftResearch.Infer.Distributions.Kernels.IKernelFunction,System.Collections.Generic.IList{MicrosoftResearch.Infer.Maths.Vector})">
            <summary>
            Constructor from kernel function and basis
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.Mean0">
            <summary>
            Prior mean
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.Kernel">
            <summary>
            Kernel function
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.Basis">
            <summary>
            List of basis vectors
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.KernelOf_B_B">
            <summary>
            Kernel evaluated at the basis points
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.InvKernelOf_B_B">
            <summary>
            Inverse of the kernel evaluated at the basis points
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.NumberFeatures">
            <summary>
            Number of features - i.e. the dimension of the
            GP index space
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.SparseGPFixed.NumberBasisPoints">
            <summary>
            Number of basis points
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Distributions.Dirichlet">
            <summary>
            A Dirichlet distribution on probability vectors.
            </summary>
            <remarks><para>
            The Dirichlet is a distribution on probability vectors.
            The formula for the distribution is p(x) = (Gamma(a)/prod_i Gamma(b_i)) prod_i x_i^{b_i-1}
            subject to the constraints x_i >= 0 and sum_i x_i = 1.
            The parameter a is the "total pseudo-count" and is shorthand for sum_i b_i.
            The vector b is the pseudo-count of case i.
            </para><para>
            The distribution is represented by the pair (TotalCount, PseudoCount).
            If TotalCount is infinity, the distribution is a point mass.  The Point property gives the mean.
            Otherwise TotalCount is always equal to PseudoCount.Sum().
            If distribution is uniform when all PseudoCounts = 1.
            If any PseudoCount &lt;= 0, the distribution is improper.
            In this case, the density is redefined to not include the Gamma terms, i.e.
            there is no normalizer.
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Dirichlet.TotalCount">
            <summary>
            Total count - if infinite, the distribution is a point mass.
            Otherwise, this is the sum of pseudo-counts
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Dirichlet.PseudoCount">
            <summary>
            Vector of pseudo-counts
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.IsProper">
            <summary>
            Whether the the distribution is proprer or not.
            It is proper if all pseudo-counts are > 0.
            </summary>
            <returns>true if proper, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMean">
            <summary>
            Gets the expected value E(x)
            </summary>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMean(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the expected value E(x). Provide a vector to put the result
            </summary>
            <param name="result">Where to put E(x)</param>
            <returns>E(x)</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanLog">
            <summary>
            Gets the expected log value E(log(x))
            </summary>
            <returns>E(log(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanLog(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the expected log value E(log(x)). Provide a vector to put the result
            </summary>
            <param name="result">Where to put E(log(x))</param>
            <returns>E(log(x))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanLogAt(System.Int32)">
            <summary>
            E[log prob[sample]]
            </summary>
            <param name="sample">a dimension of prob of interest</param>
            <returns>E[log prob[sample]]</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanSquare">
            <summary>
            Computes E[p(x)^2] for each x.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanCube">
            <summary>
            Computes E[p(x)^3] for each x.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetVariance">
            <summary>
            Gets the variance var(p) = m*(1-m)/(1+s)
            </summary>
            <returns>The variance</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Gets the mean E(p) = m/s and variance var(p) = m*(1-m)/(1+s)
            </summary>
            <param name="mean">Where to put the mean</param>
            <param name="variance">Where to put the variance</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetMeanAndMeanSquare(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the mean, and sets the precision to best match the given mean-squares.
            </summary>
            <param name="mean">Desired mean in each dimension.  Must be in [0,1] and sum to 1.</param>
            <param name="meanSquare">Desired meanSquare in each dimension.  Must be in [0,1].</param>
            <remarks>
            The resulting distribution will have the given mean but will only approximately match
            the meanSquare, since the Dirichlet does not have enough parameters.  The moment matching
            formula comes from:
            "Expectation-Propagation for the Generative Aspect Model",
            Thomas Minka and John Lafferty,
            Proceedings of the 18th Conference on Uncertainty in Artificial Intelligence, pp. 352-359, 2002
            http://research.microsoft.com/~minka/papers/aspect/
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetMeanAndVariance(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Sets the mean, and sets the precision to best match the given variances.
            </summary>
            <param name="mean">Desired mean in each dimension.  Must be in [0,1] and sum to 1.</param>
            <param name="variance">Desired variance in each dimension.  Must be non-negative.</param>
            <remarks>
            The resulting distribution will have the given mean but will only approximately match
            the variance, since the Dirichlet does not have enough parameters.  The moment matching
            formula comes from:
            "Expectation-Propagation for the Generative Aspect Model",
            Thomas Minka and John Lafferty,
            Proceedings of the 18th Conference on Uncertainty in Artificial Intelligence, pp. 352-359, 2002
            http://research.microsoft.com/~minka/papers/aspect/
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.FromMeanLog(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Create a Dirichlet distribution with the given expected logarithms.
            </summary>
            <param name="meanLog">Desired expectation E[log(pk)] for each k.</param>
            <returns>A new Dirichlet where GetMeanLog == meanLog</returns>
            <remarks>
            This function is equivalent to maximum-likelihood estimation of a Dirichlet distribution
            from data given by sufficient statistics. 
            This function is significantly slower than the other constructors since it
            involves nonlinear optimization.
            Uses the Newton algorithm described in "Estimating a Dirichlet distribution" by T. Minka, 2000.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetMeanLog(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Set the Dirichlet parameters to produce the given expected logarithms.
            </summary>
            <param name="meanLog">Desired expectation E[log(pk)] for each k.</param>
            <remarks>
            This function is equivalent to maximum-likelihood estimation of a Dirichlet distribution
            from data given by sufficient statistics. 
            This function is significantly slower than the other setters since it
            involves nonlinear optimization.
            Uses the Newton algorithm described in "Estimating a Dirichlet distribution" by T. Minka, 2000.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.EstimateNewton(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Modifies PseudoCount to produce the given expected logarithms.
            </summary>
            <param name="PseudoCount">On input, the initial guess.  On output, the converged solution.</param>
            <param name="meanLog">May be -infinity.</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetDomainPrototype">
            <summary>
            Gets a prototype from the distributions domain
            </summary>
            <returns>The zero Vector of the correct dimension</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Clone">
            <summary>
            Clones this Dirichlet. 
            </summary>
            <returns>An object which is a clone of the current instance. This must be cast
            if you want to assign the result to a Dirichlet type</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.MaxDiff(System.Object)">
            <summary>
            The maximum difference between the parameters of this Dirichlet
            and that Dirichlet
            </summary>
            <param name="that">That Dirichlet</param>
            <returns>The maximum difference</returns>
            <remarks><c>a.MaxDiff(b) == b.MaxDiff(a)</c></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Equals(System.Object)">
            <summary>
            Override of the Equals method
            </summary>
            <param name="thatd">The instance to compare to</param>
            <returns>True if the two distributions are the same in value, false otherwise</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetHashCode">
            <summary>
            Override of GetHashCode method
            </summary>
            <returns>The hash code for this instance</returns>
            <exclude/>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogProb(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Evaluates the log of the Dirichlet density function at the given Vector value
            </summary>
            <param name="value">Where to do the evaluation. Must be vector of positive real numbers</param>
            <returns>log(Dir(value;a,b))</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogNormalizer">
            <summary>
            Gets the log normalizer for the distribution
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.DirichletLn(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Computes the log Dirichlet function: <c>sum_i GammaLn(pseudoCount[i]) - GammaLn(sum_i pseudoCount[i])</c>
            </summary>
            <param name="pseudoCount">Vector of pseudo-counts.</param>
            <returns><c>sum_i GammaLn(pseudoCount[i]) - GammaLn(sum_i pseudoCount[i])</c></returns>
            <remarks>
            If any pseudoCount &lt;= 0, the result is defined to be 0.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetAverageLog(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            The expected logarithm of that distribution under this distribution.
            </summary>
            <param name="that">The distribution to take the logarithm of.</param>
            <returns><c>sum_x this.Evaluate(x)*Math.Log(that.Evaluate(x))</c></returns>
            <remarks>This is also known as the cross entropy.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetTo(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Sets this Dirichlet instance to have the parameter values of another Dirichlet instance
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToProduct(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Sets the parameters to represent the product of two Dirichlets.
            </summary>
            <param name="a">The first Dirichlet</param>
            <param name="b">The second Dirichlet</param>
            <remarks>
            The result may not be proper, i.e. its parameters may be negative.
            For example, if you multiply Dirichlet(0.1,0.1) by itself you get Dirichlet(-0.8, -0.8).
            No error is thrown in this case.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.op_Multiply(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Creates a Dirichlet distribution which is the product of two Dirichlet distributions
            </summary>
            <param name="a">The first distribution</param>
            <param name="b">The second distribution</param>
            <returns>The resulting Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToRatio(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Sets the parameters to represent the ratio of two Dirichlets.
            </summary>
            <param name="numerator">The numerator Dirichlet</param>
            <param name="denominator">The denominator Dirichlet</param>
            <remarks>
            The result may not be proper, i.e. its parameters may be negative.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.op_Division(MicrosoftResearch.Infer.Distributions.Dirichlet,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Creates a Dirichlet distribution which is the ratio of two Dirichlet distributions
            </summary>
            <param name="numerator">The numerator distribution</param>
            <param name="denominator">The denominator distribution</param>
            <returns>The resulting Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToPower(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Sets the parameters to represent the raising a Dirichlet to some power.
            </summary>
            <param name="dist">The Dirichlet</param>
            <param name="exponent">The exponent</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.op_ExclusiveOr(MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double)">
            <summary>
            Raises a distribution to a power.
            </summary>
            <param name="dist">The distribution.</param>
            <param name="exponent">The power to raise to.</param>
            <returns><paramref name="dist"/> raised to power <paramref name="exponent"/>.</returns>
        </member>
        <member name="F:MicrosoftResearch.Infer.Distributions.Dirichlet.AllowImproperSum">
            <summary>
            Flag to allow improper sum
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToSum(System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet,System.Double,MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Sets the parameters to represent the weighted sum of two Dirichlets.
            </summary>
            <param name="dist1">The first Dirichlet</param>
            <param name="weight1">The first weight</param>
            <param name="dist2">The second Dirichlet</param>
            <param name="weight2">The second weight</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.WeightedSum``1(``0,System.Int32,System.Double,``0,System.Double,``0)">
            <summary>
            Static weighted sum method for distribution types for which both mean and variance
            can be got/set as Vectors
            </summary>
            <typeparam name="T">The distribution type</typeparam>
            <param name="result">The resulting distribution</param>
            <param name="dimension">The vector dimension</param>
            <param name="weight1">First weight</param>
            <param name="dist1">First distribution instance</param>
            <param name="weight2">Second weight</param>
            <param name="dist2">Second distribution instance</param>
            <returns>Resulting distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.SetToUniform">
            <summary>
            Sets the distribution to be uniform
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.IsUniform">
            <summary>
            Whether this instance is uniform (i.e. has unit pseudo-counts)
            </summary>
            <returns>true if uniform, false otherwise</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.GetLogAverageOf(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            The log of the integral of the product of this Dirichlet and that Dirichlet
            </summary>
            <param name="that">That Dirichlet</param>
            <returns>The log inner product</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Sample">
            <summary>
            Samples from this Dirichlet distribution
            </summary>
            <returns>The sample Vector</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Sample(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Samples from this Dirichlet distribution. Provide a Vector to place the result
            </summary>
            <param name="result">Where to place the resulting sample</param>
            <returns>result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Sample(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Static method to return a sample from a Dirichlet with specified pseudo-counts
            </summary>
            <param name="pseudoCount">The pseudo-count vector</param>
            <param name="result">Where to put the result</param>
            <returns>result</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Int32)">
            <summary>
            Creates a uniform Dirichlet distribution with unit pseudo-counts.
            </summary>
            <param name="dimension"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Int32,System.Double)">
            <summary>
            Creates a uniform Dirichlet distribution with the specified pseudo-counts.
            </summary>
            <param name="dimension"></param>
            <param name="initialCount"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a Dirichlet distribution with the specified pseudo-counts.
            </summary>
            <param name="pseudoCount">The vector of pseudo-counts</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(System.Double[])">
            <summary>
            Creates a Dirichlet distribution with the psecified pseudo-counts
            </summary>
            <param name="pseudoCount">An array of pseudo-counts</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.#ctor(MicrosoftResearch.Infer.Distributions.Dirichlet)">
            <summary>
            Copy constructor.
            </summary>
            <param name="that"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.PointMass(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Creates a point-mass Dirichlet at the specified location
            </summary>
            <param name="mean">Where to locate the point-mass. All elements of the Vector must be positive</param>
            <returns>The created point mass Dirichlet</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Uniform(System.Int32)">
            <summary>
            Instantiates a uniform Dirichlet distribution
            </summary>
            <param name="dimension">Dimension</param>
            <returns>A new uniform Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.Uniform(System.Int32,System.Double)">
            <summary>
            Creates a Dirichlet distribution with all pseudo-counts equal to initialCount.
            </summary>
            <param name="dimension">Dimension</param>
            <param name="initialCount">The value for all pseudo-counts</param>
            <returns>A new Dirichlet distribution</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.PointMass(System.Double[])">
            <summary>
            Creates a point-mass Dirichlet at the specified location
            </summary>
            <param name="mean">Where to locate the point-mass. All elements of the array must be positive</param>
            <returns>The created point mass Dirichlet</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Distributions.Dirichlet.ToString">
            <summary>
            ToString override
            </summary>
            <returns>String representation of the instance</returns>
            <exclude/>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Dimension">
            <summary>
            Vector dimension
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.Point">
            <summary>
            Sets/gets this distribution as a point mass
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Distributions.Dirichlet.IsPointMass">
            <summary>
            Whether this Dirichlet is a point mass
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.LuDecomposition">
            <summary>
            Class for calculating and doing operations with an LU decomposition
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.LuDecomposition.LU">
            <summary>
            The matrix
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new LUDecomposition class with a given number of rows and columns
            </summary>
            <param name="nRows">Number of rows</param>
            <param name="nCols">Number of columns</param>
            <remarks><para>
            Currently this only supports square matrices
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.#ctor(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Constructs an LUDecopmosition class, and performs the decomposition on the given matrix.
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.InPlace(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Creates performs and returns an LUDecomposition on a given matrix.
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Decompose(MicrosoftResearch.Infer.Maths.Matrix)">
            <summary>
            Decomposes the matrix A
            </summary>
            <param name="A"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Decompose">
            <summary>
            Performs the decomposition for this instance
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Determinant">
            <summary>
            Returns the determinant of the given instance. The
            decomposition is assumed to have been performed
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.LuDecomposition.Solve(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Solves Ay = x for x
            </summary>
            <param name="x"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.UnaryOp`1">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Random``1(MicrosoftResearch.Infer.Distributions.Sampleable{``0})"/>, given random arguments to the function.
            </summary>
            <typeparam name="DomainType">Domain type</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogAverageFactor``1(``0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Incoming message from 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogAverageFactor``1(`0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Constant value for 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogEvidenceRatio``1(``0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Incoming message from 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.LogEvidenceRatio``1(`0,``0)">
            <summary>
            Evidence message for EP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Constant value for 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.RandomAverageConditional``1(``0)">
            <summary>
            EP message to 'random'.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="dist">Incoming message from 'dist'</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.AverageLogFactor``1(``0,``0)">
            <summary>
            Evidence message for VMP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Incoming message from 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.AverageLogFactor``1(`0,``0)">
            <summary>
            Evidence message for VMP.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="random">Constant value for 'random'</param>
            <param name="dist">Incoming message from 'dist'</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.RandomAverageLogarithm``1(``0)">
            <summary>
            VMP message to 'random'.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="dist">Incoming message from 'dist'</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.UnaryOp`1.RandomMaxConditional``2(``0,``1)">
            <summary>
            Max product message to 'random'.
            </summary>
            <typeparam name="T">Distribution type</typeparam>
            <param name="dist">Incoming message from 'dist'</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ConstantOp`1">
            <summary>
            Provides outgoing messages for <see cref="!:Factor.Constant&lt;DomainType&gt;"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstantOp`1.LogEvidenceRatio">
            <summary>
            Evidence message for EP.
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstantOp`1.ConstantAverageConditional``1(`0,``0)">
            <summary>
            EP message to 'constant'
            </summary>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="value">Constant value</param>
            <param name="result">Where to put result</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstantOp`1.AverageLogFactor">
            <summary>
            Evidence message for VMP
            </summary>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ConstantOp`1.ConstantAverageLogarithm``1(`0,``0)">
            <summary>
            VMP message to 'constant'
            </summary>
            <typeparam name="DistributionType">Distribution type</typeparam>
            <param name="value">Constant value</param>
            <param name="result">Where to put result</param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.FastSumOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.Factor.Sum(System.Collections.Generic.IList{System.Double})"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogAverageFactor(MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sum,array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogAverageFactor(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx)</c>
            where <c>x = (sum,array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogEvidenceRatio(MicrosoftResearch.Infer.Distributions.Gaussian)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (sum,array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.LogEvidenceRatio(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (sum,array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.SumAverageConditional(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            EP message to 'sum'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing EP message to the 'sum' argument.</returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'sum'.
            The formula is <c>int f(sum,x) q(x) dx</c> where <c>x = (array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageConditional``1(MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int f(array,x) q(x) dx</c> where <c>x = (sum)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageConditional``1(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            EP message to 'array'.
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int f(array,x) q(x) dx</c> where <c>x = (sum)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.SumAverageLogarithm(System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian})">
            <summary>
            VMP message to 'sum'.
            </summary>
            <param name="array">Incoming message from 'array'. Must be a proper distribution.  If any element is uniform, the result will be uniform.</param>
            <returns>The outgoing VMP message to the 'sum' argument.</returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'sum'.
            The formula is <c>int log(f(sum,x)) q(x) dx</c> where <c>x = (array)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="array"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageLogarithm``1(MicrosoftResearch.Infer.Distributions.Gaussian,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="sum">Incoming message from 'sum'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int log(f(array,x)) q(x) dx</c> where <c>x = (sum)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="sum"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.ArrayAverageLogarithm``1(System.Double,System.Collections.Generic.IList{MicrosoftResearch.Infer.Distributions.Gaussian},``0)">
            <summary>
            VMP message to 'array'.
            </summary>
            <param name="sum">Constant value for 'sum'.</param>
            <param name="array">Incoming message from 'array'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the exponential of the integral of the log-factor times incoming messages, over all arguments except 'array'.
            The formula is <c>int log(f(array,x)) q(x) dx</c> where <c>x = (sum)</c>.
            </para></remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.FastSumOp.AverageLogFactor">
            <summary>
            Evidence message for VMP.
            </summary>
            <returns><c>sum_x marginal(x)*log(factor(x))</c></returns>
            <remarks><para>
            The formula for the result is <c>int log(f(x)) q(x) dx</c>
            where <c>x = (sum,array)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ShiftAlpha">
            <summary>
            Factors that change a message channel's alpha factor
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.ToFactor``1(``0,System.Double,System.Double)">
            <summary>
            Changes a message channel's alpha value, going to a factor.
            </summary>
            <typeparam name="T">The domain type.</typeparam>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.FromFactor``1(``0,System.Double,System.Double)">
            <summary>
            Changes a message channel's alpha value, coming from a factor.
            </summary>
            <typeparam name="T">The domain type.</typeparam>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.ToFactor``1(``0,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp.FactorAverageConditional``1(``0,``0,System.Double,System.Double,``0)">
            <summary>
            EP message to 'factor'.
            </summary>
            <param name="factor">Incoming message from 'factor'.</param>
            <param name="variable">Incoming message from 'variable'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="variableAlpha">Constant value for 'variableAlpha'.</param>
            <param name="factorAlpha">Constant value for 'factorAlpha'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'factor'.
            The formula is <c>int f(factor,x) q(x) dx</c> where <c>x = (variable,variableAlpha,factorAlpha)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variable"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp.VariableAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'variable'.
            </summary>
            <param name="factor">Incoming message from 'factor'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'variable'.
            The formula is <c>int f(variable,x) q(x) dx</c> where <c>x = (factor,variableAlpha,factorAlpha)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="factor"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaToFactorOp.LogEvidenceRatioOld``1(``0,``0,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="factor">Incoming message from 'factor'.</param>
            <param name="variable">Incoming message from 'variable'.</param>
            <param name="variableAlpha">Constant value for 'variableAlpha'.</param>
            <param name="factorAlpha">Constant value for 'factorAlpha'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (factor,variable,variableAlpha,factorAlpha)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp">
            <summary>
            Provides outgoing messages for <see cref="M:MicrosoftResearch.Infer.Factors.ShiftAlpha.FromFactor``1(``0,System.Double,System.Double)"/>, given random arguments to the function.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp.FactorAverageConditional``1(``0,``0,System.Double,System.Double,``0)">
            <summary>
            EP message to 'factor'.
            </summary>
            <param name="factor">Incoming message from 'factor'.</param>
            <param name="variable">Incoming message from 'variable'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="factorAlpha">Constant value for 'factorAlpha'.</param>
            <param name="variableAlpha">Constant value for 'variableAlpha'.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'factor'.
            The formula is <c>int f(factor,x) q(x) dx</c> where <c>x = (variable,factorAlpha,variableAlpha)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="variable"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp.VariableAverageConditional``1(``0,``0)">
            <summary>
            EP message to 'variable'.
            </summary>
            <param name="factor">Incoming message from 'factor'. Must be a proper distribution.  If uniform, the result will be uniform.</param>
            <param name="result">Modified to contain the outgoing message.</param>
            <returns><paramref name="result"/></returns>
            <remarks><para>
            The outgoing message is the integral of the factor times incoming messages, over all arguments except 'variable'.
            The formula is <c>int f(variable,x) q(x) dx</c> where <c>x = (factor,factorAlpha,variableAlpha)</c>.
            </para></remarks>
            <exception cref="T:MicrosoftResearch.Infer.Factors.ImproperMessageException"><paramref name="factor"/> is not a proper distribution</exception>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.ShiftAlphaFromFactorOp.LogEvidenceRatioOld``1(``0,``0,System.Double,System.Double)">
            <summary>
            Evidence message for EP.
            </summary>
            <param name="factor">Incoming message from 'factor'.</param>
            <param name="variable">Incoming message from 'variable'.</param>
            <param name="variableAlpha">Constant value for 'variableAlpha'.</param>
            <param name="factorAlpha">Constant value for 'factorAlpha'.</param>
            <returns><c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c></returns>
            <remarks><para>
            The formula for the result is <c>log(int f(x) qnotf(x) dx / int ftilde(x) qnotf(x) dx)</c>
            where <c>x = (variable,factor,factorAlpha,variableAlpha)</c>.
            </para></remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Factors.IsGreaterThanOp">
            <summary>
            Implements the constraint IsGreaterThan = (A > B).
            </summary>
            <remarks>A and B need not have the same dimension.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.IsGreaterThanAverageConditional(MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Compute the probability that A > B.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.AAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Compute the BP message to A.
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Factors.IsGreaterThanOp.BAverageConditional(MicrosoftResearch.Infer.Distributions.Bernoulli,MicrosoftResearch.Infer.Distributions.Discrete,MicrosoftResearch.Infer.Distributions.Discrete)">
            <summary>
            Compute the BP message to B.
            </summary>
            <param name="result"></param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator">
            <summary>
            Class for accumulating weighted noisy vector observations,
            and computing sample count, mean vector, and covariance matrix
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.diff">
            <summary>
            Temporary workspace
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.diff2">
            <summary>
            Temporary workspace
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.outer">
            <summary>
            Temporary workspace
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Vector)">
            <summary>
            Adds an observation 
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Vector,System.Double)">
            <summary>
            Adds a weighted observation.
            </summary>
            <param name="x"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Add(MicrosoftResearch.Infer.Maths.Vector,MicrosoftResearch.Infer.Maths.PositiveDefiniteMatrix,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.#ctor(System.Int32)">
            <summary>
            Constructs an accumulator for vector observations
            </summary>
            <param name="dimension"></param>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Count">
            <summary>
            Count
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Mean">
            <summary>
            Mean
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Variance">
            <summary>
            Covariance
            </summary>
        </member>
        <member name="P:MicrosoftResearch.Infer.Maths.VectorMeanVarianceAccumulator.Dimension">
            <summary>
            The dimensionality of the vector
            </summary>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.SortedSet`1">
            <summary>
            A sorted collection of unique items.
            </summary>
            <typeparam name="T">The item type.</typeparam>
            <remarks>
            A sorted collection of items, all of which are different according
            to Equals.  null items are not allowed.  Adding a duplicate has no effect.
            Union, intersection, and superset are all supported via operator overloading.
            The items are stored in the keys of a SortedList, which does the sorting
            via its own comparer function.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.Contains(System.Collections.Generic.IList{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>result[i] is true iff the set contains list[i].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.ContainsAny(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>true if the set contains any item in list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Collections.SortedSet{`0},MicrosoftResearch.Infer.Collections.SortedSet{`0})">
            <summary>
            Superset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a superset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.SortedSet`1.op_LessThanOrEqual(MicrosoftResearch.Infer.Collections.SortedSet{`0},MicrosoftResearch.Infer.Collections.SortedSet{`0})">
            <summary>
            Subset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a subset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.Set`1">
            <summary>
            A collection of unique items.
            </summary>
            <typeparam name="T">The item type.</typeparam>
            <remarks>
            A collection of items, all of which are different according
            to Equals.  null items are not allowed.  Adding a duplicate has no effect.
            Union, intersection, and superset are all supported via operator overloading.
            The items are stored in the keys of a Dictionary that ensures uniqueness
            via its own comparer function.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.Contains(System.Collections.Generic.IList{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>result[i] is true iff the set contains list[i].</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>true if the set contains all items in list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.ContainsAny(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Test membership of all items in a collection.
            </summary>
            <param name="list"></param>
            <returns>true if the set contains any item in list.</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.Remove(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a collection.
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.op_GreaterThanOrEqual(MicrosoftResearch.Infer.Collections.Set{`0},MicrosoftResearch.Infer.Collections.Set{`0})">
            <summary>
            Superset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a superset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Set`1.op_LessThanOrEqual(MicrosoftResearch.Infer.Collections.Set{`0},MicrosoftResearch.Infer.Collections.Set{`0})">
            <summary>
            Subset operator.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns>True iff a is equal to or a subset of b.</returns>
            <remarks>null is treated as an empty set.</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.ParallelCursorArray`2">
            <summary>
            A multidimensional array of objects where each field is in a CursorArray.
            </summary>
            <typeparam name="CursorType"></typeparam>
            <typeparam name="ArrayType">A cursor-based array type, such as CursorArray or ParallelCursorArray.</typeparam>
            <remarks><para>
            A ParallelCursorArray is meant to behave like an ordinary Array, while 
            being more memory-efficient.  It uses a cursor similar to a CursorArray.
            However, the storage layout is different.  Each field of the cursor
            is stored in a separate ICursorArray, with its own inner cursor.
            By advancing these inner cursors, the outer cursor is automatically
            updated.  Thus <typeparamref name="CursorType"/> does not need to implement <c>ICursor</c>.
            For example, <typeparamref name="CursorType"/> might be <c>Array&lt;ICursor&gt;</c>, holding an array of  
            inner cursors.
            </para><para>
            There must be at least one member array, and 
            all member arrays must have the same dimensions.
            </para></remarks>
            <example>See CursorArrayTest.cs.</example>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.ParallelCursorArray`2.#ctor(`0,System.Collections.Generic.IList{`1})">
            <summary>
            Create a new ParallelCursorArray.
            </summary>
            <param name="cursor">An object to use as the cursor.</param>
            <param name="members">A list of cursor-based arrays.</param>
            <remarks>
            <paramref name="cursor"/> must already be initialized to contain
            the cursors of the arrays in <paramref name="members"/>.
            There must be at least one member array, and 
            all member arrays must have the same dimensions.
            </remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator">
            <summary>
            Class for accumulating weighted noisy scalar observations,
            and computing sample count, mean, and variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Mean">
            <summary>
            The sample mean
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Variance">
            <summary>
            Sample variance
            </summary>
        </member>
        <member name="F:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Count">
            <summary>
            Sample count
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Add(System.Double)">
            <summary>
            Adds an observation
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Add(System.Double,System.Double)">
            <summary>
            Adds a weighted observation.
            </summary>
            <param name="x"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Add(System.Double,System.Double,System.Double)">
            <summary>
            Adds a noisy observation.
            </summary>
            <param name="x"></param>
            <param name="noiseVariance"></param>
            <param name="weight"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Clear">
            <summary>
            Clears the accumulator
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.SetTo(MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator)">
            <summary>
            Sets the state of this estimator from the specified estimator.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Maths.MeanVarianceAccumulator.Clone">
            <summary>
            Returns a clone of this estimator.
            </summary>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Utils.Hash">
            <summary>
            Utilities for implementing GetHashCode().
            </summary>
            <remarks><para>
            To hash an object with two fields x and y:
            <code>return Hash.Combine(x.GetHashCode(), y.GetHashCode());</code>
            </para><para>
            To hash an array:
            <example><code>
            int hash = Hash.Start;
            for(int i = 0; i &lt; Count; i++)
            	hash = Hash.Combine(hash, this[i].GetHashCode());
            return hash;
            </code></example>
            </para><para>
            Algorithm: FNV hash from http://www.isthe.com/chongo/tech/comp/fnv/
            </para><para>
            Note: You should not use xor to combine hash codes, even though it is
            recommended by MSDN.  xor is invariant to permutation, which means
            "abc" and "bac" and "cba" will hash to the same value (bad).
            Also xoring a hash value with itself produces 0, so "aab" and "b"
            will hash to the same value (bad).
            </para></remarks>
        </member>
        <member name="F:MicrosoftResearch.Infer.Utils.Hash.Start">
            <summary>
            The recommended start value for a combined hash value
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Hash.Combine(System.Int32,System.Byte)">
            <summary>
            Combines an existing hash key with a new byte value
            </summary>
            <param name="hash">Current hash code</param>
            <param name="key">New byte of the new hash code to be integrated</param>
            <returns>A new hash-count that is neither order invariant nor "idempotent"</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            Combines two int32 hash keys
            </summary>
            <param name="hash">First hash key</param>
            <param name="key">Second hash key</param>
            <returns>Incorporates the second hash key into the first hash key and returns the new, combined hash key</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Utils.Hash.Combine(System.Int32,System.Double)">
            <summary>
            Incorporates the hash key of a double into an existing hash key
            </summary>
            <param name="hash">Exisiting hash key</param>
            <param name="number">Floating point number to incorporate</param>
            <returns>The new, combined hash key</returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Enumerable.Merge``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <summary>
            Merges two sorted lists into one list in ascending order.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list1"></param>
            <param name="list2"></param>
            <param name="comparer"></param>
            <returns></returns>
            <remarks>
            If items from list1 and list2 are equal, the items from list1 are put first.
            </remarks>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.Enumerable.Split``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Collections.Generic.List{``0}@)">
            <summary>
            Take n items from a stream, returning a stream for the remainder.
            </summary>
            <typeparam name="T">The item type.</typeparam>
            <param name="stream">A stream</param>
            <param name="count">The number of items to take from the front of the stream.</param>
            <param name="head">On return, the first <paramref name="count"/> items of the stream.</param>
            <returns>The rest of the stream.</returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray">
            <summary>
            Class that provides useful static methods for jagged arrays
            </summary>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetInnermostType(System.Type)">
            <summary>
            Gets the innermost non-array type
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetInnermostType``1">
            <summary>
            Gets the innermost non-array type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks(System.Type,System.Type)">
            <summary>
            Gets the ranks of a jagged array type when considered an array 
            </summary>
            <param name="jaggedType">The jagged array type</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks``2">
            <summary>
            Gets the ranks of a jagged array type when considered an array 
            over the specified leaf type
            </summary>
            <typeparam name="JaggedType">The jagged array type</typeparam>
            <typeparam name="LeafType">The leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks(System.Type)">
            <summary>
            Gets the ranks of a jagged array down to the first non-array type
            </summary>
            <param name="jaggedType">The jagged array type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetRanks``1">
            <summary>
            Gets the ranks of a jagged array down to the first non-array type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth(System.Type,System.Type)">
            <summary>
            Gets the depth of the jagged array when considered an
            array over the specified leaf type
            </summary>
            <param name="jaggedType"></param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth``2">
            <summary>
            Gets the depth of the jagged array when considered an
            array over the specified leaf type
            </summary>
            <typeparam name="JaggedType">Jagge array type</typeparam>
            <typeparam name="LeafType">The leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth(System.Type)">
            <summary>
            Gets the depth of the jagged array
            </summary>
            <param name="jaggedType"></param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetDepth``1">
            <summary>
            Gets the depth of the jagged array
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes(System.Type,System.Type)">
            <summary>
            Gets the types at each depth of a jagged array when
            considered as a jagged array over the specified leaf type
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <param name="leafType">Leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes(System.Type)">
            <summary>
            Gets the types at each depth of a jagged array
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes(System.Type,System.Type,System.Type)">
            <summary>
            Gets jagged array types for the target leaf type to match
            the given jagged array considered as an array over the specified
            leaf type
            </summary>
            <param name="jaggedType">Jagged array type</param>
            <param name="leafType">Leaf type</param>
            <param name="targetLeafType">Desired leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes``2">
            <summary>
            Gets the types at each depth of a jagged array when
            considered as a jagged array over the specified leaf type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <typeparam name="LeafType">Leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes``1">
            <summary>
            Gets the types at each depth of a jagged array
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetTypes``3">
            <summary>
            Gets jagged array types for the target leaf type to match
            the given jagged array considered as an array over the specified
            leaf type
            </summary>
            <typeparam name="JaggedType">Jagged array type</typeparam>
            <typeparam name="LeafType">Leaf type</typeparam>
            <typeparam name="TargetLeafType">Target leaf type</typeparam>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ElementIterator(System.Collections.IEnumerable,System.Type)">
            <summary>
            Iterates over the elements of a jagged array when considered as
            an array over the specified leaf type
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ElementIterator``1(System.Collections.IEnumerable)">
            <summary>
            Iterates over the elements of a jagged array when considered as
            an array over the specified leaf type
            </summary>
            <typeparam name="LeafType">Leaf type</typeparam>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ElementIterator(System.Collections.IEnumerable)">
            <summary>
            Iterates over the elements of a jagged array
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLength(System.Collections.IEnumerable,System.Type)">
            <summary>
            Gets the total length of the jagged array when considered as
            an array over the specified leaf type.
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLongLength(System.Collections.IEnumerable,System.Type)">
            <summary>
            Gets the total long length of the jagged array when considered as
            an array over the specified leaftype.
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <param name="leafType">The leaf type</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLength``1(System.Collections.IEnumerable)">
            <summary>
            Gets the total length of the jagged array when considered as
            an array over the specified leaf type.
            </summary>
            <typeparam name="LeafType">The leaf type</typeparam>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLongLength``1(System.Collections.IEnumerable)">
            <summary>
            Gets the total long length of the jagged array when considered as
            an array over the specified leaf type.
            </summary>
            <typeparam name="LeafType">The leaf type</typeparam>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLength(System.Collections.IEnumerable)">
            <summary>
            Gets the total length of the jagged array
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.GetLongLength(System.Collections.IEnumerable)">
            <summary>
            Gets the total long length of the jagged array
            </summary>
            <param name="jaggedArray">The jagged array</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertToNew(System.Array,System.Type,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Creates a jagged array with the same structure as another jagged array
            </summary>
            <param name="sourceArray">The source jagged array</param>
            <param name="sourceLeafType">The leaf type of the source jagged array</param>
            <param name="targetLeafType">The leaf type of the target jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertToNew(System.Array,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Creates a jagged array with the same structure as another jagged array
            </summary>
            <param name="sourceArray">The source jagged array</param>
            <param name="targetLeafType">The leaf type of the target jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertToNew``2(System.Array,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter{``0,``1})">
            <summary>
            Creates a jagged array with the same structure as another jagged array
            </summary>
            <typeparam name="SourceLeafType">Leaf type of the source jagged array</typeparam>
            <typeparam name="TargetLeafType">Leaf type of the target jagged array</typeparam>
            <param name="sourceArray">The source array</param>
            <param name="converter">The converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements(System.Array,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Sets the elements of a jagged array
            </summary>
            <param name="jaggedArray">The source jagged array</param>
            <param name="leafType">The leaf type of the jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements(System.Array,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter)">
            <summary>
            Sets the elements of a jagged array
            </summary>
            <param name="jaggedArray">The source jagged array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements2(System.Array,System.Array,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter2)">
            <summary>
            Sets the elements of a jagged array given another jagged
            </summary>
            <param name="targetArray">The target array - also acts as a source</param>
            <param name="sourceArray">The source array</param>
            <param name="leafType">The leaf type of the target array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.ConvertElements2(System.Array,System.Array,MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter2)">
            <summary>
            Sets the elements of a jagged array given another jagged
            </summary>
            <param name="targetArray">The target array - also acts as a source</param>
            <param name="sourceArray">The source array</param>
            <param name="converter">Element converter</param>
            <returns></returns>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements(System.Collections.IEnumerable,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction)">
            <summary>
            Visits all elements with the specified leaf type, and perform the action
            </summary>
            <param name="jaggedArray">Jagged array</param>
            <param name="leafType">Element type</param>
            <param name="action">Action delegate</param>
        </member>
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements(System.Collections.IEnumerable,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction)">
            <summary>
            Visits all elements and perform the action
            </summary>
            <param name="jaggedArray">Jagged array</param>
            <param name="action">Action delegate</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements2(System.Collections.IEnumerable,System.Collections.IEnumerable,System.Type,System.Type,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction2)" -->
        <member name="M:MicrosoftResearch.Infer.Collections.JaggedArray.VisitElements2(System.Collections.IEnumerable,System.Collections.IEnumerable,MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction2)">
            <summary>
            Visits all elements oftwo jagged arrays, and perform the action
            </summary>
            <param name="jaggedArray1">First jagged array</param>
            <param name="jaggedArray2">Second jagged array</param>
            <param name="action">The action to take</param>
            <remarks>There is no checking of compatibility between the two jagged arrays</remarks>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter">
            <summary>
            Delegate for jagged array element converter
            </summary>
            <param name="elt">Jagged array element</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter`2">
            <summary>
            Delegate for jagged array element converter
            </summary>
            <typeparam name="SourceLeafType">Type of leaf elements in source array</typeparam>
            <typeparam name="TargetLeafType">Type of leaf elements in target array</typeparam>
            <param name="elt"></param>
            <returns></returns>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementConverter2">
            <summary>
            Delegate for jagged array element converter
            </summary>
            <param name="elt1">Jagged array element 1</param>
            <param name="elt2">Jagged array element 2</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction">
            <summary>
            Delegate for jagged array element visitor
            </summary>
            <param name="elt">Jagged array element</param>
        </member>
        <member name="T:MicrosoftResearch.Infer.Collections.JaggedArray.ElementAction2">
            <summary>
            Delegate for generic jagged array element visitor
            </summary>
            <param name="elt1">Jagged array element 1</param>
            <param name="elt2">Jagged array element 2</param>
        </member>
    </members>
</doc>
